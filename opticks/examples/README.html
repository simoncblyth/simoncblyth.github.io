
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Examples of Opticks Usage, especially the CMake machinery &#8212; Opticks 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Opticks 0.0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Examples of Opticks Usage, especially the CMake machinery</a><ul>
<li><a class="reference internal" href="#testing-cmake-finding-externals-and-minimal-usage">Testing CMake finding externals and minimal usage</a></li>
<li><a class="reference internal" href="#cmake-finding-opticks-sub-packages">CMake finding Opticks sub-packages</a></li>
<li><a class="reference internal" href="#march-reboot-of-opengl-cuda-interop-examples">(2024 March) Reboot of OpenGL + CUDA Interop examples</a></li>
<li><a class="reference internal" href="#examples-directly-using-nvidia-optix">Examples Directly Using NVIDIA OptiX</a><ul>
<li><a class="reference internal" href="#optix-pre7-usage-examples">OptiX pre7 usage examples</a></li>
<li><a class="reference internal" href="#standalone-ish-optix-5-or-6-examples">Standalone-ish OptiX 5 or 6 Examples</a></li>
<li><a class="reference internal" href="#experimental-pre7-and-7-machinery">Experimental pre7 and 7 machinery</a></li>
<li><a class="reference internal" href="#standalone-ish-optix-7-examples">Standalone-ish OptiX 7 Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/examples/README.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="examples-of-opticks-usage-especially-the-cmake-machinery">
<h1><a class="toc-backref" href="#id1">Examples of Opticks Usage, especially the CMake machinery</a><a class="headerlink" href="#examples-of-opticks-usage-especially-the-cmake-machinery" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#examples-of-opticks-usage-especially-the-cmake-machinery" id="id1">Examples of Opticks Usage, especially the CMake machinery</a><ul>
<li><a class="reference internal" href="#testing-cmake-finding-externals-and-minimal-usage" id="id2">Testing CMake finding externals and minimal usage</a></li>
<li><a class="reference internal" href="#cmake-finding-opticks-sub-packages" id="id3">CMake finding Opticks sub-packages</a></li>
<li><a class="reference internal" href="#march-reboot-of-opengl-cuda-interop-examples" id="id4">(2024 March) Reboot of OpenGL + CUDA Interop examples</a></li>
<li><a class="reference internal" href="#examples-directly-using-nvidia-optix" id="id5">Examples Directly Using NVIDIA OptiX</a><ul>
<li><a class="reference internal" href="#optix-pre7-usage-examples" id="id6">OptiX pre7 usage examples</a></li>
<li><a class="reference internal" href="#standalone-ish-optix-5-or-6-examples" id="id7">Standalone-ish OptiX 5 or 6 Examples</a></li>
<li><a class="reference internal" href="#experimental-pre7-and-7-machinery" id="id8">Experimental pre7 and 7 machinery</a></li>
<li><a class="reference internal" href="#standalone-ish-optix-7-examples" id="id9">Standalone-ish OptiX 7 Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>The examples have go.sh scripts which perform the normal
config, make, install using a fresh build dir every time.
This is a convenient when the focus is on the CMake machinery.</p>
<div class="section" id="testing-cmake-finding-externals-and-minimal-usage">
<h2><a class="toc-backref" href="#id2">Testing CMake finding externals and minimal usage</a><a class="headerlink" href="#testing-cmake-finding-externals-and-minimal-usage" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>UsePLog</dt>
<dd>simple executable using PLog via imported interface target
from cmake/Modules/FindPLog.cmake</dd>
<dt>UseGLMRaw</dt>
<dd><p class="first">(plain vanilla modern CMake with target import/export)</p>
<ul class="last simple">
<li>find_package(GLM) succeeds due to cmake/Modules/FindGLM.cmake which
exports the Opticks::GLM interface only target
(GLM is just headers)</li>
<li>vending targets as of CMake 3.5 takes lots of boilerplate</li>
</ul>
</dd>
<dt>UseUseGLM</dt>
<dd><p class="first">(plain vanilla modern CMake)</p>
<ul class="last simple">
<li>find_package(UseGLM) succeed due to the exported target written by UseGLM</li>
<li>nice and simple : plain CMake is fine when consuming
targets only without vending.</li>
<li>Note that only need to be concerned with direct dependency on UseGLM.
The dependency of UseGLM on GLM comes along with the imported target with no effort.</li>
<li>Also note that the dependency transmission is working across package boundaries,
ie UseGLM and UseUseGLM are not tied together in a single CMake build,
they are entirely separate projects.</li>
</ul>
</dd>
<dt>UseGLMViaBCM</dt>
<dd><blockquote class="first">
<div>(modern CMake assisted by BCM)</div></blockquote>
<ul class="last simple">
<li>much less boilerplate, intent is clear</li>
<li>forced(?) to place headers into an include folder in source dir</li>
<li>forced(?) in install at prefix/include rather than current opticks location prefix/include/name/</li>
<li>HMM: NOT KEEN ON CO-MINGLING HEADERS OF ALL PROJECTS IN A SINGLE include DIR, OR ON HAVING
THE HASSLE OF SEPARATE include DIR for sources</li>
</ul>
</dd>
</dl>
<p>UseUseGLMViaBCM</p>
<blockquote>
<div><ul class="simple">
<li>similar observations to UseUseGLM</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>UseOpticksBoost</dt>
<dd>no longer operational exercise for the old variable-centric approach to Boost hookup</dd>
<dt>UseBoost</dt>
<dd><p class="first">Attempt to vend a library target that uses Boost::filesystem:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">16</span> <span class="n">find_package</span><span class="p">(</span><span class="n">Boost</span> <span class="n">REQUIRED</span> <span class="n">COMPONENTS</span> <span class="n">filesystem</span><span class="p">)</span>
<span class="mi">17</span>
<span class="mi">18</span> <span class="c1">## kludge that tees up arguments to find_dependency in generated export useboost-config.cmake</span>
<span class="mi">19</span> <span class="c1">## so downstream will automatically do the above find_package</span>
<span class="mi">20</span> <span class="n">set_target_properties</span><span class="p">(</span><span class="n">Boost</span><span class="p">::</span><span class="n">filesystem</span> <span class="n">PROPERTIES</span> <span class="n">INTERFACE_FIND_PACKAGE_NAME</span> <span class="s2">&quot;Boost REQUIRED COMPONENTS filesystem&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>UseUseBoost</dt>
<dd><p class="first">attempt to use the lib target exported from UseBoost, initially failed to auto hookup
the non-direct Boost::filesystem dependent, because useboost-config.cmake had:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">include</span><span class="p">(</span><span class="n">CMakeFindDependencyMacro</span><span class="p">)</span>
<span class="c1"># Library: Boost::filesystem</span>
<span class="n">find_dependency</span><span class="p">(</span><span class="n">Boost</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{CMAKE_CURRENT_LIST_DIR}</span><span class="s2">/useboost-targets.cmake&quot;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{CMAKE_CURRENT_LIST_DIR}</span><span class="s2">/properties-useboost-targets.cmake&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Suspect problem is that the non-BCM exported targets lack some needed metadata ? YEP, BCM
relies on setting target properties in bcm_deploy that get read on generating the exported target
serialization.  Kludge fix is to misuse that property as shown above, so that the imported target
automatically does the necessary:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">find_dependency</span><span class="p">(</span><span class="n">Boost</span> <span class="n">REQUIRED</span> <span class="n">COMPONENTS</span> <span class="n">filesystem</span><span class="p">)</span>
<span class="c1"># this works with cmake_minimum_version set to 3.5 with cmake 3.11</span>
</pre></div>
</div>
</dd>
<dt>UseOpenMesh</dt>
<dd>check consumption of BCM exported targets done by cmake/Modules/FindOpenMesh.cmake</dd>
<dt>UseG4NoOpticks</dt>
<dd>used to develop a new FindG4.cmake that works with both Geant4 1042 and 1062,
does not use Opticks at all : requires BCM and Geant4 to be installed
and provided on CMAKE_PREFIX_PATH</dd>
<dt>UseUseG4NoOpticks</dt>
<dd>paired with UseG4NoOpticks, creating an executable that uses the lib from UseG4NoOpticks</dd>
</dl>
</div>
<div class="section" id="cmake-finding-opticks-sub-packages">
<h2><a class="toc-backref" href="#id3">CMake finding Opticks sub-packages</a><a class="headerlink" href="#cmake-finding-opticks-sub-packages" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>UseSysRap</dt>
<dd>vends a library that uses the SysRap target exported by sysrap/CMakeLists.txt</dd>
<dt>UseUseSysRap</dt>
<dd>uses the UseSysRap exported library, succeeds to auto-find the dependencies (SysRap)
of its direct dependent UseSysRap</dd>
<dt>UseBoostRap</dt>
<dd>testing dependency isolation of BoostRap</dd>
<dt>UseNPY(needs-revisit)</dt>
<dd><p class="first">old first attempt using raw inclusion of exported targets with
the non-standard approach of cmake -DOPTICKS_CONFIG_DIR=/usr/local/opticks/config
rather than using the standard find_package mechanism</p>
<ul class="last simple">
<li>exporting was done in opticksnpy/CMakeLists.txt
BUT: this approach is jumping into the thicket of the dependency tree.  Better to
get experience out in the leaves, before tackling the interior of the bush.</li>
</ul>
</dd>
<dt>UseOpticksGLFW</dt>
<dd>minimal use of OpenGL via GLFW, pops up a window and renders a colorful rotating triangle.
Key presses cause the GLFW_KEY_XX enum name to be emitted to stdout. Press ESCAPE to exit.</dd>
<dt>UseOpticksGLFWSnap</dt>
<dd>variant of UseOpticksGLFW adding the capability to save screen images to PPM files</dd>
<dt>UseOpticksGLFWSPPM</dt>
<dd>variant of UseOpticksGLFWSnap with the PPM handling from reusable sysrap/SPPM</dd>
<dt>UseShader</dt>
<dd><p class="first">Formerly named UseOpticksGLFWShader</p>
<ul class="simple">
<li>adapted GLFW example, modified to use GLEW and GLM : it ran giving a black screen.</li>
<li>adding a VAO makes the coloured triangle appear</li>
<li>added error checking and compilation log output</li>
</ul>
<p class="last">This is a good starting point for creating self contained minimal reproducers.</p>
</dd>
<dt>UseOGLRapMinimal</dt>
<dd>Creates red-green-blue axes that can interact with using the usual controls.
Tests the Rdr axis renderer in isolation using just Composition, Frame and Interactor
(no Scene).</dd>
<dt>UseGeometryShader</dt>
<dd><p class="first">Creates red-green-blue axes</p>
<p>Implemented in standalone single file fashion that sets up a geometry shader
pipeline using the same shader strings as the Rdr axis renderer
as used by UseOGLRapMinimal.  All the mat4 have been matched with
UseOGLRapMinimal.</p>
<p>Features a monolithic standalone getMVP, providing the ModelViewProjection matrix, which
is useful for demo code.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="p">::</span><span class="n">mat4</span> <span class="n">getMVP</span><span class="p">(</span><span class="nb">int</span> <span class="n">width</span><span class="p">,</span> <span class="nb">int</span> <span class="n">height</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">verbose</span><span class="p">)</span>
</pre></div>
</div>
<p>Actually it was the comparison of the mat4 between
UseOGLRapMinimal which uses View::getTransforms
and my standalone reimplementation of the matrix manipulations
in UseGeometryShader that led to finding the “uninitialized forth row bug”
that has been lurking for years ready to bite just at the wrong time
following a Linux kernel and driver update and OptiX update.</p>
<p class="last">See the mis-named: notes/issues/OGLRap_GLFW_OpenGL_Linux_display_issue_with_new_driver.rst</p>
</dd>
<dt>UseOGLRap</dt>
<dd>same as OGLRap AxisAppCheck</dd>
<dt>UseOpticksGL</dt>
<dd>OAxisTest appears to be trying to change things with OptiX launches whilsy displaying with OpenGL</dd>
<dt>UseOpticksGLEW</dt>
<dd>Just dumping version numbers from header. CMake machinery test.</dd>
</dl>
</div>
<div class="section" id="march-reboot-of-opengl-cuda-interop-examples">
<h2><a class="toc-backref" href="#id4">(2024 March) Reboot of OpenGL + CUDA Interop examples</a><a class="headerlink" href="#march-reboot-of-opengl-cuda-interop-examples" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>UseGeometryShader</dt>
<dd><p class="first">record array rec_flying_point viz using early stage of SGLFW.h encapulation</p>
<ul class="last simple">
<li>NB build.sh script is unusual, it builds against OpenGL without using CMake (working on Darwin and Linux)</li>
</ul>
</dd>
<dt>UseShaderSGLFW</dt>
<dd>single triangle</dd>
<dt>UseShaderSGLFW_Mesh</dt>
<dd>single mesh</dd>
<dt>UseShaderSGLFW_MeshMesh</dt>
<dd>multiple mesh</dd>
<dt>UseShaderSGLFW_MeshMesh_Instanced</dt>
<dd>with instancing</dd>
<dt>UseShaderSGLFW_SScene</dt>
<dd>get SMesh and instance transforms from SScene</dd>
<dt>UseShaderSGLFW_SScene_encapsulated</dt>
<dd>moving impl into SGLFW_Scene.h</dd>
</dl>
</div>
<div class="section" id="examples-directly-using-nvidia-optix">
<h2><a class="toc-backref" href="#id5">Examples Directly Using NVIDIA OptiX</a><a class="headerlink" href="#examples-directly-using-nvidia-optix" title="Permalink to this headline">¶</a></h2>
<p>The below sections list examples using OptiX, named after directory names.
Many of the examples are standalone in nature, not depending on an Opticks install.
The steps to build (and sometimes run) are often simply:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">~/</span><span class="n">opticks</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">UseOptiX</span>
<span class="o">./</span><span class="n">go</span><span class="o">.</span><span class="n">sh</span>

<span class="n">cd</span> <span class="o">~/</span><span class="n">opticks</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">UseOptiX7GeometryInstanced</span>
<span class="o">./</span><span class="n">go</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<div class="section" id="optix-pre7-usage-examples">
<h3><a class="toc-backref" href="#id6">OptiX pre7 usage examples</a><a class="headerlink" href="#optix-pre7-usage-examples" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>UseOptiX</dt>
<dd>really minimal usage of OptiX C API, checking creation of context and buffer,
no kernel launching</dd>
<dt>UseOptiXProgram</dt>
<dd>OptiX C API creates raygen program and launches it, just dumping launch index</dd>
<dt>UseOptiXProgramPP</dt>
<dd>OptiX C++ API variant of the above : provides a command line interface to quickly run
simple OptiX code (no buffers in context).</dd>
<dt>UseOptiXBuffer</dt>
<dd>OptiX C API creates raygen program that just writes constant values to a buffer</dd>
<dt>UseOptiXBufferPP</dt>
<dd>OptiX C++ API : creates in and out buffers from NPY arrays and launches a program that
simply copies from in to out.  Provides a command line interface to quickly run variants
of the buffer accessing GPU code.</dd>
<dt>UseOptiXGeometry</dt>
<dd>Minimally demonstrate OptiX geometry without using OXRAP, performs a “standalone” raytrace
of a box with normal shader coloring.</dd>
<dt>UseOptiXGeometryTriangles</dt>
<dd><p class="first">Minimally demonstrate the use of optix::GeometryTriangles introduced in OptiX 6.0.0.
Raytraces an octahedron writing a PPM file.
Based on NPY and SYSRAP for buffer and PPM handling. No OXRAP.</p>
<ul class="last simple">
<li><a class="reference external" href="https://raytracing-docs.nvidia.com/optix/api/html/group___geometry_triangles.html">https://raytracing-docs.nvidia.com/optix/api/html/group___geometry_triangles.html</a></li>
</ul>
</dd>
<dt>UseOContextBufferPP</dt>
<dd>Use the OptiXRap.OContext to reimplement UseOptiXBufferPP in a higher level style,
hoping to approach close enough to UseOptiXRap for the problem to manifest.
But it hasnt.</dd>
<dt>UseOptiXRap</dt>
<dd><p class="first">Uses Opticks higher level OptiXRap API to test changing the sizes of buffers.</p>
<p>Issue with OptiX 6.0.0 : the buffer manipulations seem to work but the rtPrintf
output does not appear unless the buffer writing is commented out.</p>
<p>Huh, now rtPrintf seems to be working without any clear fix.
Now not working.
Now working again, immediately after an oxrap–</p>
<p>Perhaps a problem of host code being updated and PTX not, because the
PTX is from oxrap ?</p>
<p>Can change the progname via envvar:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">USEOPTIXRAP_PROGNAME</span><span class="o">=</span><span class="s2">&quot;bufferTest_2&quot;</span> <span class="n">UseOptiXRap</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="standalone-ish-optix-5-or-6-examples">
<h3><a class="toc-backref" href="#id7">Standalone-ish OptiX 5 or 6 Examples</a><a class="headerlink" href="#standalone-ish-optix-5-or-6-examples" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>UseOptiXTexture</dt>
<dd>C API 3D texture creation, with pullback test into out_buffer</dd>
<dt>UseOptiXTextureLayered</dt>
<dd>Switch from 3D to layered 2D texture, <em>exfill</em> attempt to fill with MapEx failed</dd>
<dt>UseOptiXTextureLayeredPP</dt>
<dd>Convert to use OptiX 6 C++ API</dd>
<dt>UseOptiXTextureLayeredOK</dt>
<dd>Start encapsulation into Make2DLayeredTexture</dd>
<dt>UseOptiXTextureLayeredOKImg</dt>
<dd>Use ImageNPY::LoadPPM to load images into textures
First try at 2d layered tex failed, so reverted to 2d textures.</dd>
<dt>UseOptiXTextureLayeredOKImgGeo</dt>
<dd><p class="first">Ray-traced theta-phi texture mapping onto a sphere, when using an Earth texture this provides
Earth view PPM images centered around any latitude-longitude position.
This example was used to develop the watertight OptiX OCtx wrapper (C opaque pointer style)
which does not leak any optix types into its interface.</p>
<p class="last">Intersects are highly instrumented with the position of each interesect recorded into a pos buffer.</p>
</dd>
<dt>UseOptiXGeometryInstanced</dt>
<dd><p class="first">start from UseOptiXGeometryInstancedStandalone, plan:</p>
<ol class="arabic simple">
<li>DONE: Opticks packages to reduce the amount of code</li>
<li>DONE: adopt OCtx watertight wrapper, adding whats needed for instancing</li>
<li>DONE: add optional switch from box to sphere</li>
<li>DONE: generate PPM of thousands of textured Earths</li>
</ol>
<p class="last">jumble of thousands of spheres gradient shaded with red/green/blue border/midline/quadline</p>
</dd>
<dt>UseOptiXGeometryInstancedOCtx</dt>
<dd><p class="first">start from UseOptiXGeometryInstanced, using just OCtx</p>
<p>/tmp/octx.sh               : normal shaded assembly of boxes and spheres
/tmp/octx.sh global        : global shaded assembly of boxes and spheres
/tmp/octx.sh textured,tex1 : textured assembly of boxes and spheres, using tex1 green midline</p>
<p>/tmp/octx.sh single        : normal shaded single box and sphere
/tmp/octx.sh single,textured,tex1    : single box and sphere</p>
<p>/tmp/octx.sh textest,tex0  : vertical gradient with red border
/tmp/octx.sh textest,tex1  : vertical gradient with green midlines
/tmp/octx.sh textest,tex2  : vertical gradient with blue quadlines</p>
<p>ISSUE</p>
<p>on Linux/OptiX 6.5 the spheres are appearing as big boxes but there
is no problem with the sphere implementation when used not in an assembly.
Perhaps problem with the transforms/scaling/bbox ?</p>
<p>ISSUE HAS DISAPPEARED</p>
<p class="last">Returning to this issue after implementing IntersectSDF to automatically
test for such problems find that the problem is no longer happening.</p>
</dd>
<dt>UseOptiXGeometryOCtx</dt>
<dd>start from UseOptiXGeometry to investigate why getting problem with instanced spheres in OptiX 6.5
Creates PPM of a single normal-shaded sphere or box picked via argument sphere.cu or box.cu</dd>
<dt>UseOptiXGeometryInstancedStandalone</dt>
<dd>creates a jumble of thousands of randomly oriented boxes, colorfully normal-shaded</dd>
</dl>
</div>
<div class="section" id="experimental-pre7-and-7-machinery">
<h3><a class="toc-backref" href="#id8">Experimental pre7 and 7 machinery</a><a class="headerlink" href="#experimental-pre7-and-7-machinery" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>UseOpticksOptiX</dt>
<dd>checking FindOpticksOptiX.cmake can be made to work with 5,6 and 7</dd>
</dl>
</div>
<div class="section" id="standalone-ish-optix-7-examples">
<h3><a class="toc-backref" href="#id9">Standalone-ish OptiX 7 Examples</a><a class="headerlink" href="#standalone-ish-optix-7-examples" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>UseOptiX7</dt>
<dd>Basic check of CMake machinery, finding OptiX 7</dd>
<dt>UseOptiX7GeometryStandalone</dt>
<dd>Start from the SDK optixSphere example
This example uses custom(aka analytic or non-triangulated) geometry.
Follows the monolithic main layout of optixSphere, just adapting to use glm for
viewpoint math. (Feb 2024: updated for OptiX 7.5+)</dd>
<dt>UseOptiX7GeometryModular</dt>
<dd><p class="first">Start from UseOptiX7GeometryStandalone
Apply wrecking ball to the monolith, splitting into:</p>
<dl class="docutils">
<dt>Engine</dt>
<dd>context, control</dd>
<dt>Binding</dt>
<dd>common types between CPU and GPU</dd>
<dt>PIP</dt>
<dd>pipeline of programs creation and updating</dd>
<dt>GAS</dt>
<dd>geometry acceleration structure building</dd>
</dl>
<p class="last">Revisited this, tidying up the headers aiming to
eliminate optix types from high levels in order to hide the version.
(Feb 2024: updated for OptiX 7.5+)</p>
</dd>
<dt>UseOptiX7GeometryInstanced</dt>
<dd>Attempting to switch UseOptiX7GeometryModular to use an
instanced custom geometry for lots of spheres.
(Feb 2024: updated for OptiX 7.5+)</dd>
<dt>UseOptiX7GeometryInstancedGAS</dt>
<dd><p class="first">Started from UseOptiX7GeometryInstanced.</p>
<ol class="arabic simple">
<li>pulled out the higher level geometry setup into Geo</li>
<li>uses a single IAS with multiple GAS</li>
<li>create big sphere containing a cube grid of two radii,
where the intersect program gets its sphere radius from
Sbt record</li>
</ol>
<p class="last">(Feb 2024: updated for OptiX 7.5+)</p>
</dd>
<dt>UseOptiX7GeometryInstancedGASComp</dt>
<dd>Started from UseOptiX7GeometryInstancedGAS.
(Feb 2024: updated for OptiX 7.5+)</dd>
<dt>UseOptiX7GeometryInstancedGASCompDyn</dt>
<dd>SBT mechanics worked out, using vectors of BI structs to keep count
Find that have to fudge the bbox larger to get expected results ?
(Feb 2024: updated for OptiX 7.5+)</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Opticks 0.0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Simon C Blyth.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
  </body>
</html>