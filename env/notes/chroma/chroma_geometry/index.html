<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chroma Geometry Source Overview &mdash; Env  documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/highstock/highstock.js"></script>
    <script type="text/javascript" src="../../_static/highstock/modules/exporting.js"></script>
    <link rel="top" title="Env  documentation" href="../../" />
    <link rel="up" title="chroma" href="../" />
    <link rel="next" title="Chroma Materials" href="../chroma_materials/" />
    <link rel="prev" title="Getting to know how Chroma uses PyCUDA" href="../chroma_pycuda/" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../chroma_materials/" title="Chroma Materials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../chroma_pycuda/" title="Getting to know how Chroma uses PyCUDA"
             accesskey="P">previous</a> |</li>
    <li><a href="/tracs/env/timeline">env</a> &raquo;</li>
    
        <li><a href="../../">Env  documentation</a> &raquo;</li>

          <li><a href="../" accesskey="U">chroma</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><h3>Links</h3>
<ul class="this-page-menu">
	<li><a href="/tracs/env"> env </a>  <a href="/tracs/env/timeline"> tl </a> <a href="/repos/env/trunk"> repo </a> <a href="/e"> edocs </a> </li>
	<li><a href="/tracs/heprez"> heprez </a>  <a href="/tracs/heprez/timeline"> tl </a> <a href="/repos/heprez/trunk"> repo</a> <a href="/h">hdocs</a>   </li>
        <li><a href="/e/scm/monitor/" > backup status </a> </li>
</ul>

<h3>Content Skeleton</h3>

<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../install/">Installing <strong>env</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../base/">Base Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../log/May2012/">LOG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../TODO/">TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sysadmin/">Sys Admin</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plot/">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scm/">SCM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trac/">Trac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../root/">ROOT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sphinxext/">Sphinx Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../matplotlib/">Matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nose/">nose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../svn/">SVN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../npy/">Numerical Python, numpy et al</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pypy/">PyPy : faster python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mysqlhotcopy/">MySQL hotcopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mysql/">MySQL Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sqlite/">SQLite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../db/">DB scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qxml/">QXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fossil/">Fossil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../java/">Java Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cuda/">cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pycuda/">pycuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../geant4/">geant4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../muon_simulation/">muon_simulation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../">chroma</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../chroma_issues/">Chroma Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma/">CHROMA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how_chroma_works/">How Chroma Works ?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/">Chroma Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs/">Chroma Refs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_prerequisites/">Chroma Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_geant4_integration/">Chroma Geant4 Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_nuwa_geant4_integration/">Chroma/NuWa/Geant4 Integration with ZeroMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_nuwa_integration/">Chroma NuWa Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_cuda_photon/">Chroma CUDA Photon handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_collada/">Chroma COLLADA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_pycuda/">Getting to know how Chroma uses PyCUDA</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Chroma Geometry Source Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_materials/">Chroma Materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_propagate/">Photon Propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_physics/">Chroma Physics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_detector/">Chroma Modeling of Sensitive Detectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_server/">Chroma Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_zeromq/">Chroma ZeroMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_camera/">chroma_camera</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_sim/">chroma_sim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_cuda_freeze/">Chroma CUDA Freeze</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_cuda/">Chroma CUDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_visualisation/">Chroma Visualisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../geant4_background/">Geant4 Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cuda_background/">Cuda Threads and Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bvh_background/">Bounding Volume Hierarchy (BVH)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/">Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_install/">install issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chroma_tests/">tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ChromaZMQRootTest/">ChromaZMQRootTest</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../llvm/">llvm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../graphics/">Graphics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cuda/">cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../opencl/">opencl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../linux/">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cloud/">Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../package_management/">Package Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ui/">ui</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../debugging/">debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mercurial/">mercurial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../javascript/">javascript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nuwa/">nuwa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ccgpu/">ccgpu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pygame/">pygame</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zeromq/">zeromq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/">doc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python/">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../osx/">osx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hg/">hg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simoncblyth.bitbucket.org/">simoncblyth.bitbucket.org</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/chroma/chroma_geometry.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
  <h4>Previous topic</h4>
  <p class="topless"><a href="../chroma_pycuda/"
                        title="previous chapter">Getting to know how Chroma uses PyCUDA</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../chroma_materials/"
                        title="next chapter">Chroma Materials</a></p>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chroma-geometry-source-overview">
<h1>Chroma Geometry Source Overview<a class="headerlink" href="#chroma-geometry-source-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="where-is-geometry-populated">
<h2>where is geometry populated<a class="headerlink" href="#where-is-geometry-populated" title="Permalink to this headline">¶</a></h2>
<p>So where is <cite>Geometry</cite> populated:</p>
<div class="highlight-python"><pre>(chroma_env)delta:cuda blyth$ grep geometry_types.h *.*
bvh.cu:#include "geometry_types.h"
geometry.h:#include "geometry_types.h"    # device funcs that query the geometry, accessing nodes/triangles etc..</pre>
</div>
<p>From python with <cite>chroma/gpu/geometry.py:GPUGeometry</cite> using <cite>pycuda.gpuarray</cite> and <cite>chroma.gpu.tools.make_gpu_struct</cite></p>
</div>
<div class="section" id="chroma-cuda-geometry-types-h">
<h2>chroma/cuda/geometry_types.h<a class="headerlink" href="#chroma-cuda-geometry-types-h" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>46 struct Node
47 {
48     float3 lower;
49     float3 upper;
50     unsigned int child;
51     unsigned int nchild;
52 };
53
54 struct Geometry
55 {
56     float3 *vertices;
57     uint3 *triangles;
58     unsigned int *material_codes;
59     unsigned int *colors;
60     uint4 *primary_nodes;
61     uint4 *extra_nodes;
62     Material **materials;
63     Surface **surfaces;
64     float3 world_origin;
65     float world_scale;
66     int nprimary_nodes;
67 };</pre>
</div>
<ul class="simple">
<li><a class="reference external" href="http://stackoverflow.com/a/4838734">http://stackoverflow.com/a/4838734</a></li>
</ul>
</div>
<div class="section" id="chroma-gpu-geometry-py">
<h2>chroma/gpu/geometry.py<a class="headerlink" href="#chroma-gpu-geometry-py" title="Permalink to this headline">¶</a></h2>
<p>GPUGeometry class that converts into GPU side geometry using CUDA types from <cite>geometry_types.h</cite></p>
<div class="highlight-python"><pre>simon:chroma blyth$ find . -name '*.py' -exec grep -H GPUGeometry {} \;

./camera.py:        self.gpu_geometry = gpu.GPUGeometry(self.geometry)
./camera.py:                gpu_geometry = gpu.GPUGeometry(geometry, print_usage=False)
./camera.py:        gpu_geometry = gpu.GPUGeometry(geometry)

./gpu/detector.py:from chroma.gpu.geometry import GPUGeometry
./gpu/detector.py:class GPUDetector(GPUGeometry):
./gpu/detector.py:        GPUGeometry.__init__(self, detector, wavelengths=wavelengths, print_usage=False)

./gpu/geometry.py:class GPUGeometry(object):

./sim.py:            self.gpu_geometry = gpu.GPUGeometry(detector)


(chroma_env)delta:chroma blyth$ find ../bin -type f -exec grep -H GPUGeometry {} \;

../bin/chroma-bvh:from chroma.gpu.geometry import GPUGeometry
../bin/chroma-bvh:    gpu_geometry = GPUGeometry(geometry)</pre>
</div>
<div class="section" id="gpugeometry">
<h3>GPUGeometry<a class="headerlink" href="#gpugeometry" title="Permalink to this headline">¶</a></h3>
<p>GPU <cite>Geometry</cite> struct is constructed and populated from the below python using</p>
<ul class="simple">
<li><cite>pycuda.gpuarray</cite><ul>
<li><a class="reference external" href="http://documen.tician.de/pycuda/array.html">http://documen.tician.de/pycuda/array.html</a></li>
</ul>
</li>
<li><cite>chroma.gpu.tools.make_gpu_struct</cite></li>
</ul>
<p><cite>chroma/gpu/geometry.py</cite>:</p>
<div class="highlight-python"><pre>13 class GPUGeometry(object):
14     def __init__(self, geometry, wavelengths=None, print_usage=False, min_free_gpu_mem=300e6):
15         if wavelengths is None:
16             wavelengths = standard_wavelengths
17
18         try:
19             wavelength_step = np.unique(np.diff(wavelengths)).item()
20         except ValueError:
21             raise ValueError('wavelengths must be equally spaced apart.')
22
23         geometry_source = get_cu_source('geometry_types.h')
24         material_struct_size = characterize.sizeof('Material', geometry_source)
25         surface_struct_size = characterize.sizeof('Surface', geometry_source)
26         geometry_struct_size = characterize.sizeof('Geometry', geometry_source)
27
..</pre>
</div>
<p>The materials/surfaces/mesh from the python geometry object are transferred over
to the GPU and <cite>Geometry</cite> struct is created to hold the pointers.</p>
<p>Some fiddly splitting of data between GPU and CPU ?:</p>
<div class="highlight-python"><pre>196 def Mapped(array):
197     '''Analog to pycuda.driver.InOut(), but indicates this array
198     is memory mapped to the device space and should not be copied.
199
200     To simplify coding, Mapped() will pass anything with a gpudata
201     member, like a gpuarray, through unchanged.
202     '''
203     if hasattr(array, 'gpudata'):
204         return array
205     else:
206         return np.intp(array.base.get_device_pointer())

In [91]: np.intp
Out[91]: numpy.int32</pre>
</div>
<p>Heavy lifting of getting geometry onto GPU:</p>
<div class="highlight-python"><pre>134         self.vertices = mapped_empty(shape=len(geometry.mesh.vertices),
135                                      dtype=ga.vec.float3,
136                                      write_combined=True)
137         self.triangles = mapped_empty(shape=len(geometry.mesh.triangles),
138                                       dtype=ga.vec.uint3,
139                                       write_combined=True)
140         self.vertices[:] = to_float3(geometry.mesh.vertices)
141         self.triangles[:] = to_uint3(geometry.mesh.triangles)
142

143         self.world_origin = ga.vec.make_float3(*geometry.bvh.world_coords.world_origin)
144         self.world_scale = np.float32(geometry.bvh.world_coords.world_scale)

145
146         material_codes = (((geometry.material1_index &amp; 0xff) &lt;&lt; 24) |
147                           ((geometry.material2_index &amp; 0xff) &lt;&lt; 16) |
148                           ((geometry.surface_index &amp; 0xff) &lt;&lt; 8)).astype(np.uint32)
149         self.material_codes = ga.to_gpu(material_codes)

///   packing 3 single byte indices (0:255) into unint32 with low byte empty

In [110]: "0x%x" %  (((0xaa &amp; 0xff) &lt;&lt; 24) | ((0xbb &amp; 0xff) &lt;&lt; 16) |  ((0xcc &amp; 0xff) &lt;&lt; 8))
Out[110]: '0xaabbcc00'



150         colors = geometry.colors.astype(np.uint32)
151         self.colors = ga.to_gpu(colors)

152         self.solid_id_map = ga.to_gpu(geometry.solid_id.astype(np.uint32))
153


154         # Limit memory usage by splitting BVH into on and off-GPU parts
155         gpu_free, gpu_total = cuda.mem_get_info()
156         node_array_usage = geometry.bvh.nodes.nbytes
157
158         # Figure out how many elements we can fit on the GPU,
159         # but no fewer than 100 elements, and no more than the number of actual nodes
160         n_nodes = len(geometry.bvh.nodes)
161         split_index = min(
162             max(int((gpu_free - min_free_gpu_mem) / geometry.bvh.nodes.itemsize),100),
163             n_nodes
164             )
165
166         self.nodes = ga.to_gpu(geometry.bvh.nodes[:split_index])
167         n_extra = max(1, (n_nodes - split_index)) # forbid zero size
168         self.extra_nodes = mapped_empty(shape=n_extra,
169                                         dtype=geometry.bvh.nodes.dtype,
170                                         write_combined=True)
171         if split_index &lt; n_nodes:
172             logger.info('Splitting BVH between GPU and CPU memory at node %d' % split_index)
173             self.extra_nodes[:] = geometry.bvh.nodes[split_index:]
174
175         # See if there is enough memory to put the and/ortriangles back on the GPU
176         gpu_free, gpu_total = cuda.mem_get_info()
177         if self.triangles.nbytes &lt; (gpu_free - min_free_gpu_mem):
178             self.triangles = ga.to_gpu(self.triangles)
179             logger.info('Optimization: Sufficient memory to move triangles onto GPU')
180
181         gpu_free, gpu_total = cuda.mem_get_info()
182         if self.vertices.nbytes &lt; (gpu_free - min_free_gpu_mem):
183             self.vertices = ga.to_gpu(self.vertices)
184             logger.info('Optimization: Sufficient memory to move vertices onto GPU')
185
186         self.gpudata = make_gpu_struct(geometry_struct_size,
187                                        [Mapped(self.vertices),
188                                         Mapped(self.triangles),
189                                         self.material_codes,
190                                         self.colors, self.nodes,
191                                         Mapped(self.extra_nodes),
192                                         self.material_pointer_array,
193                                         self.surface_pointer_array,
194                                         self.world_origin,
195                                         self.world_scale,
196                                         np.int32(len(self.nodes))])</pre>
</div>
</div>
<div class="section" id="material-and-surface-indices-packed-into-material-codes">
<h3>material and surface indices packed into material_codes<a class="headerlink" href="#material-and-surface-indices-packed-into-material-codes" title="Permalink to this headline">¶</a></h3>
<p>Hmm, there are loadsa materials and surfaces, so whats this <cite>material_codes</cite> qty ?:</p>
<div class="highlight-python"><pre>145
146         material_codes = (((geometry.material1_index &amp; 0xff) &lt;&lt; 24) |
147                           ((geometry.material2_index &amp; 0xff) &lt;&lt; 16) |
148                           ((geometry.surface_index &amp; 0xff) &lt;&lt; 8)).astype(np.uint32)
149         self.material_codes = ga.to_gpu(material_codes)

///   packing 3 single byte indices (0:255) into unint32 with low byte empty

In [110]: "0x%x" %  (((0xaa &amp; 0xff) &lt;&lt; 24) | ((0xbb &amp; 0xff) &lt;&lt; 16) |  ((0xcc &amp; 0xff) &lt;&lt; 8))
Out[110]: '0xaabbcc00'

In [130]: (np.array([(1&lt;&lt;8)-1, (1&lt;&lt;8), (1&lt;&lt;8)+1 ]) &amp; 0xff ).astype(np.uint32)
Out[130]: array([255,   0,   1], dtype=uint32)</pre>
</div>
<p>chroma/geometry.py:</p>
<div class="highlight-python"><pre>301     def flatten(self):
302         """
303         Create the flat list of triangles (and triangle properties)
304         from the list of solids in this geometry.
305
306         This does not build the BVH!  If you want to use the geometry
307         for rendering or simulation, you should call build() instead.
308         """
309
310         # Don't run this function twice!
311         if hasattr(self, 'mesh'):
312             return
313
314         nv = np.cumsum([0] + [len(solid.mesh.vertices) for solid in self.solids])
315         nt = np.cumsum([0] + [len(solid.mesh.triangles) for solid in self.solids])
316
317         vertices = np.empty((nv[-1],3), dtype=np.float32)
318         triangles = np.empty((nt[-1],3), dtype=np.uint32)
319
320
321         logger.info('Flattening detector mesh...')
322         logger.info('  triangles: %d' % len(triangles))
323         logger.info('  vertices:  %d' % len(vertices))
324
325
326         for i, solid in enumerate(self.solids):
327             vertices[nv[i]:nv[i+1]] = \
328                 np.inner(solid.mesh.vertices, self.solid_rotations[i]) + self.solid_displacements[i]
329             triangles[nt[i]:nt[i+1]] = solid.mesh.triangles + nv[i]
330
331         # Different solids are very unlikely to share vertices, so this goes much faster
332         self.mesh = Mesh(vertices, triangles, remove_duplicate_vertices=False)
333
334         self.colors = np.concatenate([solid.color for solid in self.solids])
335
336         self.solid_id = np.concatenate([filled_array(i, shape=len(solid.mesh.triangles), dtype=np.uint32) for i, solid in enumerate(self.solids)])
337
338         self.unique_materials = list(np.unique(np.concatenate([solid.unique_materials for solid in self.solids])))
339
340         material_lookup = dict(zip(self.unique_materials, range(len(self.unique_materials))))
//
//          map from material to its unique index
//
341
342         self.material1_index = np.concatenate([solid.material1_indices(material_lookup) for solid in self.solids])
343
//          array of material1 indices of every triangle in every solid
//
344         self.material2_index = np.concatenate([solid.material2_indices(material_lookup) for solid in self.solids])
345
346         self.unique_surfaces = list(np.unique(np.concatenate([solid.unique_surfaces for solid in self.solids])))
347
348         surface_lookup = dict(zip(self.unique_surfaces, range(len(self.unique_surfaces))))
349
350         self.surface_index = np.concatenate([solid.surface_indices(surface_lookup) for solid in self.solids])
351
352         try:
353             self.surface_index[self.surface_index == surface_lookup[None]] = -1
354         except KeyError:
355             pass
356</pre>
</div>
<p>chroma/cuda/photon.h:</p>
<div class="highlight-python"><pre>79 __device__ void
80 fill_state(State &amp;s, Photon &amp;p, Geometry *g)
81 {
82     p.last_hit_triangle = intersect_mesh(p.position, p.direction, g,
83                                          s.distance_to_boundary,
84                                          p.last_hit_triangle);
85
86     if (p.last_hit_triangle == -1) {
87         p.history |= NO_HIT;
88         return;
89     }
90
91     Triangle t = get_triangle(g, p.last_hit_triangle);
92
93     unsigned int material_code = g-&gt;material_codes[p.last_hit_triangle];
94
95     int inner_material_index = convert(0xFF &amp; (material_code &gt;&gt; 24));
96     int outer_material_index = convert(0xFF &amp; (material_code &gt;&gt; 16));
97     s.surface_index = convert(0xFF &amp; (material_code &gt;&gt; 8));


In [135]: "0x%x" % (0xff &amp; (0xaabbcc00 &gt;&gt; 24 ))
Out[135]: '0xaa'

In [136]: "0x%x" % (0xff &amp; (0xaabbcc00 &gt;&gt; 16 ))
Out[136]: '0xbb'

In [137]: "0x%x" % (0xff &amp; (0xaabbcc00 &gt;&gt; 8 ))
Out[137]: '0xcc'

98
99     float3 v01 = t.v1 - t.v0;
00     float3 v12 = t.v2 - t.v1;
01
02     s.surface_normal = normalize(cross(v01, v12));
03
04     Material *material1, *material2;
05     if (dot(s.surface_normal,-p.direction) &gt; 0.0f) {
06         // outside to inside
07         material1 = g-&gt;materials[outer_material_index];
08         material2 = g-&gt;materials[inner_material_index];
09
10         s.inside_to_outside = false;
11     }
12     else {
13         // inside to outside
14         material1 = g-&gt;materials[inner_material_index];
15         material2 = g-&gt;materials[outer_material_index];
16         s.surface_normal = -s.surface_normal;
17
18         s.inside_to_outside = true;
19     }
20
21     s.refractive_index1 = interp_property(material1, p.wavelength,
22                                           material1-&gt;refractive_index);
23     s.refractive_index2 = interp_property(material2, p.wavelength,
24                                           material2-&gt;refractive_index);
25     s.absorption_length = interp_property(material1, p.wavelength,
26                                           material1-&gt;absorption_length);
27     s.scattering_length = interp_property(material1, p.wavelength,
28                                           material1-&gt;scattering_length);
29     s.reemission_prob = interp_property(material1, p.wavelength,
30                                         material1-&gt;reemission_prob);
31
32     s.material1 = material1;
33 } // fill_state</pre>
</div>
</div>
</div>
<div class="section" id="chroma-loader-py">
<h2>chroma/loader.py<a class="headerlink" href="#chroma-loader-py" title="Permalink to this headline">¶</a></h2>
<p><cite>def load_geometry_from_string</cite></p>
<div class="highlight-python"><pre>28       "filename.stl" or "filename.stl.bz2" - Create a geometry from a
29           3D mesh on disk.  This model will not be cached, but the
30           BVH can be, depending on whether update_bvh_cache is True.</pre>
</div>
</div>
<div class="section" id="chroma-stl-py">
<h2>chroma/stl.py<a class="headerlink" href="#chroma-stl-py" title="Permalink to this headline">¶</a></h2>
<p>Parse STL files (simple format of vertices and triangles) into Mesh objects.</p>
</div>
<div class="section" id="chroma-geometry-py">
<h2>chroma/geometry.py<a class="headerlink" href="#chroma-geometry-py" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Is the below wavelength comment outdated ?</li>
</ul>
<p>My impression was that the wavelengths used are held in the material/surface
structs and interpolated as appropriate.:</p>
<div class="highlight-python"><pre>15 # all material/surface properties are interpolated at these
16 # wavelengths when they are sent to the gpu
17 standard_wavelengths = np.arange(60, 810, 20).astype(np.float32)
18
19 class Mesh(object):
20     "Triangle mesh object."
21     def __init__(self, vertices, triangles, remove_duplicate_vertices=False):
22         vertices = np.asarray(vertices, dtype=np.float32)
23         triangles = np.asarray(triangles, dtype=np.int32)</pre>
</div>
<p>Python side geometry</p>
<ul class="simple">
<li><cite>Geometry</cite>, a detector_material and a list of Solids, rotations and displacements<ul>
<li><cite>flatten</cite> method determines global unique_materials, unique_surfaces from those for each solid</li>
</ul>
</li>
<li><cite>Solid</cite>, attaches materials, surfaces, and colors to each triangle in the Mesh object argument</li>
<li><cite>Mesh</cite> , comprising arrays of vertices and triangles</li>
<li><cite>Material</cite>, with name and wavelength dependant property arrays:<ul>
<li>refractive_index</li>
<li>absorption_length</li>
<li>scattering_length</li>
<li>reemission_prob</li>
<li>reemission_cdf</li>
<li>density</li>
<li>composition</li>
</ul>
</li>
<li><cite>Surface</cite>, with name and model and wavelength dependant optical property arrays:<ul>
<li>detect/absort/reemit/reflect_diffuse/reflect_specular/eta/k/reemission_cdf/thickness/transmissive</li>
</ul>
</li>
</ul>
<div class="section" id="q-where-all-these-properties-getting-set">
<h3>Q: where all these properties getting set ?<a class="headerlink" href="#q-where-all-these-properties-getting-set" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>not in the STL, thats a very simple list of vertices/triangles</li>
</ul>
<p>Chroma geometry construction currently done in &#8220;ad-hoc&#8221; python such as <cite>chroma/demo/__init__.py</cite>,
Not out of some &#8220;standard&#8221; file format, like G4DAE COLLADA+metadata</p>
</div>
</div>
<div class="section" id="chroma-bvh-class-chroma-bvh-bvh-py">
<h2>Chroma BVH class chroma/bvh/bvh.py<a class="headerlink" href="#chroma-bvh-class-chroma-bvh-bvh-py" title="Permalink to this headline">¶</a></h2>
<p>A bounding volume hierarchy for a triangle mesh.</p>
<p>For the purposes of Chroma, a BVH is a tree with the following properties:</p>
<ul class="simple">
<li>Each node consists of an axis-aligned bounding box, a child ID
number, and a boolean flag indicating whether the node is a
leaf.  The bounding box is represented as a lower and upper
bound for each Cartesian axis.</li>
</ul>
<div class="section" id="id1">
<h3>chroma/cuda/geometry_types.h<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><pre>46 struct Node
47 {
48     float3 lower;
49     float3 upper;
50     unsigned int child;
51     unsigned int nchild;
52 };</pre>
</div>
<ul class="simple">
<li>All nodes are stored in a 1D array with the root node first.</li>
<li>A node with a bounding box that has no surface area (upper and
lower bounds equal for all axes) is a dummy node that should
be ignored.  Dummy nodes are used to pad the tree to satisfy
the fixed degree requirement described below, and have no
children.</li>
<li>If the node is a leaf, then the child ID number refers to the
ID number of the triangle this node contains.</li>
<li>If the node is not a leaf (an &#8220;inner&#8221; node), then the child ID
number indicates the offset in the node array of the first
child.  The other children of this node will be stored
immediately after the first child.</li>
<li>All inner nodes have the same number of children, called the
&#8220;degree&#8221; (technically the &#8220;out-degree&#8221;) of the tree.  This
avoid the requirement to save the degree with the node.</li>
<li>For simplicity, we also require nodes at the same depth
in the tree to be contiguous, and the layers to be in order
of increasing depth.</li>
<li>All nodes satisfy the <strong>bounding volume hierarchy constraint</strong>:
their bounding boxes contain the bounding boxes of all their
children.</li>
</ul>
<p>For space reasons, the BVH bounds are internally represented using
16-bit unsigned fixed point coordinates.  Normally, we would want
to hide that from you, but we would like to avoid rounding issues
and high memory usage caused by converting back and forth between
floating point and fixed point representations.  For similar
reasons, the node array is stored in a packed record format that
can be directly mapped to the GPU.  In general, you will not need
to manipulate the contents of the BVH node array directly.</p>
</div>
</div>
<div class="section" id="chroma-cuda-mesh-h">
<h2>chroma/cuda/mesh.h<a class="headerlink" href="#chroma-cuda-mesh-h" title="Permalink to this headline">¶</a></h2>
<p>Stack based recursive tree walk:</p>
<div class="highlight-python"><pre>36 /* Finds the intersection between a ray and `geometry`. If the ray does
37    intersect the mesh and the index of the intersected triangle is not equal
38    to `last_hit_triangle`, set `min_distance` to the distance from `origin` to
39    the intersection and return the index of the triangle which the ray
40    intersected, else return -1. */
41 __device__ int
42 intersect_mesh(const float3 &amp;origin, const float3&amp; direction, Geometry *g,
43            float &amp;min_distance, int last_hit_triangle = -1)
44 {
45     int triangle_index = -1;
46</pre>
</div>
<div class="sidebar">
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../chroma_materials/" title="Chroma Materials"
             >next</a> |</li>
        <li class="right" >
          <a href="../chroma_pycuda/" title="Getting to know how Chroma uses PyCUDA"
             >previous</a> |</li>
    <li><a href="/tracs/env/timeline">env</a> &raquo;</li>
    
        <li><a href="../../">Env  documentation</a> &raquo;</li>

          <li><a href="../" >chroma</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Simon C Blyth.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>