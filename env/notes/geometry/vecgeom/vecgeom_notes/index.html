<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>VecGeom Notes &mdash; Env  documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/highstock/highstock.js"></script>
    <script type="text/javascript" src="../../../_static/highstock/modules/exporting.js"></script>
    <link rel="top" title="Env  documentation" href="../../../" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="/tracs/env/timeline">env</a> &raquo;</li>
    
        <li><a href="../../../">Env  documentation</a> &raquo;</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><h3>Links</h3>
<ul class="this-page-menu">
	<li><a href="/tracs/env"> env </a>  <a href="/tracs/env/timeline"> tl </a> <a href="/repos/env/trunk"> repo </a> <a href="/e"> edocs </a> </li>
	<li><a href="/tracs/heprez"> heprez </a>  <a href="/tracs/heprez/timeline"> tl </a> <a href="/repos/heprez/trunk"> repo</a> <a href="/h">hdocs</a>   </li>
        <li><a href="/e/scm/monitor/" > backup status </a> </li>
</ul>

<h3>Content Skeleton</h3>

<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/">Installing <strong>env</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../base/">Base Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../log/May2012/">LOG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../TODO/">TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sysadmin/">Sys Admin</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plot/">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scm/">SCM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trac/">Trac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../root/">ROOT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sphinxext/">Sphinx Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../matplotlib/">Matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nose/">nose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../svn/">SVN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../npy/">Numerical Python, numpy et al</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pypy/">PyPy : faster python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mysqlhotcopy/">MySQL hotcopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mysql/">MySQL Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sqlite/">SQLite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../db/">DB scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qxml/">QXML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fossil/">Fossil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../java/">Java Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cuda/">cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pycuda/">pycuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../geant4/">geant4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../muon_simulation/">muon_simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chroma/">chroma</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../llvm/">llvm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphics/">Graphics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ggeoview/">ggeoview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../oglrap/">oglrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cfg4/">cfg4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cuda/">cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../opencl/">opencl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../linux/">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cloud/">Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../package_management/">Package Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ui/">ui</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../debugging/">debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mercurial/">mercurial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../javascript/">javascript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nuwa/">nuwa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ccgpu/">ccgpu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pygame/">pygame</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zeromq/">zeromq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc/">doc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../python/">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../osx/">osx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hg/">hg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../simoncblyth.bitbucket.org/">simoncblyth.bitbucket.org</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../numpy/">numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../presentation/">Muon Simulation Presentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optix/">optix</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/geometry/vecgeom/vecgeom_notes.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="vecgeom-notes">
<h1>VecGeom Notes<a class="headerlink" href="#vecgeom-notes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="thoughts-on-vecgeom-gpu-from-a-very-brief-usage-attempt-and-code-look">
<h2>Thoughts on VecGeom GPU from a very brief usage attempt and code look<a class="headerlink" href="#thoughts-on-vecgeom-gpu-from-a-very-brief-usage-attempt-and-code-look" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>too stuck in Geant4 geometry model mindset<ul>
<li>tiny volumes are one-by-one copied to GPU</li>
<li>stuck in the each shape is an object mindset,
on the GPU or just when you have many thousands of volumes it
makes more sense to think lower level : entries in a buffer</li>
<li>looks like no repeated volume instancing in the
graphics sense</li>
</ul>
</li>
<li>contrasting the way OptiX geometry is setup to VecGeom it
seems plain that VecGeom aint going to be interfaceable
into the OptiX/Opticks way of geometry handling</li>
<li>VecGeom implemention may however help with ideas
on how to structure a less manual analytic geometry
approach</li>
<li>examining VecGeom makes me appreciate what OptiX provides</li>
<li>also the very particular way OptiX needs intersection code setup:</li>
</ul>
</div>
<div class="section" id="optix-intersection">
<h2>OptiX intersection<a class="headerlink" href="#optix-intersection" title="Permalink to this headline">¶</a></h2>
<p>Very particular tmin/tmax squeeze approach implemented via rtPotentialIntersection, rtReportIntersection pairs.
Other than intersection algorithm ideas there seems little way that VecGeom could help.:</p>
<div class="highlight-python"><pre>884 static __device__
885 void intersect_box(quad&amp; q0, quad&amp; q1, quad&amp; q2, quad&amp; q3, const uint4&amp; identity)
886 {
887
888   const float3 min_ = make_float3(q0.f.x - q0.f.w, q0.f.y - q0.f.w, q0.f.z - q0.f.w );
889   const float3 max_ = make_float3(q0.f.x + q0.f.w, q0.f.y + q0.f.w, q0.f.z + q0.f.w );
890   const float3 cen_ = make_float3(q0.f.x, q0.f.y, q0.f.z) ;
891
892   float3 t0 = (min_ - ray.origin)/ray.direction;
893   float3 t1 = (max_ - ray.origin)/ray.direction;
894
895   // slab method
896   float3 near = fminf(t0, t1);
897   float3 far = fmaxf(t0, t1);
898   float tmin = fmaxf( near );
899   float tmax = fminf( far );
900
901   if(tmin &lt;= tmax &amp;&amp; tmax &gt; 0.f)
902   {
903       bool check_second = true;
904       float tint = tmin &gt; 0.f ? tmin : tmax ;
905
906       if(rtPotentialIntersection(tint))
907       {
908           float3 p = ray.origin + tint*ray.direction - cen_ ;
909           float3 pa = make_float3(fabs(p.x), fabs(p.y), fabs(p.z)) ;
910           float pmax = fmaxf(pa);
911
912           float3 n = make_float3(0.f) ;
913           if(      pa.x &gt;= pa.y &amp;&amp; pa.x &gt;= pa.z ) n.x = copysignf( 1.f , p.x ) ;
914           else if( pa.y &gt;= pa.x &amp;&amp; pa.y &gt;= pa.z ) n.y = copysignf( 1.f , p.y ) ;
915           else if( pa.z &gt;= pa.x &amp;&amp; pa.z &gt;= pa.y ) n.z = copysignf( 1.f , p.z ) ;
916
917
918           shading_normal = geometric_normal = n ;
919           instanceIdentity = identity ;
920           if(rtReportIntersection(0)) check_second = false ;   // material index 0
921       }
922
923       // handle when inside box, or are epsilon near clipped
924       if(check_second)
925       {
926           if(rtPotentialIntersection(tmax))</pre>
</div>
</div>
<div class="section" id="refs">
<h2>Refs<a class="headerlink" href="#refs" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://indico.cern.ch/event/289682/contributions/664274/attachments/540916/745663/johannes_concurrency_forum_3.pdf">http://indico.cern.ch/event/289682/contributions/664274/attachments/540916/745663/johannes_concurrency_forum_3.pdf</a></li>
</ul>
</div>
<div class="section" id="cuda-usage-in-vecgeom">
<h2>Cuda Usage in VecGeom<a class="headerlink" href="#cuda-usage-in-vecgeom" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>simon:VecGeom blyth$ find . -type f -exec grep -H CudaManager.h {} \;
./management/CudaManager.h:/// \file CudaManager.h
./management/CudaManager_0.h:/// \file CudaManager.h
./navigation/NavigationState.h:#include "management/CudaManager.h"
./navigation/NavStatePool.h:#include "management/CudaManager.h"
./source/benchmarking/Benchmarker.cpp:#include "management/CudaManager.h"
./source/benchmarking/Benchmarker.cu:#include "management/CudaManager.h"
./source/benchmarking/NavigationBenchmarker.cpp:#include "management/CudaManager.h"
./source/benchmarking/NavigationBenchmarker.cu:#include "management/CudaManager.h"
./source/CudaManager.cpp:#include "management/CudaManager.h"
./source/CudaManager.cu:#include "management/CudaManager.h"
./source/UnplacedBooleanVolume.cpp:#include "management/CudaManager.h"
./source/UnplacedScaledShape.cpp:#include "management/CudaManager.h"
./test/benchmark/OrbBenchmark.cpp:#include "management/CudaManager.h"
./test/core/create_geometry.cpp:#include "management/CudaManager.h"
./test/core/TestNavigationStatePool.cpp:#include "management/CudaManager.h"
./test/root/ImportFromRootFileTest.cpp:#include "management/CudaManager.h"
./userexamples/src/TestNavigationStatePool.cu:#include "management/CudaManager.h"</pre>
</div>
</div>
<div class="section" id="benchmark-asserts">
<h2>Benchmark asserts<a class="headerlink" href="#benchmark-asserts" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>simon:VecGeom.build blyth$ lldb ./TubeBenchmark
(lldb) target create "./TubeBenchmark"
Current executable set to './TubeBenchmark' (x86_64).
(lldb) r
Process 22650 launched: './TubeBenchmark' (x86_64)
INFO: using default 10240 for option -npoints
INFO: using default 1 for option -nrep
INFO: using default 0 for option -rmin
INFO: using default 5 for option -rmax
INFO: using default 10 for option -dz
INFO: using default 0 for option -sphi
INFO: using default 6.28319 for option -dphi
PlacedVolume created after geometry is closed --&gt; will not be registered
PlacedVolume created after geometry is closed --&gt; will not be registered
Running Contains and Inside benchmark for 10240 points for 1 repetitions.
Generating points with bias 0.500000... Done in 0.006851 s.
Vectorized    - Inside: 0.001402s (0.001402s), Contains: 0.001406s (0.001406s), Inside/Contains: 1.00
Specialized   - Inside: 0.001209s (0.001209s), Contains: 0.001192s (0.001192s), Inside/Contains: 1.01
Unspecialized - Inside: 0.001211s (0.001211s), Contains: 0.001182s (0.001182s), Inside/Contains: 1.02
CUDA          - ScanGeometry found pvolumes2
Allocating placed volume Assertion failed: (&amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr), function AllocatePlacedVolumesOnCoproc, file /usr/local/env/geometry/VecGeom/source/CudaManager.cpp, line 256.
Process 22650 stopped
* thread #1: tid = 0xf34e2, 0x00007fff8f97a866 libsystem_kernel.dylib`__pthread_kill + 10, queue = 'com.apple.main-thread', stop reason = signal SIGABRT
    frame #0: 0x00007fff8f97a866 libsystem_kernel.dylib`__pthread_kill + 10
libsystem_kernel.dylib`__pthread_kill + 10:
-&gt; 0x7fff8f97a866:  jae    0x7fff8f97a870            ; __pthread_kill + 20
   0x7fff8f97a868:  movq   %rax, %rdi
   0x7fff8f97a86b:  jmp    0x7fff8f977175            ; cerror_nocancel
   0x7fff8f97a870:  retq
(lldb) bt
* thread #1: tid = 0xf34e2, 0x00007fff8f97a866 libsystem_kernel.dylib`__pthread_kill + 10, queue = 'com.apple.main-thread', stop reason = signal SIGABRT
  * frame #0: 0x00007fff8f97a866 libsystem_kernel.dylib`__pthread_kill + 10
    frame #1: 0x00007fff8701735c libsystem_pthread.dylib`pthread_kill + 92
    frame #2: 0x00007fff8dd67b1a libsystem_c.dylib`abort + 125
    frame #3: 0x00007fff8dd319bf libsystem_c.dylib`__assert_rtn + 321
    frame #4: 0x0000000104f1e945 libvecgeomcuda.so`vecgeom::cxx::CudaManager::AllocatePlacedVolumesOnCoproc(this=0x00000001000ac838) + 277 at CudaManager.cpp:256
    frame #5: 0x0000000104f1c870 libvecgeomcuda.so`vecgeom::cxx::CudaManager::AllocateGeometry(this=0x00000001000ac838) + 1424 at CudaManager.cpp:311
    frame #6: 0x0000000104f1a147 libvecgeomcuda.so`vecgeom::cxx::CudaManager::Synchronize(this=0x00000001000ac838) + 183 at CudaManager.cpp:66
    frame #7: 0x0000000104f0f272 libvecgeomcuda.so`vecgeom::Benchmarker::GetVolumePointers(this=0x00007fff5fbfe630, volumesGpu=0x00007fff5fbfce48) + 98 at Benchmarker.cpp:2670
    frame #8: 0x0000000104ebbda9 libvecgeomcuda.so`vecgeom::Benchmarker::RunInsideCuda(this=0x00007fff5fbfe630, posX=0x000000010b805c00, posY=0x000000010b819c00, posZ=0x000000010b82dc00, contains=0x000000010b867a00, inside=0x000000010b86a200) + 329 at Benchmarker.cu:78
    frame #9: 0x000000010005580e TubeBenchmark`vecgeom::Benchmarker::RunInsideBenchmark(this=0x00007fff5fbfe630) + 3806 at Benchmarker.cpp:723
    frame #10: 0x00000001000548b8 TubeBenchmark`vecgeom::Benchmarker::RunBenchmark(this=0x00007fff5fbfe630) + 104 at Benchmarker.cpp:623
    frame #11: 0x00000001000027bb TubeBenchmark`benchmark(rmin=0, rmax=5, dz=10, sphi=0, dphi=6.2831853071795862, npoints=10240, nrep=1) + 523 at TubeBenchmark.cpp:29
    frame #12: 0x0000000100003013 TubeBenchmark`main(argc=1, argv=0x00007fff5fbfee18) + 1827 at TubeBenchmark.cpp:42
    frame #13: 0x00007fff8aded5fd libdyld.dylib`start + 1
    frame #14: 0x00007fff8aded5fd libdyld.dylib`start + 1
(lldb)

(lldb) f 10
frame #10: 0x00000001000548b8 TubeBenchmark`vecgeom::Benchmarker::RunBenchmark(this=0x00007fff5fbfe630) + 104 at Benchmarker.cpp:623
   620  {
   621    assert(fWorld != nullptr);
   622    int errorcode = 0;
-&gt; 623    errorcode += RunInsideBenchmark();
   624    errorcode += RunToInBenchmark();
   625    errorcode += RunToOutBenchmark();
   626    if (fMeasurementCount == 1) errorcode += CompareMetaInformation();

(lldb) f 9
frame #9: 0x000000010005580e TubeBenchmark`vecgeom::Benchmarker::RunInsideBenchmark(this=0x00007fff5fbfe630) + 3806 at Benchmarker.cpp:723
   720      if (fOkToRunROOT) RunInsideRoot(containsRoot);
   721  #endif
   722  #ifdef VECGEOM_CUDA
-&gt; 723      RunInsideCuda(fPointPool-&gt;x(), fPointPool-&gt;y(), fPointPool-&gt;z(), containsCuda, insideCuda);
   724  #endif
   725    }

(lldb) f 8
frame #8: 0x0000000104ebbda9 libvecgeomcuda.so`vecgeom::Benchmarker::RunInsideCuda(this=0x00007fff5fbfe630, posX=0x000000010b805c00, posY=0x000000010b819c00, posZ=0x000000010b82dc00, contains=0x000000010b867a00, inside=0x000000010b86a200) + 329 at Benchmarker.cu:78
   75     if (fVerbosity &gt; 0) printf("CUDA          - ");
   76
   77     std::list&lt;CudaVolume&gt; volumesGpu;
-&gt; 78     GetVolumePointers(volumesGpu);
   79
   80     vecgeom::cuda::LaunchParameters launch = vecgeom::cuda::LaunchParameters(fPointCount);

(lldb) f 7
frame #7: 0x0000000104f0f272 libvecgeomcuda.so`vecgeom::Benchmarker::GetVolumePointers(this=0x00007fff5fbfe630, volumesGpu=0x00007fff5fbfce48) + 98 at Benchmarker.cpp:2670
   2667 void Benchmarker::GetVolumePointers(std::list&lt;DevicePtr&lt;cuda::VPlacedVolume&gt;&gt; &amp;volumesGpu)
   2668 {
   2669   CudaManager::Instance().LoadGeometry(GetWorld());
-&gt; 2670   CudaManager::Instance().Synchronize();
   2671   for (std::list&lt;VolumePointers&gt;::const_iterator v = fVolumes.begin(); v != fVolumes.end(); ++v) {
   2672     volumesGpu.push_back(CudaManager::Instance().LookupPlaced(v-&gt;Specialized()));
   2673   }

(lldb) f 6
frame #6: 0x0000000104f1a147 libvecgeomcuda.so`vecgeom::cxx::CudaManager::Synchronize(this=0x00000001000ac838) + 183 at CudaManager.cpp:66
   63
   64     // Populate the memory map with GPU addresses
   65
-&gt; 66     AllocateGeometry();
   67
   68     // Create new objects with pointers adjusted to point to GPU memory, then
   69     // copy them to the allocated memory locations on the GPU.

(lldb) f 5
frame #5: 0x0000000104f1c870 libvecgeomcuda.so`vecgeom::cxx::CudaManager::AllocateGeometry(this=0x00000001000ac838) + 1424 at CudaManager.cpp:311
   308
   309    // the allocation for placed volumes is a bit different (due to compact buffer treatment), so we call a specialized
   310    // function
-&gt; 311    AllocatePlacedVolumesOnCoproc(); // for placed volumes
   312
   313    // this we should only do if not using inplace transformations
   314    AllocateCollectionOnCoproc("transformations", transformations_);

(lldb) f 4
frame #4: 0x0000000104f1e945 libvecgeomcuda.so`vecgeom::cxx::CudaManager::AllocatePlacedVolumesOnCoproc(this=0x00000001000ac838) + 277 at CudaManager.cpp:256
   253    size_t totalSize = 0;
   254    // calculate total size of buffer on GPU to hold the GPU copies of the collection
   255    for (unsigned int i = 0; i &lt; size; ++i) {
-&gt; 256      assert(&amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr);
   257      totalSize += (&amp;GeoManager::gCompactPlacedVolBuffer[i])-&gt;DeviceSizeOf();
   258    }
   259</pre>
</div>
<div class="highlight-python"><pre>239 // a special treatment for placed volumes to ensure same order of placed volumes in compact buffer
240 // as on CPU
241 bool CudaManager::AllocatePlacedVolumesOnCoproc()
242 {
243   // check if geometry is closed
244   if (!GeoManager::Instance().IsClosed()) {
245     std::cerr &lt;&lt; "Warning: Geometry on host side MUST be closed before copying to DEVICE\n";
246   }
247
248   // we start from the compact buffer on the CPU
249   unsigned int size = placed_volumes_.size();
250
251   //   if (verbose_ &gt; 2) std::cout &lt;&lt; "Allocating placed volume ";
252   std::cerr &lt;&lt; "Allocating placed volume ";
253   size_t totalSize = 0;
254   // calculate total size of buffer on GPU to hold the GPU copies of the collection
255   for (unsigned int i = 0; i &lt; size; ++i) {
256     assert(&amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr);
257     totalSize += (&amp;GeoManager::gCompactPlacedVolBuffer[i])-&gt;DeviceSizeOf();
258   }
259</pre>
</div>
<div class="highlight-python"><pre>simon:VecGeom.build blyth$ ./OrbBenchmark
INFO: using default 10240 for option -npoints
INFO: using default 1 for option -nrep
INFO: using default 3 for option -r
PlacedVolume created after geometry is closed --&gt; will not be registered
PlacedVolume created after geometry is closed --&gt; will not be registered
Running Contains and Inside benchmark for 10240 points for 1 repetitions.
Generating points with bias 0.500000... Done in 0.007703 s.
Vectorized    - Inside: 0.001440s (0.001440s), Contains: 0.001325s (0.001325s), Inside/Contains: 1.09
Specialized   - Inside: 0.001386s (0.001386s), Contains: 0.001216s (0.001216s), Inside/Contains: 1.14
Unspecialized - Inside: 0.001507s (0.001507s), Contains: 0.001328s (0.001328s), Inside/Contains: 1.13
CUDA          - ScanGeometry found pvolumes2
Allocating placed volume Assertion failed: (&amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr), function AllocatePlacedVolumesOnCoproc, file /usr/local/env/geometry/VecGeom/source/CudaManager.cpp, line 256.
Abort trap: 6</pre>
</div>
<p>Huh in debugger looks like the assert should be satisfied:</p>
<div class="highlight-python"><pre>(lldb) f 4
frame #4: 0x0000000104f14945 libvecgeomcuda.so`vecgeom::cxx::CudaManager::AllocatePlacedVolumesOnCoproc(this=0x00000001000a8418) + 277 at CudaManager.cpp:256
   253    size_t totalSize = 0;
   254    // calculate total size of buffer on GPU to hold the GPU copies of the collection
   255    for (unsigned int i = 0; i &lt; size; ++i) {
-&gt; 256      assert(&amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr);
   257      totalSize += (&amp;GeoManager::gCompactPlacedVolBuffer[i])-&gt;DeviceSizeOf();
   258    }
   259
(lldb) p i
(unsigned int) $0 = 0
(lldb) p GeoManager::gCompactPlacedVolBuffer
(vecgeom::cxx::VPlacedVolume *) $1 = 0x000000010b6284b0
(lldb) p GeoManager::gCompactPlacedVolBuffer[0]
(vecgeom::cxx::VPlacedVolume) $2 = {
  id_ = 0
  label_ = "paraboloid"
  logical_volume_ = 0x00007fff5fbfec48
  fTransformation = {
    fTranslation = ([0] = 0, [1] = 0, [2] = 0)
    fRotation = ([0] = 1, [1] = 0, [2] = 0, [3] = 0, [4] = 1, [5] = 0, [6] = 0, [7] = 0, [8] = 1)
    fIdentity = true
    fHasRotation = false
    fHasTranslation = false
  }
  bounding_box_ = 0x0000000000000000
}
(lldb) p GeoManager::gCompactPlacedVolBuffer
(vecgeom::cxx::VPlacedVolume *) $3 = 0x000000010b6284b0
(lldb) p i
(unsigned int) $4 = 0
(lldb) p GeoManager::gCompactPlacedVolBuffer[i]
(vecgeom::cxx::VPlacedVolume) $5 = {
  id_ = 0
  label_ = "paraboloid"
  logical_volume_ = 0x00007fff5fbfec48
  fTransformation = {
    fTranslation = ([0] = 0, [1] = 0, [2] = 0)
    fRotation = ([0] = 1, [1] = 0, [2] = 0, [3] = 0, [4] = 1, [5] = 0, [6] = 0, [7] = 0, [8] = 1)
    fIdentity = true
    fHasRotation = false
    fHasTranslation = false
  }
  bounding_box_ = 0x0000000000000000
}
(lldb) p &amp;GeoManager::gCompactPlacedVolBuffer[i]
(vecgeom::cxx::VPlacedVolume *) $6 = 0x000000010b6284b0
(lldb) p nullptr
(nullptr_t) $7 = 0x0000000000000000
(lldb) p &amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr
(bool) $8 = true
(lldb)</pre>
</div>
<p>Smth fishy:</p>
<div class="highlight-python"><pre>(lldb) p &amp;GeoManager::gCompactPlacedVolBuffer[i]
(vecgeom::cxx::VPlacedVolume *) $4 = 0x000000010b628540
(lldb) p vpv
(vecgeom::cxx::VPlacedVolume *) $5 = 0x0000000000000000
(lldb) p size
(unsigned int) $6 = 2</pre>
</div>
<div class="highlight-python"><pre>simon:VecGeom.build blyth$ ./OrbBenchmark
INFO: using default 10240 for option -npoints
INFO: using default 1 for option -nrep
INFO: using default 3 for option -r
PlacedVolume created after geometry is closed --&gt; will not be registered
PlacedVolume created after geometry is closed --&gt; will not be registered
Running Contains and Inside benchmark for 10240 points for 1 repetitions.
Generating points with bias 0.500000... Done in 0.008925 s.
Vectorized    - Inside: 0.001493s (0.001493s), Contains: 0.001388s (0.001388s), Inside/Contains: 1.08
Specialized   - Inside: 0.001301s (0.001301s), Contains: 0.001245s (0.001245s), Inside/Contains: 1.04
Unspecialized - Inside: 0.001467s (0.001467s), Contains: 0.001243s (0.001243s), Inside/Contains: 1.18
CUDA          - ScanGeometry found pvolumes2
Starting synchronization to GPU.
Allocating geometry on GPU...Allocating logical volumes... OK
Allocating unplaced volumes... OK
Allocating placed volume Assertion failed: (vpv != nullptr), function AllocatePlacedVolumesOnCoproc, file /usr/local/env/geometry/VecGeom/source/CudaManager.cpp, line 259.
Abort trap: 6
simon:VecGeom.build blyth$</pre>
</div>
<div class="highlight-python"><pre>simon:VecGeom blyth$ find . -type f -exec grep -H PlacedVolume\ created\ after\ geometry\ is\ closed {} \;
./source/GeoManager.cpp:    std::cerr &lt;&lt; "PlacedVolume created after geometry is closed --&gt; will not be registered\n";</pre>
</div>
<div class="highlight-python"><pre>simon:VecGeom blyth$ find . -type f -exec grep -H gCompactPlacedVolBuffer {} \;
./management/CudaManager.h:// extern __device__ VPlacedVolume *gCompactPlacedVolBuffer;
./management/GeoManager.h:  static VPlacedVolume *gCompactPlacedVolBuffer;
./navigation/NavigationState.h:    return &amp;vecgeom::GeoManager::gCompactPlacedVolBuffer[index];
./navigation/NavigationState.h:    // (failed preveously due to undefined symbol vecgeom::cuda::GeoManager::gCompactPlacedVolBuffer)
./services/NavigationSpecializer.cpp:    outstream &lt;&lt; "VPlacedVolume const * pvol = &amp;GeoManager::gCompactPlacedVolBuffer[" &lt;&lt; fTargetVolIds[transitionid]

./source/CudaGlobalSymbols.cu:__device__ VPlacedVolume *gCompactPlacedVolBuffer;

./source/CudaManager.cpp:           (size_t)(&amp;GeoManager::gCompactPlacedVolBuffer[0]) + sizeof(vecgeom::cxx::VPlacedVolume) * (*i)-&gt;id());
./source/CudaManager.cpp:    VPlacedVolume* vpv = &amp;GeoManager::gCompactPlacedVolBuffer[i] ;
./source/CudaManager.cpp:    //assert(&amp;GeoManager::gCompactPlacedVolBuffer[i] != nullptr);
./source/CudaManager.cpp:    //totalSize += (&amp;GeoManager::gCompactPlacedVolBuffer[i])-&gt;DeviceSizeOf();
./source/CudaManager.cpp:  // since the pointers in GeoManager::gCompactPlacedVolBuffer are sorted by the volume id, we are
./source/CudaManager.cpp:    VPlacedVolume const *ptr                  = &amp;GeoManager::gCompactPlacedVolBuffer[i];

./source/CudaManager.cu:static __device__ VPlacedVolume *gCompactPlacedVolBuffer = nullptr;
./source/CudaManager.cu:  return gCompactPlacedVolBuffer;

./source/CudaManager_0.cu:static __device__ VPlacedVolume *gCompactPlacedVolBuffer = nullptr;
./source/CudaManager_0.cu:  return gCompactPlacedVolBuffer;

./source/GeoManager.cpp:VPlacedVolume *GeoManager::gCompactPlacedVolBuffer = nullptr;
./source/GeoManager.cpp:  gCompactPlacedVolBuffer = (VPlacedVolume *)malloc(pvolumecount * sizeof(VPlacedVolume));
./source/GeoManager.cpp:    gCompactPlacedVolBuffer[volumeindex] = *v.second;
./source/GeoManager.cpp:    fPlacedVolumesMap[volumeindex]       = &amp;gCompactPlacedVolBuffer[volumeindex];
./source/GeoManager.cpp:    conversionmap[v.second]              = &amp;gCompactPlacedVolBuffer[volumeindex];
./source/GeoManager.cpp:  if (GeoManager::gCompactPlacedVolBuffer != nullptr) {
./source/GeoManager.cpp:    free(gCompactPlacedVolBuffer);
./source/GeoManager.cpp:    gCompactPlacedVolBuffer = nullptr;</pre>
</div>
<p>source/CudaGlobalSymbols.cu:</p>
<div class="highlight-python"><pre>01 #include "base/Global.h"
 2
 3 namespace vecgeom {
 4 class VPlacedVolume;
 5 // instantiation of global device geometry data
 6 namespace globaldevicegeomdata {
 7 //#ifdef VECGEOM_NVCC_DEVICE
 8 __device__ VPlacedVolume *gCompactPlacedVolBuffer;
 9 //#endif
10 }
11 }</pre>
</div>
</div>
<div class="section" id="contrast-vecgeom-gpu-geo-setup-with-oxrap-oscene-cc">
<h2>Contrast VecGeom GPU geo setup with oxrap/OScene.cc<a class="headerlink" href="#contrast-vecgeom-gpu-geo-setup-with-oxrap-oscene-cc" title="Permalink to this headline">¶</a></h2>
<p>oxrap/OScene::init</p>
<ul class="simple">
<li>sets up OptiX context with geometry info, including GPU textures</li>
</ul>
<p>Observations of VecGeom. Hmm no logging, no profiling machinery, copying volumes to GPU 1-by-1, no instancing, not good signs.:</p>
<div class="highlight-python"><pre>053 vecgeom::DevicePtr&lt;const vecgeom::cuda::VPlacedVolume&gt; CudaManager::Synchronize()
 54 {
 55   Stopwatch timer, overalltimer;
 56   overalltimer.Start();
 57   if (verbose_ &gt; 0) std::cerr &lt;&lt; "Starting synchronization to GPU.\n";
 58
 59   // Will return null if no geometry is loaded
 60   if (synchronized) return vecgeom::DevicePtr&lt;const vecgeom::cuda::VPlacedVolume&gt;(world_gpu_);
 61
 62   CleanGpu();
 63
 64   // Populate the memory map with GPU addresses
 65
 66   AllocateGeometry();
 67
 68   // Create new objects with pointers adjusted to point to GPU memory, then
 69   // copy them to the allocated memory locations on the GPU.
 70
 71   if (verbose_ &gt; 1) std::cerr &lt;&lt; "Copying geometry to GPU..." &lt;&lt; std::endl;
 72
 73   if (verbose_ &gt; 2) std::cerr &lt;&lt; "\nCopying logical volumes...";
 74   timer.Start();
 75   for (std::set&lt;LogicalVolume const *&gt;::const_iterator i = logical_volumes_.begin(); i != logical_volumes_.end(); ++i) {
 76
 77     (*i)-&gt;CopyToGpu(LookupUnplaced((*i)-&gt;GetUnplacedVolume()), LookupDaughters((*i)-&gt;fDaughters), LookupLogical(*i));
 78   }
 79   timer.Stop();
 80   if (verbose_ &gt; 2) std::cerr &lt;&lt; " OK; TIME NEEDED " &lt;&lt; timer.Elapsed() &lt;&lt; "s \n";
 81
 82   if (verbose_ &gt; 2) std::cerr &lt;&lt; "Copying unplaced volumes...";
 83   timer.Start();
 84   for (std::set&lt;VUnplacedVolume const *&gt;::const_iterator i = unplaced_volumes_.begin(); i != unplaced_volumes_.end();
 85        ++i) {
 86
 87     (*i)-&gt;CopyToGpu(LookupUnplaced(*i));
 88   }
 89   timer.Stop();
 90   if (verbose_ &gt; 2) std::cout &lt;&lt; " OK; TIME NEEDED " &lt;&lt; timer.Elapsed() &lt;&lt; "s \n";
 91
 92   if (verbose_ &gt; 2) std::cout &lt;&lt; "Copying transformations_...";
 93   timer.Start();
 94   for (std::set&lt;Transformation3D const *&gt;::const_iterator i = transformations_.begin(); i != transformations_.end();
 95        ++i) {
 96
 97     (*i)-&gt;CopyToGpu(LookupTransformation(*i));
 98   }
 99   timer.Stop();
100   if (verbose_ &gt; 2) std::cout &lt;&lt; " OK; TIME NEEDED " &lt;&lt; timer.Elapsed() &lt;&lt; "s \n";
101
102   if (verbose_ &gt; 2) std::cout &lt;&lt; "Copying placed volumes...";
103   // TODO: eventually we want to copy the placed volumes in one go (since they live now in contiguous buffers on both
104   // sides
105   // (the catch is that we will need to fix the virtual table pointers on the device side manually )
106
107   timer.Start();
108   for (std::set&lt;VPlacedVolume const *&gt;::const_iterator i = placed_volumes_.begin(); i != placed_volumes_.end(); ++i) {
109
110     (*i)-&gt;CopyToGpu(LookupLogical((*i)-&gt;GetLogicalVolume()), LookupTransformation((*i)-&gt;GetTransformation()),
111                     LookupPlaced(*i));
112</pre>
</div>
<div class="sidebar">
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="/tracs/env/timeline">env</a> &raquo;</li>
    
        <li><a href="../../../">Env  documentation</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Simon C Blyth.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>