
.. comment 

.. raw:: html

    <style type="text/css">
        span.alarm { color: red; } 
        span.warn { color: orange; } 
        span.ok { color: green; } 
        span.i { display: none; } 
    </style>

.. role:: i 
.. role:: alarm
.. role:: warn
.. role:: ok


.. include:: <s5defs.txt>

.. s5_background_image::

    #
    # slide titles and background image urls, 
    # including server relative urls like /env/geant4/geometry/collada/daeview/20140419-170713.png
    # and protocol relative urls like //localhost/env/test/LANS_AD3_CoverGas_Humidity.png
    #
    # NB1 slide titles here must match those in body precisely, 
    # NB2 also ensure all slide titles are unique
    #
    # first slide id is exceptionally: slide0, not the mangled title
    slide0
    /env/geant4/geometry/collada/g4daeview/20140419-170713.png auto_auto 0px_0px

    g4daeview.py : Fast OpenGL 3D viewer for G4DAE files
    /env/geant4/geometry/collada/g4daeview/20140419-170713.png

    Cerenkov Photons Simulation - Top View
    /env/geant4/geometry/collada/g4daeview/20141224-115923.png

    Cerenkov Photons Simulation - Side View
    /env/geant4/geometry/collada/g4daeview/20141224-115935.png

    Scintillation Photons Simulation - Top View
    /env/geant4/geometry/collada/g4daeview/20141224-121444.png

    Scintillation Photons Simulation - Side View
    /env/geant4/geometry/collada/g4daeview/20141224-121435.png

    Standard Geant4 Workflow
    /env/keynotefigs/G4DAEChroma/G4DAEChroma.001.png

    External Photon Simulation Workflow
    /env/keynotefigs/G4DAEChroma/G4DAEChroma.002.png

    GGeoView
    /env/graphics/ggeoview/ggeoview-cerenkov-001.png 1047px_795px

.. comment 

    GGeoView image is 2094x1590 1047x795

    Generated Scintillation Photons GPU cf Geant4
    /env/g4dae/generated_scintillation_time_wavelength.png

    G4/DetSim Generated Cerenkov Wavelength
    /env/g4dae/g4_cerenkov_wavelength.png



======================================================================
Optical Photon Simulation with NVIDIA OptiX
======================================================================

.. class:: small

    http://simoncblyth.bitbucket.org/env/presentation/optical_photon_simulation_with_nvidia_optix.html (May 2015)
    http://simoncblyth.bitbucket.org/env/presentation/gpu_accelerated_geant4_simulation.html (Jan 2015)

.. sidebar:: OptiX Ray Tracing    

   Extreme speed ~200M ray intersections/second/GPU, regular releases,
   performance scales with CUDA cores across multiple GPUs.

.. class:: small

   * Why not Chroma ?
   * Introducing NVIDIA OptiX
   * OptiX tests
   * Chroma to OptiX migration
   * Validating OptiX Generated Photons
   * Next Steps
   * Visualizations

   |  Simon C Blyth, National Taiwan University
   |  **May 2015** 

.. comment 


:small:`Why not Chroma ?`
------------------------------------------------------- 

.. sidebar:: Lack of multi-GPU support   

   .. class:: small

      Production running demands efficient use 
      of multiple GPUs.  Lack of this difficult
      to implement feature is a :red:`show stopper for Chroma use in production`.

.. class:: small

    :green:`Chroma Features`

    * Python/PyCUDA/NumPy based infrastructure for geometry/photon loading, kernel launch  
    * accelerated geometry intersection using BVH structure 
    * optical photon simulation CUDA kernels 

    :blue:`My additions to Chroma`

    * G4DAE Geometry import
    * G4Step transport and Cerenkov/Scintillation photon generation on GPU
    * OpenGL/CUDA interop visualisations  

    :red:`Missing Features`

    * GPU workload scheduling
    * Multi-GPU support



.. class:: tiny

   https://bitbucket.org/chroma/chroma

   https://bitbucket.org/simoncblyth/chroma  (my fork)



:small:`Introducing NVIDIA OptiX Ray Tracing Engine [C++/C/CUDA]`
-------------------------------------------------------------------

.. sidebar:: OptiX *Tutorial* Sample App

    .. class:: small

        Image pixels calculated by recursively bouncing rays 
        around geometry doing shadow, reflection, refraction calculations.
        Runs at interactive speeds with GeForce GT 750M.

    .. image:: /env/optix/samples/optix-tutorial-10.png 
       :width: 450px
       :align: right


.. class:: small

    * ~200M ray/s/GPU geometry intersections
    * very general ray tracing framework, **no rendering assumptions**
    * regular releases, improvements/tuning for new GPUs

    Ray Trace optimized compiler generates kernel combining 
    user programs: ray generation, object intersection, material shading, ..
    Incorporates NVIDIA expertise on efficient GPU/multi-GPU usage:

    * state machine continuations to implement GPU recursion
    * persistent warps with just enough threads to fill machine
    * load balancing between warps and between GPUs
      
    :red:`Hugely advantageous to let OptiX handle:`   
 
    * acceleration of geometry intersection 
    * efficient GPU/multi-GPU usage

    BUT: OptiX requires NVIDIA GPUs, AMD OpenCL **ray trace renderer** is not equivalent


.. class:: tiny

    https://developer.nvidia.com/optix 

    https://research.nvidia.com/publication/optix-general-purpose-ray-tracing-engine



:small:`Ray Tracing and Optical Photon Simulation Parallels`
--------------------------------------------------------------

.. sidebar:: OptiX *Glass* Sample App

    .. image:: /env/optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. class:: small

    Realistic image creation uses physically 
    based techniques and material definitions. Obvious parallels:

    * ray traced rendering : image pixel calculation 
    * optical photon (OP) simulation : PMT hit calculation

    Same rate determining step: :red:`geometry intersection` 

    **Applying** techniques/hardware developed for fast ray tracing 
    can be hugely beneficial to optical photon simulation. 
   
    * expect OP simulation performance >100x Geant4
    * OP processing time becomes effectively zero compared to rest



:small:`Chroma Raycast with entire geometry in view` 
---------------------------------------------------------------- 

.. class:: small

    Render Split into 3x3 CUDA kernel launches, 1 thread per pixel, ~1.8s for 1.23M pixels, 2.4M tris (with [#hw]_)

.. image:: /env/chroma/chroma_camera/20140423-162109.png
   :width: 800px
   :align: center

.. class:: tiny

   .. [#hw] MacBook Pro (2013), NVIDIA GeForce GT 750M 2048 MB ; 
            Workstation GPUs such as NVIDIA Kepler K20 expected at least ~5x faster


:small:`OptiX raycast performance`
--------------------------------------

.. sidebar:: GGeoview OptiX raycast

    .. image:: /env/optix/raycast/optix-raycast-gui-001.png
       :width: 550px
       :align: right

    .. class:: tiny

        https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/




.. class:: small

    DBNS geometry raycast comparison using mobile GPU

    * OptiX : interactive ~30 fps raycasting
    * Chroma : 1.8s per frame 

.. class:: small

    OptiX sample rendering with 2 GPU IHEP workstation,

    * 2 Tesla K20m (4992 cores) 28.0 ms/f
    * 1 Tesla K20m (2496 cores) 49.1 ms/f
    * 1 GeForce GT 750m (382 cores) 345.1 ms/f
 
    Performance linear with GPU cores, workstation compared to laptop:

    * 13x cores, 12x performance

    :red:`Adoption of OptiX is compelling`:

    * extremely fast intersection performance
    * scales with CUDA cores across multiple GPUs
    * improves with each release, new GPU tuning
    * defer management of acceleration to NVIDIA 



:small:`Status of Chroma to OptiX migration`
---------------------------------------------------------

.. sidebar:: Python/NumPy/PyCUDA to C++/CUDA/???

      .. class:: small

          OptiX provides C++/C/CUDA APIs.

          Chroma Python infrastructure is great for learning and development
          but inconvenient in production when using multiple
          threads, the standard way to work with multiple GPUs.

          :red:`Reimplementation in C++ adopted as the simplest longterm approach`


.. class:: small


    Infrastructure for geometry/photon GPU loading, kernel launch

    * :green:`C++ re-implementation, initial developments completed`
    * :red:`need to add PMT identity information for hit formation`

    Geometry intersection acceleration 

    * :green:`no longer needed, handled by OptiX`

    Optical photon Cerenkov/Scintillation generation 

    * :green:`port completed and verified to match Geant4`

    Optical photon simulation CUDA kernels 

    * :blue:`port started`

    Visualization application to aid simulation development

    * :blue:`development ongoing in tandem with simulation port needs`



:small:`C++ Infrastructure : foundation packages`
-----------------------------------------------------

.. sidebar:: Replacing Python, NumPy, PyZMQ

    .. class:: small

         Boost Libraries (filesystem, thread, program_options, logging, regex, ptree, Asio)
         and Asio-ZMQ, ZMQ used to replace python packages.  

         NPY format convenient for C++/Python interop:

    .. class:: tiny
    
         ::

             a = np.load("photons.npy")


.. class:: small

   *NPY*
         Array persistency/manipulations inspired by NumPy, 
         using NPY serialization format 

         * 11 classes: G4StepNPY, PhotonsNPY, ViewNPY, NPY, ...

   *NumpyServer*
         Asynchronous IO of Geant4 Steps, Photons, Hits.
         Communicates with remote *G4DAEOpticks* process, receiving
         steps and replying with hits. 
         
         * 7 classes : numpyserver, numpydelegate, udp_server, ... 

   *CUDAWrap*
         cuRAND initialization and state persistency using pure CUDA

         * avoids large stack size requirement of cuRAND init within OptiX  
         * 5 classes : cuRANDWrapper, LaunchSequence, LaunchCommon, ..
 

.. class:: tiny

   https://bitbucket.org/simoncblyth/env/src/tip/numerics/npy/

   https://bitbucket.org/simoncblyth/env/src/tip/boost/basio/numpyserver/

   https://bitbucket.org/simoncblyth/env/src/tip/cuda/cudawrap/


:small:`C++ Infrastructure : domain packages`
-----------------------------------------------------


.. sidebar:: Replacing Python packages

    .. class:: small

         Many C++ classes required to replace:
 
         * PyCOLLADA
         * PyOpenGL + glumpy + OpenGL 2.1 + GLUT
         * daenode.py
         * g4daeview.py

         Migration allows use of modern OpenGL 4.1:

         * better visualization performance
         * retina resolution support
         * many GUI packages to choose from, picked https://github.com/ocornut/imgui

.. class:: small

   *GGeo*
         GPU Geometry representation, NPY persistency 
 
         * 22 classes: GNode, GMaterial, GSurface, GProperty, ...

   *AssimpWrap*
         Creates GGeo geometries from G4DAE exports using: 

         * https://github.com/simoncblyth/assimp (fork handles G4DAE material/surface properties)
         * 7 classes : AssimpGGeo, AssimpTree, ...
         
   *OptiXRap*
         Conversion of GGeo into OptiX geometries and OptiX launch control.
         
         * 7 classes : OptiXEngine, OptixGeometry, ...

   *OGLRap*
         OpenGL shader based 3D visualization, using GLEW, GLFW
    
         * 29 classes : Scene, View, Camera, Trackball, Renderer, Shdr, GUI, ...
     


.. class:: tiny

    https://bitbucket.org/simoncblyth/env/src/tip/optix/ggeo/

    https://bitbucket.org/simoncblyth/env/src/tip/graphics/assimpwrap/

    https://bitbucket.org/simoncblyth/env/src/tip/graphics/oglrap/

    https://bitbucket.org/simoncblyth/env/src/tip/graphics/optixrap/




:small:`GGeoView : geometry, genstep, photon visualization`  
-----------------------------------------------------------------------------   

.. class:: small

   * very fast 3D OpenGL visualization 
   * intuitive GUI controls
   * intuitive virtual trackball translate/rotate 
   * interactive fov and near/far plane clipping 
   * perspective projection :red:`to implement: parallel projection`
   * numerical control via UDP remote messaging 
   * persistent viewpoint bookmarks :red:`in development`
   * live Geant4 connection, photon, genstep visualization :red:`in development`

   Also used for testing GPU photon propagation with OptiX project 

   * OpenGL/OptiX interop presentation of GPU resident photon/genstep data
   * interactive OptiX raycasting 


:i:`GGeoView`  
-----------------------------------------------------------------------------   


.. sidebar:: Simulation development

    .. class:: tiny

       Simulated Cerenkov photons from an 100 GeV muon travelling 
       from right to left across Dayabay AD. 
       Primaries are simulated by Geant4, Cerenkov "steps" of the primaries 
       are transferred to the GPU.  The dots represent  
       OptiX calculated first intersections of GPU generated photons with colors 
       corresponding to material boundaries: :red:`(red) GdDopedLS:Acrylic`,
       :green:`(green) LiquidScintillator:Acrylic`, :blue:`(blue) Acrylic:LiquidScintillator`,
       (white) IwsWater:UnstStainlessSteel, (grey) others.
       The red lines represent the positions and directions of the "steps" with an
       arbitrary scaling for visibility. 
       


:small:`Compare DAE Exports to GDML and VRML2(WRL)`
----------------------------------------------------

.. class:: small

    Export validation:

     * Comparison of all vertices/faces reveals :red:`boolean solids are discrepant`. 

     * Perfect [#perfect]_ DAE WRL agreement achieved by *cheating* : :blue:`perform triangulation once and reuse`.

     * Boolean solid triangulation sensitivity must be kept in mind as a potential systematic
       for computational uses 

     * **DAE not much bigger than GDML**, despite including all triangles/vertices [#not-repeating]_
       

.. class:: small

    ====================  =================  ==============  ==================  =================
     Qty                    DayaBay            Lingao             Far             Juno x0.5 
    ====================  =================  ==============  ==================  =================
    Volumes                     12,229           12,229             18,903            25,000
    Triangles                2,448,064        2,448,064          4,189,680        21,886,158
    Vertices                 1,245,996        1,245,996          2,128,208        10,993,079
    DAE/GDML/WRL (MB)      **6.9**/4.0/98    **6.9**/4.0/96    **8.6**/6.0/167     **6.1**/-/-                 
    ====================  =================  ==============  ==================  =================


.. class:: tiny

    ``VGDX_20140414`` counts using ``g4daeview.py -g 0: --with-chroma``, Juno geometry truncated

.. class:: tiny

    .. [#perfect] Maximum DAE WRL offset < 0.13 mm, after patching VRML2 export precision bug (fixed in current G4). 
                  Details: http://simoncblyth.bitbucket.org/env/notes/geant4/geometry/collada/dae_cf_wrl/ 
    .. [#not-repeating] Geometry is not repeated, instead the COLLADA format uses geometry instancing and a tree of transforms, 
                        just like GDML  






:small:`G4DAEChroma : Bridging from Geant4 to Chroma`
-----------------------------------------------------------

.. class:: small

   https://bitbucket.org/simoncblyth/env/src/tip/chroma/G4DAEChroma/G4DAEChroma/

.. sidebar:: Transport Infrastructure

   .. class:: small

       Collects generation steps from Geant4, sends to Chroma, receives
       hits in reply, integrates into G4 Hit Collections.
       :red:`Implemented with core of ~20 C++ classes`

.. class:: small

   * :green:`Two detector specific subclasses required eg` *DybG4DAECollector* *DybG4DAEGeometry*
   * NumPy array creation from C++, transport via ZeroMQ
   * JSON metadata communication C++/Python, *map<string,string> <-> dict*
   * Geant4 hit integration using additional *G4VSensitiveDetector*
     that steals hit collection pointers from existing one
   * Transform Cache to obtain PMT local coordinates from global hit coordinates
   * SQLite DB integation for monitoring/control

.. image:: /env/chroma/G4DAEChroma/G4DAEChroma_bitbucket.png
   :width: 700px
   :align: center


:small:`G4DAEChroma : For implementation details...`
-----------------------------------------------------------

.. class:: small

   http://simoncblyth.bitbucket.org/env/notes/chroma/G4DAEChroma/G4DAEChroma/G4DAEChroma_implementation/

.. image:: /env/chroma/G4DAEChroma/G4DAEChroma_implementation.png
   :width: 700px
   :align: center


https://bitbucket.org/simoncblyth/chroma :small:`Forked:` 
---------------------------------------------------------------------------

.. class:: small

    Changes in my fork of Chroma:

    * stability + efficiency improvements, enabling mobile development 
    * OpenGL/CUDA interoperation, using VBOs
    * add recording of propagation steps into VBO datastructure
    * more efficient Raycasting using 4x4 matrix uniforms and PBOs
    * animated photon propagation visualization
    * change serialization approach from ROOT/TObject to NumPy (NPY) 
    * :red:`generation of Cerenkov and Scintillation Photons based
      on Geant4 Generation Step inputs` 

.. image:: /env/chroma/chroma_fork_jan2015.png 
   :width: 700px
   :align: center



:small:`Chroma Generated Scintillation Photons cf Geant4`
------------------------------------------------------------ 

.. class:: small 

   Chroma interpolates all properties in 20nm bins, stair artifacts
   in wavelength distribution can be reduced by using eg 10nm property interpolation bins.  

.. image:: /env/g4dae/generated_scintillation_time_wavelength.png
   :width: 800px
   :align: center


:small:`Chroma Generated Cerenkov Photons cf Geant4`
------------------------------------------------------- 

.. class:: small 
  
   Geant4/DetSim wavelength distribution has a blip at 200nm, corresponding to edge of water 
   refractive index properties. (see the extra slides)

.. image:: /env/g4dae/generated_cerenkov_time_wavelength.png
   :width: 800px
   :align: center

Next Steps
------------------

.. class:: small

   G4DAE Geometry Exporter

   * implement parametrized/replica geometry handling, following GDML

   * investigate issue inherited from GDML of a skipped  
     edge case (when a volume is shared between multiple volume pairs)
     resulting in missing *G4LogicalBorderSurface* 

   * investigate improving default export appearance in common viewers 

   * test with newer and latest versions of Geant4

   * test on more detector geometries

   * incorporate into Geant4 codebase  

.. class:: small

   G4DAEChroma bridge

   * refactor to remove duplication in *G4DAEHit* *G4DAEHitList* 

   * eliminate use of *cnpy* external in favor of *numpy.hpp* 

.. class:: small

   Chroma

   * Port Cerenkov *ApplyWaterQE* to Chroma (expect quick)

   * Port *DsPmtSensDet::ProcessHits* QE gymnastics to Chroma 

   * Implement double sided surfaces, to match *G4LogicalBorderSurface*

   * Compare PMT Hit distributions between *NuWa/DetSimChroma* and *NuWa/DetSim* 

     * :red:`iterate until match achieved or discrepancies explained`

   * Find desktop GPU on which can test operation and performance  



:i:`Cerenkov Photons Simulation - Side View`
----------------------------------------------

.. sidebar:: Cerenkov Photons

    .. class:: tiny

       Simulated Cerenkov shock front from an 100 GeV muon travelling 
       from right to left across Dayabay AD. 
       Primaries are simulated by Geant4, Cerenkov "steps" of the primaries 
       are transferred to the GPU where **photons are generated, propagated and PMT hits formed**. 
       Photon colors indicate reemission (green), absorption(red), specular reflection (magenta), scattering(blue), no history (white).


:i:`Scintillation Photons Simulation - Side View`
--------------------------------------------------

.. sidebar:: Scintillation Photons

    .. class:: tiny

       Simulated Scintillation photons from an 100 GeV muon travelling 
       from right to left across Dayabay AD. 
       Primaries are simulated by Geant4, Scintillation "steps" of the primaries 
       are transferred to the GPU where **photons are generated, propagated and PMT hits formed**. 
       Photon colors indicate reemission (green), absorption(red), specular reflection (magenta), scattering(blue), no history (white).



Cerenkov Photons Simulation - Top View
----------------------------------------------

Scintillation Photons Simulation - Top View
----------------------------------------------



Extra Slides
---------------



:small:`g4daeview.py : OpenGL view of Juno Geometry`
-------------------------------------------------------------------------------

.. class:: tiny

   External view of Juno geometry with cutaway. The extreme size of the Juno geometry (50 million nodes in Chroma representation)
   provides a challenge for development on mobile GPUs. 
   As my developments operate at the Geant4 level wherever possible it   
   was relatively straightforward to apply the machinery developed for 
   Dayabay to the Juno detector. In collaboration with 
   Juno simulation experts the geometry was exported from   
   Geant4 and GPU visualized in under a days work. 


.. image:: /env/geant4/geometry/collada/g4daeview/20140716-194144.png
   :height: 650px
   :align: center



:small:`g4daeview.py : Chroma Raycast of Juno Geometry`
-------------------------------------------------------------------------------

.. class:: tiny

   External view of Juno geometry. The extreme size of the  Juno geometry (50 million nodes in Chroma representation)
   provides a challenge for development on mobile GPUs. The black rectangle arises due to aborts to avoid GPU
   crashes. 


.. image:: /env/geant4/geometry/collada/g4daeview/20140716-191232.png
   :height: 650px
   :align: center



:small:`G4 Generated Cerenkov Wavelengths in material categories`
------------------------------------------------------------------------

.. class:: small 

   Blip caused by 200nm edge in water refractive index

.. image:: /env/g4dae/g4_cerenkov_wavelength.png
   :width: 700px
   :align: center



:small:`Refractive Index Interpolation Explains Jump at 200nm`
---------------------------------------------------------------- 

.. class:: small

   DeadWater, IwsWater, OwsWater have same RINDEX starting from 200nm.
   Chroma interpolates properties onto a standard set of wavelengths, 
   getting rid of the jump. 


.. image:: /env/g4dae/plot_refractive_index_comparison.png
   :width: 900px
   :align: center



:small:`Comparison of Generated Scintillation Photon Distributions`
------------------------------------------------------------------------

.. class:: small 

   Position, direction, polarization XYZ  + time, wavelength, weight  

.. image:: /env/g4dae/generated_scintillation_3xyzw.png
   :width: 700px
   :align: center


:small:`Comparison of Generated Cerenokov Photon Distributions`
------------------------------------------------------------------------

.. class:: small 

   Position, direction, polarization XYZ  + time, wavelength, weight  

.. image:: /env/g4dae/generated_cerenkov_3xyzw.png
   :width: 700px
   :align: center




:small:`g4daeview.py : Dayabay Chroma Photon Propagation (1)` 
-------------------------------------------------------------------------------

.. class:: tiny

   Chroma GPU photon propagation at 12 nanoseconds.  The photons are generated by Geant4 
   simulation of a 100 GeV muon travelling from right to left. 
   Photon colors indicate reemission (green), absorption(red),
   specular reflection (magenta), scattering(blue), no history (white). 

.. image:: /env/geant4/geometry/collada/g4daeview/20140716-161445.png
   :height: 600px
   :align: center



