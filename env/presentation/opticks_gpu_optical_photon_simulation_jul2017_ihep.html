<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>Opticks : GPU Optical Photon Simulation for Particle Physics with NVIDIA OptiX</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="visible" />
<!-- style sheet links -->
<script src="ui/my-small-white/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/my-small-white/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/my-small-white/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/my-small-white/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/my-small-white/opera.css"
      type="text/css" media="projection" id="operaFix" />
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1><span class="i">Opticks : GPU Optical Photon Simulation for Particle Physics with NVIDIA OptiX</span></h1>

</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title"><span class="i">Opticks : GPU Optical Photon Simulation for Particle Physics with NVIDIA OptiX</span></h1>

<!-- comment

00 : <inline classes="i">Opticks : GPU Optical Photon Simulation for Particle Physics with NVIDIA OptiX</inline>
01 : opticks benefits
02 : outline

    Highlights teaser statement and outline

03 : optical photon simulation problem...
04 : jpmt before contact 2

    Statement of problem

05 : ray traced realistic image synthesis - -> optical photon simulation

    Ray trace connection to simulation

06 : nvidia optix 1
07 : nvidia optix 2

    OptiX intro are refs

08 : opticks geometry workflow : geocache
09 : large geometry techniques : instancing mandatory
10 : opticks geometry workflow : gpu textures



11 : hybrid geant4/opticks event workflow
12 : opticks interoperation : optix/cuda/thrust/opengl


ABSTRACT

Opticks is an open source project that integrates the NVIDIA OptiX
GPU ray tracing engine with Geant4 toolkit based simulations.
Massive parallelism brings drastic performance improvements with
optical photon simulation speedup expected to exceed 1000 times Geant4
when using workstation GPUs. Optical photon simulation time becomes
effectively zero compared to the rest of the simulation.

Optical photons from scintillation and Cherenkov processes
are allocated, generated and propagated entirely on the GPU, minimizing
transfer overheads and allowing CPU memory usage to be restricted to
optical photons that hit photomultiplier tubes or other photon detectors.
Collecting hits into standard Geant4 hit collections then allows the
rest of the simulation chain to proceed unmodified.

Optical physics processes of scattering, absorption, reemission and
boundary processes are implemented as CUDA OptiX programs based on the Geant4
implementations. Wavelength dependent material and surface properties as well as
inverse cumulative distribution functions for reemission are interleaved into
GPU textures providing fast interpolated property lookup or wavelength generation.

Geometry is provided to OptiX in the form of CUDA programs that return bounding boxes
for each primitive and single ray geometry intersection results. Some critical parts
of the geometry such as photomultiplier tubes have been implemented analytically
with the remainder being tesselated.
OptiX handles the creation and application of a choice of acceleration structures
such as boundary volume heirarchies and the transparent use of multiple GPUs.

OptiX interoperation with OpenGL and CUDA Thrust has enabled
unprecedented visualisations of photon propagations to be developed
using OpenGL geometry shaders to provide interactive time scrubbing and
CUDA Thrust photon indexing to provide interactive history selection.

Validation and performance results are shown for the photomultiplier based
Daya Bay and JUNO Neutrino detectors. -->
<style type="text/css">
    span.alarm { color: red; }
    span.warn { color: orange; }
    span.ok { color: green; }
    span.i { display: none; }
    pre.sliteral { class:"literal-block small"; }
    pre.mypre {
         display: block;
         font-family: monospace;
         font-size: 20px;
         white-space: pre;
         margin: 1em 0;
    }

    pre.mypretiny {
         display: block;
         font-family: monospace;
         font-size: 15px;
         white-space: pre;
         margin: 1em 0;
    }

    pre.myfoot {
         display: block;
         font-family: monospace;
         font-size: 18px;
         white-space: pre;
         color: white;
         position: absolute; top:86%; left:4%; width:50%; height:10% ;
    }

    a.mylink {
         display: block;
         font-family: monospace;
         font-size: 18px;
         white-space: pre;
         color: black;
         position: absolute; top:86%; left:4%; width:50%; height:10% ;
    }


    div.mytitle {
         font-size: 20px;
         color: black;
         position: absolute; top:0%; left:5%; width:90%; height:10% ;
    }

    div.mycredit {
         font-size: 20px;
         color: black;
         position: absolute; top:90%; left:5%; width:80%; height:10% ;
    }





</style><!-- Definitions of interpreted text roles (classes) for S5/HTML data. -->
<!-- This data file has been placed in the public domain. -->
<!-- Colours
======= -->
<!-- Text Sizes
========== -->
<!-- Display in Slides (Presentation Mode) Only
========================================== -->
<!-- Display in Outline Mode Only
============================ -->
<!-- Display in Print Only
===================== -->
<!-- Display in Handout Mode Only
============================ -->
<!-- Incremental Display
=================== -->

       <style type="text/css">

          div.slide { 
             background-clip: border-box;
             background-repeat: no-repeat;
             height: 100%;
          }
          div.slide#slide0{
             background-image: url(/env/graphics/ggeoview/jpmt-inside-wide_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#opticks-benefits{
             background-image: url(/env/graphics/ggeoview/jpmt-inside-wide_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#visualizing-an-optical-photon-simulation{
             background-image: url(/env/graphics/ggeoview/jpmt-inside-wide_crop.png);
             background-size: 640px 360px;
             background-position: 600px 100px;
          }
          div.slide#overview{
             background-image: url(/env/graphics/ggeoview/jpmt-inside-wide_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#g4daeview-py-fast-opengl-3d-viewer-for-g4dae-files{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20140419-170713.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#cerenkov-photons-simulation-top-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-115923.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#cerenkov-photons-simulation-side-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-115935.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#scintillation-photons-simulation-top-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-121444.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#scintillation-photons-simulation-side-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-121435.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#standard-geant4-workflow{
             background-image: url(/env/keynotefigs/G4DAEChroma/G4DAEChroma.001.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#external-photon-simulation-workflow{
             background-image: url(/env/keynotefigs/G4DAEChroma/G4DAEChroma.002.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#ggeoview{
             background-image: url(/env/graphics/ggeoview/ggeoview-cerenkov-001.png);
             background-size: 1047px 795px;
             background-position: 0px 0px;
          }
          div.slide#ggeoview-m1-points{
             background-image: url(/env/graphics/ggeoview/ggeoview-scintillation-points-mat1.png);
             background-size: 1435px 848px;
             background-position: 0px 0px;
          }
          div.slide#ggeoview-flag-selection{
             background-image: url(/env/graphics/ggeoview/ggeoview-scintillation-flag-seq-select.png);
             background-size: 1436px 842px;
             background-position: 0px 0px;
          }
          div.slide#ggeoview-cerenkov-geom-m1{
             background-image: url(/env/graphics/ggeoview/ggeoview-cerenkov-m1-geom.png);
             background-size: 1416px 845px;
             background-position: 0px 0px;
          }
          div.slide#detecting-neutrinos-via-optical-photons-1{
             background-image: url(/env/presentation/dayabay-principal_half.png);
             background-size: 1417px 830px;
             background-position: 0px 0px;
          }
          div.slide#detecting-neutrinos-via-optical-photons-2{
             background-image: url(/env/presentation/dayabay-principal_half.png);
             background-size: 1417px 830px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-inside-wide{
             background-image: url(/env/graphics/ggeoview/jpmt-inside-wide_half.png);
             background-size: 1432px 844px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-wide{
             background-image: url(/env/graphics/ggeoview/jpmt-wide_half.png);
             background-size: 1409px 836px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-headview{
             background-image: url(/env/graphics/ggeoview/jpmt-headview_half.png);
             background-size: 1308px 783px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-backview{
             background-image: url(/env/graphics/ggeoview/jpmt-backview_half.png);
             background-size: 1149px 794px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-approach{
             background-image: url(/env/graphics/ggeoview/jpmt-approach_half.png);
             background-size: 1431px 839px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-arrival{
             background-image: url(/env/graphics/ggeoview/jpmt-arrival_half.png);
             background-size: 1427px 841px;
             background-position: 0px 0px;
          }
          div.slide#optical-photon-simulation-problem{
             background-image: url(/env/graphics/ggeoview/jpmt-before-contact_half.png);
             background-size: 1430px 844px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-before-contact{
             background-image: url(/env/graphics/ggeoview/jpmt-before-contact_half.png);
             background-size: 1430px 844px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-before-contact-2{
             background-image: url(/env/graphics/ggeoview/jpmt-before-contact_half.png);
             background-size: 1430px 844px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-before-contact-3{
             background-image: url(/env/graphics/ggeoview/jpmt-before-contact_half.png);
             background-size: 1430px 844px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-after-contact{
             background-image: url(/env/graphics/ggeoview/jpmt-after-contact_half.png);
             background-size: 1425px 840px;
             background-position: 0px 0px;
          }
          div.slide#jpmt-inside-outside{
             background-image: url(/env/graphics/ggeoview/jpmt-inside-outside_half.png);
             background-size: 1401px 842px;
             background-position: 0px 0px;
          }
          div.slide#nvidia-optix-in-action{
             background-image: url(/env/presentation/optix-in-action_half.png);
             background-size: 966px 646px;
             background-position: 100px 50px;
          }
          div.slide#pmtinbox-approach-1{
             background-image: url(/env/graphics/ggeoview/PmtInBox-approach.png);
             background-size: 1069px 769px;
             background-position: 0px 0px;
          }
          div.slide#pmtinbox-approach-2{
             background-image: url(/env/graphics/ggeoview/PmtInBox-approach.png);
             background-size: 1069px 769px;
             background-position: 0px 0px;
          }
          div.slide#pmtinbox-after-1{
             background-image: url(/env/graphics/ggeoview/PmtInBox-after.png);
             background-size: 1057px 760px;
             background-position: 0px 0px;
          }
          div.slide#pmtinbox-after-2{
             background-image: url(/env/graphics/ggeoview/PmtInBox-after.png);
             background-size: 1057px 760px;
             background-position: 0px 0px;
          }
          div.slide#daya-bay-pmt-wall-photo-1{
             background-image: url(/env/presentation/gtc2016/dyb-pmt-wall-photo.png);
             background-size: 1329px 798px;
             background-position: 0px 0px;
          }
          div.slide#daya-bay-pmt-wall-photo-2{
             background-image: url(/env/presentation/gtc2016/dyb-pmt-wall-photo.png);
             background-size: 1329px 798px;
             background-position: 0px 0px;
          }
          div.slide#super-kamiokande-pmts-not-16-9{
             background-image: url(/env/presentation/gtc2016/sk-PH20-water-withboat-apr23-wm.png);
             background-size: 1181px 771px;
             background-position: 0px 0px;
          }
          div.slide#super-kamiokande-pmts-1{
             background-image: url(/env/presentation/PH20-water-withboat-apr23-wm_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#super-kamiokande-pmts-2{
             background-image: url(/env/presentation/PH20-water-withboat-apr23-wm_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#super-kamiokande-pmts-3{
             background-image: url(/env/presentation/PH20-water-withboat-apr23-wm_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#super-kamiokande-pmts-4{
             background-image: url(/env/presentation/PH20-water-withboat-apr23-wm_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#kamiokande-ii-1{
             background-image: url(/env/presentation/1987a.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#kamiokande-ii-2{
             background-image: url(/env/presentation/1987a.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#kamiokande-ii-3{
             background-image: url(/env/presentation/1987a.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#fast-optical-photon-simulation{
             background-image: url(/env/presentation/newtons-opticks.png);
             background-size: 374px 684px;
             background-position: 800px 0px;
          }
          div.slide#photomultiplier-tubes-pmts{
             background-image: url(/env/presentation/hamamatsu-pmt-16x9.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#photomultiplier-tube-operation{
             background-image: url(/env/presentation/hamamatsu-pmt-16x9.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#old-hamamatsu-photomultiplier-tubes-pmts{
             background-image: url(/env/presentation/hamamatsu-pmt.png);
             background-size: 1099px 734px;
             background-position: 0px 0px;
          }
          div.slide#old-photomultiplier-tube-operation{
             background-image: url(/env/presentation/hamamatsu-pmt.png);
             background-size: 1099px 734px;
             background-position: 0px 0px;
          }
          div.slide#jiangmen-underground-neutrino-observatory-juno{
             background-image: url(/env/presentation/juno-schematic-5.png);
             background-size: 1391px 734px;
             background-position: 0px 0px;
          }
          div.slide#jiangmen-underground-neutrino-observatory-goals{
             background-image: url(/env/presentation/juno-schematic-5.png);
             background-size: 1391px 734px;
             background-position: 0px 0px;
          }
          div.slide#dayabay-reactor-neutrino-expt-far-site{
             background-image: url(/env/presentation/DybFar_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#daya-bay-far-site-2{
             background-image: url(/env/presentation/DybFar_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#daya-bay-far-site-3{
             background-image: url(/env/presentation/DybFar_crop.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#geant4-monte-carlo-simulation-toolkit{
             background-image: url(/env/presentation/g4-hep.png);
             background-size: 1025px 621px;
             background-position: 100px 100px;
          }
          div.slide#geant4-monte-carlo-simulation-toolkit-generality{
             background-image: url(/env/presentation/g4-hep.png);
             background-size: 1025px 621px;
             background-position: 100px 100px;
          }
          div.slide#seeing-neutrinos-via-scintillation-cherenkov-light{
             background-image: url(/env/presentation/cherenkov.png);
             background-size: 316px 203px;
             background-position: 850px 400px;
          }
          div.slide#large-geometry-techniques-instancing-mandatory{
             background-image: url(/env/graphics/ggeoview/ggv-juno-instancing.png);
             background-size: 852px 592px;
             background-position: 450px 80px;
          }
          div.slide#nvidia-optix-1{
             background-image: url(/env/presentation/NVIDIAOptiXWebsite_Oct2016.png);
             background-size: 1280px;
             background-position: 0px 0px;
          }
          div.slide#nvidia-optix-2{
             background-image: url(/env/presentation/NVIDIAOptiXWebsite_Oct2016.png);
             background-size: 1280px;
             background-position: 0px 0px;
          }
          div.slide#opticksdocs{
             background-image: url(/env/presentation/OpticksDocs.png);
             background-size: 1280px 720px;
             background-position: 0px 0px;
          }
          div.slide#daya-bay-antineutrino-detection-via-inverse-beta-decay-1{
             background-image: url(/env/presentation/AntineutrinoDetectionViaIBDJetterSept2014.png);
             background-size: 809px 576px;
             background-position: 100px 100px;
          }
          div.slide#daya-bay-antineutrino-detection-via-inverse-beta-decay-2{
             background-image: url(/env/presentation/AntineutrinoDetectionViaIBDJetterSept2014.png);
             background-size: 809px 576px;
             background-position: 100px 100px;
          }
          div.slide#daya-bay-energy-response-model-1{
             background-image: url(/env/presentation/ZheTaupDetectorResponseModel.png);
             background-size: 968px 576px;
             background-position: 100px 100px;
          }
          div.slide#daya-bay-energy-response-model-2{
             background-image: url(/env/presentation/ZheTaupDetectorResponseModel.png);
             background-size: 968px 576px;
             background-position: 100px 100px;
          }
          div.slide#daya-bay-energy-response-model-fit-to-calibration-data-1{
             background-image: url(/env/presentation/EnergyResponseModel.png);
             background-size: 693px 504px;
             background-position: 0px 100px;
          }
          div.slide#daya-bay-energy-response-model-fit-to-calibration-data-2{
             background-image: url(/env/presentation/ConstrainingNonLinearity.png);
             background-size: 761px 553px;
             background-position: 0px 80px;
          }
          div.slide#daya-bay-ngd-analysis-most-precise-theta13{
             background-image: url(/env/presentation/DYBZheTaup2015Theta13OscillationAnalysis.png);
             background-size: 1057px 625px;
             background-position: 100px 60px;
          } 

       </style>
    <!-- comment

Large Geometry/Event Techniques
/env/graphics/ggeoview/ggv-juno-instancing.png 2130px_1480px -> 1065px_740px


GGeoView image is 2094x1590 1047x795

GGeoView M1 Points is 2870x1696  1435x848

GGeoView Flag Selection 2872x1684 1436x842

GGeoView Cerenkov Geom M1 2832x1690 1416x845


Generated Scintillation Photons GPU cf Geant4
/env/g4dae/generated_scintillation_time_wavelength.png

G4/DetSim Generated Cerenkov Wavelength
/env/g4dae/g4_cerenkov_wavelength.png -->
<!-- comment

Placeholder

jpmt-after-contact.png 2850px_1680px
jpmt-approach.png 2862px_1678px
jpmt-arrival.png 2854px_1682px
jpmt-backview.png 2298px_1588px
jpmt-before-contact.png 2860px_1688px
jpmt-headview.png 2616px_1566px
jpmt-inside-outside.png 2802px_1684px
jpmt-wide.png 2818px_1672px -->
<!-- comment

I will introduce Opticks,
an optical photon simulation based on NVIDIA OptiX ray tracing
enabling particle physics detector simulations
to benefit from OptiX ray tracing.

The image visualizes photons coming from a cosmic ray muon
crossing a neutrino detector. -->
<div class="mytitle">
<h1 style="background-color:lightgrey"> <i>Opticks</i> : GPU Optical Photon Simulation for Particle Physics with NVIDIA® OptiX™ </h1>
</div>

<div class="mycredit">
<h2 style="background-color:lightgrey"> Simon C Blyth, National Taiwan University &mdash; https://bitbucket.org/simoncblyth/opticks &mdash; July 2017 IHEP</h2>
</div>
</div>
<div class="slide" id="opticks-benefits">
<h1><span class="i">Opticks Benefits</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Opticks &gt; 1000x Geant4 (*)</p>
<p class="small">GPU massive parallelism <strong>eliminates bottleneck</strong>.</p>
<ul class="small simple">
<li>optical photon simulation time --&gt; zero</li>
<li>optical photon CPU memory --&gt; zero</li>
</ul>
<p class="small">[zero: effectively, compared to rest of simulation]</p>
<p class="small"><strong>More Photons -&gt; More Benefit</strong></p>
<ul class="small simple">
<li>Neutrino detectors can benefit the most, eg
JUNO and Dayabay</li>
</ul>
<p class="small"><a class="reference external" href="http://bitbucket.org/simoncblyth/opticks">http://bitbucket.org/simoncblyth/opticks</a></p>
<p class="small last">(*) core extrapolated from mobile GPU speed</p>
</div>
<!-- comment

Neutrino detectors can benefit the most as their operation
depends on production and propagation of sometimes many millions
of optical photons.

Neutrinos detectors need to be large, as neutrinos
interact only weakly.

**Radical simulation speedup -> short development cycle -> improved understanding** -->
</div>
<div class="slide" id="summary-from-llr-workshop-nov-2016">
<h1><span class="small">Summary from LLR Workshop (Nov 2016)</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Overview</p>
<ul class="small last simple">
<li><strong>Opticks 200x Geant4</strong> with mobile GPU</li>
<li>Expect: <strong>Opticks &gt; 1000x Geant4</strong> (with workstation GPUs)</li>
<li><span class="red">photon propagation time --&gt; zero</span></li>
<li><span class="blue">analytic geometry --&gt; precise Geant4 match</span></li>
<li><strong>NOTE THE &quot;ANALYTIC&quot; CAVEAT</strong></li>
</ul>
</div>
<img alt="/env/presentation/1px.png" src="/env/presentation/1px.png" style="width: 500px; height: 50px;" />
<!--  -->
<blockquote>
<p><em>Opticks</em> enables <em>Geant4</em> based simulations to benefit from optical photon simulation
<strong>taking effectively zero time and zero CPU memory</strong>,
thanks to massive parallelism made accessible by NVIDIA OptiX.</p>
<img alt="/env/presentation/1px.png" src="/env/presentation/1px.png" style="width: 1000px; height: 20px;" />
<ul class="simple">
<li>The more photons the bigger the overall speedup (99% -&gt; 100x)</li>
<li>Drastic speedup -&gt; better detector understanding -&gt; greater precision</li>
<li>Large PMT based neutrino experiments, such as JUNO, can benefit the most</li>
</ul>
<img alt="/env/presentation/1px.png" src="/env/presentation/1px.png" style="width: 1000px; height: 20px;" />
<p class="huge"><a class="reference external" href="https://bitbucket.org/simoncblyth/opticks">https://bitbucket.org/simoncblyth/opticks</a></p>
</blockquote>
</div>
<div class="slide" id="opticks-progress-moving-to-fully-analytic-gpu-geometry">
<h1><span class="small">Opticks Progress : Moving to Fully Analytic GPU Geometry</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Nov 2016, Overview [1]</p>
<ul class="small simple">
<li><strong>Opticks 200x Geant4</strong> with mobile GPU</li>
<li>Expect: <strong>Opticks &gt; 1000x Geant4</strong> (with workstation GPUs)</li>
<li><span class="red">photon propagation time --&gt; zero</span></li>
<li><span class="blue">analytic geometry --&gt; precise Geant4 match</span></li>
</ul>
<p class="small last">CAVEAT : <strong>analytic geom needed for chi2 match</strong></p>
</div>
<p class="small"><strong>Geometry Status (Nov 2016)</strong></p>
<ul class="small simple">
<li>mostly approximated, using G4 tesselation</li>
<li>based on G4DAE geometry export</li>
<li>manually analytic PMT geometry</li>
<li>partition CSG solids into single primitive parts</li>
<li>splits at joins avoid general CSG boolean intersection</li>
</ul>
<p class="small"><strong>Geometry Status (July 2017)</strong></p>
<ul class="small simple">
<li><span class="red">general CSG tree intersection implemented on GPU</span></li>
<li>automated conversion, GDML -&gt; glTF -&gt; Opticks GPU geometry</li>
<li>all shape primitives used by Daya Bay geometry, on GPU</li>
</ul>
<p class="tiny">[1] LLR Workshop, <a class="reference external" href="https://simoncblyth.bitbucket.io/env/presentation/opticks_gpu_optical_photon_simulation_nov2016_llr.html">https://simoncblyth.bitbucket.io/env/presentation/opticks_gpu_optical_photon_simulation_nov2016_llr.html</a></p>
</div>
<div class="slide" id="constructive-solid-geometry-csg">
<h1><span class="small">Constructive Solid Geometry (CSG)</span></h1>
<div class="sidebar">
<p class="first sidebar-title">CSG Binary Tree</p>
<img alt="/env/presentation/hanrahan_example_of_solid_object_formed_using_csg.png" class="align-right" src="/env/presentation/hanrahan_example_of_solid_object_formed_using_csg.png" style="width: 450px;" />
<p class="small last">Primitives combined via binary operators</p>
</div>
<p class="small">Simple <em>by construction</em> definition, implicit geometry.</p>
<ul class="small simple">
<li><strong>A, B</strong> implicit primitive <strong>solids</strong></li>
<li><strong>A + B</strong> : union</li>
<li><strong>A * B</strong> : intersection</li>
<li><strong>A - B</strong> : difference</li>
<li><strong>!B</strong> : complement (inside &lt;-&gt; outside)</li>
</ul>
<p class="small">CSG expressions</p>
<ul class="small simple">
<li>non-unique: <strong>A - B == A * !B</strong></li>
<li>represented by binary tree, primitives at leaves</li>
</ul>
<p class="small">3D Parametric Ray : <strong>ray(t) = r0 + t rDir</strong></p>
<p class="small"><strong>Ray Geometry Intersection</strong></p>
<ul class="small simple">
<li>primitive -&gt; find <em>t</em> roots of implicit eqn</li>
<li>composite -&gt; pick primitive intersect, depending on CSG tree</li>
</ul>
<p class="large"><span class="red">How to pick exactly ?</span></p>
</div>
<div class="slide" id="csg-which-primitive-intersect-to-pick">
<h1><span class="small">CSG : Which primitive intersect to pick ?</span></h1>
<div class="sidebar">
<p class="first sidebar-title">In/On/Out transitions</p>
<img alt="/env/presentation/hanrahan_example_of_solid_object_formed_using_csg_roth_diagram.png" class="small last align-right" src="/env/presentation/hanrahan_example_of_solid_object_formed_using_csg_roth_diagram.png" style="width: 450px;" />
</div>
<p class="small">Classical Roth diagram approach</p>
<ul class="small simple">
<li>find all ray/prim intersects</li>
<li>recursively combine inside intervals using CSG operator</li>
<li>works from leaves upwards</li>
</ul>
<p class="small">Computational requirements:</p>
<ul class="small simple">
<li>find all intersects, store them, order them</li>
<li>recursive traverse</li>
</ul>
<p class="small">BUT : <strong>High performance on GPU requires</strong>:</p>
<ul class="small simple">
<li>massive parallelism -&gt; more the merrier</li>
<li>low register usage -&gt; keep it simple</li>
<li>small stack size -&gt; avoid recursion</li>
</ul>
<p class="large"><span class="red">Classical approach not appropriate on GPU</span></p>
</div>
<div class="slide" id="ray-tracing-csg-objects-using-single-hit-intersections-a-kensler">
<h1><span class="small">Ray Tracing CSG Objects Using Single Hit Intersections (A. Kensler) [*]</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Outside/Inside Unions</p>
<p class="small">dot(normal,rayDir) -&gt; Enter/Exit</p>
<img alt="/env/presentation/kensler_union_of_two_spheres_from_outside.png" class="align-center" src="/env/presentation/kensler_union_of_two_spheres_from_outside.png" style="width: 300px;" />
<img alt="/env/presentation/kensler_union_of_two_spheres_from_inside.png" class="align-center" src="/env/presentation/kensler_union_of_two_spheres_from_inside.png" style="width: 300px;" />
<ul class="small last simple">
<li><strong>A + B</strong> boundary not inside other</li>
<li><strong>A * B</strong> boundary inside other</li>
</ul>
</div>
<ul class="small simple">
<li>Classify A,B intersects, Enter/Exit/Miss</li>
<li>state(A,B) -&gt; action</li>
<li>LoopA : tMinA-&gt;tA, re-intersectA, re-classifyA (ditto LoopB)</li>
</ul>
<table border="1" class="small docutils">
<colgroup>
<col width="29%" />
<col width="21%" />
<col width="23%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Union, tA &lt; tB</th>
<th class="head">Enter B</th>
<th class="head">Exit B</th>
<th class="head">Miss B</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><strong>Enter A</strong></td>
<td>ReturnA</td>
<td>LoopA</td>
<td>ReturnA</td>
</tr>
<tr><td><strong>Exit A</strong></td>
<td>ReturnA</td>
<td>ReturnB</td>
<td>ReturnA</td>
</tr>
<tr><td><strong>Miss A</strong></td>
<td>ReturnB</td>
<td>ReturnB</td>
<td>ReturnMiss</td>
</tr>
</tbody>
</table>
<table border="1" class="small docutils">
<colgroup>
<col width="29%" />
<col width="21%" />
<col width="23%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Union, tB &lt; tA</th>
<th class="head">Enter B</th>
<th class="head">Exit B</th>
<th class="head">Miss B</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><strong>Enter A</strong></td>
<td>ReturnB</td>
<td>ReturnB</td>
<td>ReturnA</td>
</tr>
<tr><td><strong>Exit A</strong></td>
<td>LoopB</td>
<td>ReturnA</td>
<td>ReturnA</td>
</tr>
<tr><td><strong>Miss A</strong></td>
<td>ReturnB</td>
<td>ReturnB</td>
<td>ReturnMiss</td>
</tr>
</tbody>
</table>
<p class="small"><span class="blue">Recursive CSG tree python prototype of Kensler pseudocode worked after state table corrections/extensions</span></p>
<ul class="small simple">
<li>BUT GPU/OptiX demands: <span class="red">no recursion in intersect program</span></li>
</ul>
<dl class="tiny docutils">
<dt>[*] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)</dt>
<dd>with corrections by author of XRT Raytracer <a class="reference external" href="http://xrt.wikidot.com/doc:csg">http://xrt.wikidot.com/doc:csg</a></dd>
</dl>
</div>
<div class="slide" id="csg-complete-binary-tree-serialization-simplifies-gpu-side">
<h1><span class="small">CSG Complete Binary Tree Serialization -&gt; simplifies GPU side</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Bit Twiddling Navigation</p>
<ul class="small last simple">
<li>parent(i) = i/2 = i &gt;&gt; 1</li>
<li>leftchild(i) = 2*i = i &lt;&lt; 1</li>
<li>rightchild(i) = 2*i + 1 = (i &lt;&lt; 1) + 1</li>
<li>leftmost(height)  =  1 &lt;&lt; height</li>
</ul>
</div>
<p class="small">CSG Tree, leaf node primitives, internal node operators, 4x4 transforms on any node,
serialized as <span class="blue">complete binary tree</span>:</p>
<ul class="small simple">
<li>bit twiddling navigation <span class="red">avoids recursion</span></li>
<li>no need to deserialize</li>
<li>no child/parent pointers</li>
<li>BUT: very inefficient when unbalanced</li>
</ul>
<p class="small"><strong>Height 3 complete binary tree with level order indices:</strong></p>
<pre class="mypre">
                                                   depth     elevation

                     1                               0           3

          10                   11                    1           2

     100       101        110        111             2           1

 1000 1001  1010 1011  1100 1101  1110  1111         3           0
</pre>
<hr/><p class="small"><strong>postorder_next(i,elevation) = i &amp; 1 ? i &gt;&gt; 1 : (i &lt;&lt; elevation) + (1 &lt;&lt; elevation) ;</strong>   // from pattern of bits</p>
<p class="tiny">Postorder tree traverse visits all nodes, starting from leftmost, such that children
are visited prior to their parents.</p>
</div>
<div class="slide" id="evaluative-csg-intersection-pseudocode-recursion-emulated">
<h1><span class="small">Evaluative CSG intersection Pseudocode : recursion emulated</span></h1>
<pre class="mypretiny">
fullTree = PACK( 1 << height, 1 >> 1 )  // leftmost, parent_of_root(=0)
tranche.push(fullTree, ray.tmin)

while (!tranche.empty)        <b><span class="alarm"> // stack of begin/end indices </span></b>
{
    begin, end, tmin <- tranche.pop  ; node <- begin ;
    while( node != end )                  <b><span class="alarm"> // over tranche of postorder traversal </span></b>
    {
        elevation = height - TREE_DEPTH(node) ;
        if(is_primitive(node)){ isect <- intersect_primitive(node, tmin) ;  csg.push(isect) }
        else{
            i_left, i_right = csg.pop, csg.pop          <b><span class="alarm">  // csg stack of intersect normals, t </span></b>
            l_state = CLASSIFY(i_left, ray.direction, tmin)
            r_state = CLASSIFY(i_right, ray.direction, tmin)
            action = LUT(operator(node), leftIsCloser)(l_state, r_state)

            if(      action is ReturnLeft/Right)     csg.push(i_left or i_right)
            else if( action is LoopLeft/Right)
            {
                left = 2*node ; right = 2*node + 1 ;
                endTranche = PACK( node,  end );
                leftTranche = PACK(  left << (elevation-1), right << (elevation-1) )
                rightTranche = PACK(  right << (elevation-1),  node  )
                loopTranche = action ? leftTranche : rightTranche

                tranche.push(endTranche, tmin)
                tranche.push(loopTranche, tminAdvanced ) <b><span class="alarm"> // subtree re-traversal with changed tmin </span></b>
                break ; // to next tranche
            }
        }
        node <- postorder_next(node, elevation)        <b><span class="alarm"> // bit twiddling postorder </span></b>
    }
}
isect = csg.pop();       <b><span class="alarm">  // winning intersect  </span></b>
</pre><p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h">https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h</a></p>
</div>
<div class="slide" id="opticks-csg-primitives-closed-solids-consistent-normals">
<h1><span class="small">Opticks CSG Primitives : Closed Solids, Consistent Normals</span></h1>
<p class="small"><strong>Closed Solid</strong> as: <span class="blue">implementation requires otherside intersect</span>, <strong>Rigidly attached normals</strong></p>
<table border="1" class="small docutils">
<colgroup>
<col width="39%" />
<col width="29%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type code</th>
<th class="head">Python name</th>
<th class="head">C++ nnode sub-struct</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>CSG_BOX3,CSG_BOX</td>
<td>box3,box</td>
<td>nbox</td>
</tr>
<tr><td>CSG_SPHERE,CSG_ZSPHERE</td>
<td>sphere,zsphere</td>
<td>nsphere,nzsphere</td>
</tr>
<tr><td>CSG_CYLINDER,CSG_DISC</td>
<td>cylinder,disc</td>
<td>ncylinder,ndisc</td>
</tr>
<tr><td>CSG_CONE</td>
<td>cone</td>
<td>ncone</td>
</tr>
<tr><td>CSG_CONVEXPOLYHEDRON</td>
<td>convexpolyhedron</td>
<td>nconvexpolyhedron</td>
</tr>
<tr><td>CSG_TRAPEZOID,CSG_SEGMENT</td>
<td>trapezoid,segment</td>
<td>nconvexpolyhedron</td>
</tr>
</tbody>
</table>
<ul class="small simple">
<li><strong>zsphere, cone, cylinder, disc</strong> : truncated shapes <strong>closed</strong> by endcaps <span class="red">&lt;-- NOT OPTIONAL</span></li>
<li><strong>disc</strong> : avoids endcap degeneracy with very thin cylinders</li>
<li><strong>convexpolyhedron</strong> : defined by a set of planes, used for trapezoid and segment</li>
<li><strong>segment</strong> :   prism shape used for deltaphi intersection</li>
<li><strong>!complemented</strong> (inside&lt;-&gt;outside) solids handled by
special casing classification (cannot miss otherside).</li>
</ul>
<p class="small">Non-primitives, <span class="red">high level CSG definition avoids loadsa code</span></p>
<ul class="small simple">
<li><strong>ellipsoid</strong> : non-uniform scaling of sphere,  <strong>polycone</strong> : union of cylinders and cones</li>
<li><strong>inner-radii</strong> : via subtraction, <strong>deltaphi-segment</strong> : via intersect with <strong>segment</strong></li>
</ul>
</div>
<div class="slide" id="opticks-csg-primitives-what-they-comprise">
<h1><span class="small">Opticks CSG Primitives : What they comprise</span></h1>
<div class="sidebar">
<p class="first sidebar-title">OptiX Geometry</p>
<p class="small">OptiX provides acceleration of geometrical intersection, not the intersection itself.</p>
<ul class="small simple">
<li>parametric ray : <strong>p(t) = p0 + t rayDir</strong></li>
<li>implicit surface : <strong>f(p) = 0</strong></li>
</ul>
<p class="small">Intersect finding next closest root:</p>
<ul class="small last simple">
<li>smallest <strong>t</strong>, with <strong>t &gt; tmin</strong></li>
<li>surface normal at <strong>t</strong></li>
</ul>
</div>
<p class="small">OptiX/CUDA functions providing:</p>
<ul class="small simple">
<li>axis aligned bounding box (AABB)</li>
<li>intersect ray position (parametric t), surface normal</li>
</ul>
<p class="small">C++/nnode sub-struct methods</p>
<ul class="small simple">
<li>signed distance function (SDF)</li>
<li>parametric surface generation</li>
</ul>
<p class="small"><strong>Translation/rotation/scaling on any node</strong></p>
<p class="small">Intersect inverse-transformed ray -&gt; intersect in primitive frame</p>
<ul class="small simple">
<li>parametric-t same in both frames</li>
<li>normals, <strong>n_world = transpose(invert(TRS)) n_model</strong></li>
</ul>
<p class="small">Inverse transform transposed brings normal back to world frame</p>
<ul class="small simple">
<li><strong>rayDir</strong> NOT normalized</li>
</ul>
</div>
<div class="slide" id="opticks-csg-primitives-on-parade-gpu-raytrace">
<h1><span class="small">Opticks CSG Primitives On Parade (GPU raytrace)</span></h1>
<img alt="/env/presentation/tboolean_parade.png" class="align-center" src="/env/presentation/tboolean_parade.png" style="width: 1000px;" />
<p class="small">Three on right (Trapezoid, Segment, Icosahedron) all represented by planes with <strong>nconvexpolyhedron</strong></p>
</div>
<div class="slide" id="opticks-csg-serialized-into-optickscsg-format-numpy-buffers-json">
<h1><span class="small">Opticks CSG Serialized into OpticksCSG format (numpy buffers, json)</span></h1>
<pre class="mypretiny">

// tboolean-parade

from opticks.ana.base import opticks_main
from opticks.analytic.csg import CSG

args = opticks_main(csgpath="$TMP/$FUNCNAME")

container = CSG("box", param=[0,0,0,1200], boundary=args.container, poly="MC", nx="20" )

a = CSG("sphere", param=[0,0,0,100])
b = CSG("zsphere", param=[0,0,0,100], param1=[-50,60,0,0])
c = CSG("box3",param=[100,50,70,0])
d = CSG("box",param=[0,0,10,50])
e = CSG("cylinder",param=[0,0,0,100], param1=[-100,100,0,0])
f = CSG("disc",param=[0,0,0,100], param1=[-1,1,0,0])
g = CSG("cone", param=[100,-100,50,100])
h = CSG.MakeTrapezoid(z=100, x1=80, y1=100, x2=100, y2=80)
i = CSG.MakeSegment(phi0=0,phi1=45,sz=100,sr=100)
j = CSG.MakeIcosahedron(scale=100.)

prims = [a,b,c,d,e,f,g,h,i,j]

...  // setting translations

CSG.Serialize([container] + prims, args.csgpath )   <b><span class="alarm">  <-- write trees to file </span></b>
</pre><ul class="small simple">
<li>imported into C++ <strong>nnode</strong> tree by <strong>NCSG</strong></li>
</ul>
</div>
<div class="slide" id="opticks-csg-balancing-deep-trees-drastically-improves-performance">
<h1><span class="small">Opticks CSG : Balancing Deep Trees Drastically Improves Performance</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Positive form CSG Trees</p>
<p class="small">Apply deMorgan pushing negations down tree</p>
<ul class="small simple">
<li><strong>A - B -&gt; A * !B</strong></li>
<li><strong>!(A*B) -&gt; !A + !B</strong></li>
<li><strong>!(A+B) -&gt; !A * !B</strong></li>
<li><strong>!(A - B) -&gt; !(A*!B) -&gt; !A + B</strong></li>
</ul>
<p class="small">End with only UNION, INTERSECT operators,
and some complemented leaves.</p>
<p class="small last"><span class="red">COMMUTATIVE -&gt; easily rearranged</span></p>
</div>
<p class="small">Intended for solids, not scenes (tree height &lt;8, &lt;256 nodes[*])</p>
<ul class="small simple">
<li>unbalanced trees inefficiently handled as complete binary trees</li>
<li>CSG trees non-unique, many expressions of same shape</li>
</ul>
<pre class="mypretiny">
Dayabay TopESRCutHols lvidx:57  (height:9 totnodes:1023)
di(di(di(di(di(di(di(di(di(cy,cy),cy),cy),cy),cy),cy),cy),cy),cy)

                                                                    di
                                                             di          cy
                                                     di          cy
                                             di          cy
                                     di          cy
                             di          cy
                     di          cy
             di          cy
     di          cy
 cy      cy


Balanced Tree, height:4 totnodes:31
in(in(in(in(cy,!cy),in(!cy,!cy)),in(in(!cy,!cy),in(!cy,!cy))),!cy)

                                                             in
                             in                                 !cy
             in                              in
     in              in              in              in
 cy     !cy     !cy     !cy     !cy     !cy     !cy     !cy
</pre><p class="tiny">[*] Algorithm has no inherent height limit, but use of complete binary tree imposes practical performance limitation</p>
</div>
<div class="slide" id="dayabay-esr-reflector-deep-csg-tree-disc-with-9-holes">
<h1><span class="small">Dayabay ESR reflector : Deep CSG tree : disc with 9 holes</span></h1>
<img alt="/env/presentation/lvidx_57_esr_deep_tree_disc_with_holes.png" class="align-center" src="/env/presentation/lvidx_57_esr_deep_tree_disc_with_holes.png" style="width: 1000px;" />
</div>
<div class="slide" id="subtraction-of-thin-csg-cylinder-speckle-in-the-hole">
<h1><span class="small">Subtraction of thin CSG_CYLINDER -&gt; speckle in the  hole</span></h1>
<p class="small">CSG_DISC implemented to handle disc like cylinders : intersects at middle (z1+z2)/2 and offsets, <span class="red">avoids issue</span></p>
<img alt="/env/opticks_refs/speckle_lvTopESR.png" class="align-left" src="/env/opticks_refs/speckle_lvTopESR.png" style="width: 600px;" />
<img alt="/env/opticks_refs/tboolean_esr_speckle_centered_on_pole_delta_10-3.png" class="align-right" src="/env/opticks_refs/tboolean_esr_speckle_centered_on_pole_delta_10-3.png" style="width: 500px;" />
</div>
<div class="slide" id="coincident-faces-are-primary-cause-of-issues-fake-intersects">
<h1><span class="small">Coincident Faces are Primary Cause of Issues : Fake Intersects</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Cylinder - Cone</p>
<p class="small">Coincident endcaps -&gt; issue</p>
<img alt="/env/opticks_refs/lvidx_83_tbool_coincidence_artifact_at_cylinder_base.png" class="align-center" src="/env/opticks_refs/lvidx_83_tbool_coincidence_artifact_at_cylinder_base.png" style="width: 450px;" />
<p class="small last">Grow subtracted cone downwards, avoids coincidence : <strong>does not change composite solid</strong></p>
</div>
<p class="small">Coincidences common (alignment too tempting?). To fix:</p>
<ul class="small simple">
<li><strong>A-B</strong> : grow correct dimension of subtracted shape</li>
<li><strong>A+B</strong> : grow smaller interface shape into bigger, making join</li>
</ul>
<p class="small">Automated coincidence finder/fixer in operation, needs work</p>
<img alt="/env/opticks_refs/opticks_tscan_29_nzero_5_OcrGdsPrt.png" class="small align-left" src="/env/opticks_refs/opticks_tscan_29_nzero_5_OcrGdsPrt.png" style="width: 500px;" />
</div>
<div class="slide" id="full-analytic-geometry-translation-workflow">
<h1><span class="small">Full Analytic Geometry Translation Workflow</span></h1>
<div class="sidebar">
<p class="first sidebar-title">3D Formats : G4DAE, GDML, OpticksCSG, glTF</p>
<dl class="small last docutils">
<dt>G4DAE</dt>
<dd>approximate G4 triangulated geometry, includes all material/surface optical properties</dd>
<dt>GDML</dt>
<dd>analytic G4 geometry</dd>
<dt>OpticksCSG</dt>
<dd>numpy buffers of nodes, transforms, planes, json metadata</dd>
<dt>glTF</dt>
<dd>json node tree referring to OpticksCSG extras for each solid</dd>
</dl>
</div>
<p class="small">General CSG ray tracing on GPU allows operation from GDML files</p>
<p class="small"><strong>gdml2gltf.py  (opticks.analytic.sc)</strong></p>
<ul class="small simple">
<li>wraps GDML in python</li>
<li>translates G4 solids into OpticksCSG</li>
<li>collects structure into glTF scene tree</li>
<li>scene tree refers to OpticksCSG solids as extras</li>
<li>writes OpticksCSG for each solid together with glTF to file</li>
</ul>
<p class="small"><strong>NScene</strong></p>
<ul class="small simple">
<li>loads glTF structure into <strong>nd</strong> scene tree</li>
</ul>
<p class="small"><strong>NCSG</strong></p>
<ul class="small simple">
<li>loads OpticksCSG into <strong>nnode</strong> trees for each solid</li>
</ul>
<p class="small"><strong>GScene/OScene</strong></p>
<ul class="small simple">
<li>converts into OptiX GPU buffers</li>
</ul>
<p class="tiny">glTF : (GL Transmission Format) &quot;JPEG of 3D&quot; : efficient transmission and loading of 3D scenes and models,
<a class="reference external" href="https://www.khronos.org/gltf">https://www.khronos.org/gltf</a></p>
</div>
<div class="slide" id="signed-distance-function-sdf-modelling">
<h1><span class="small">Signed Distance Function (SDF) Modelling</span></h1>
<div class="sidebar">
<p class="first sidebar-title">SDF definition</p>
<p class="small">SDF(q(x,y,z) distance to solid surface</p>
<ul class="small simple">
<li>-ve : inside</li>
<li>0 : on surface</li>
<li>+ve : outside</li>
</ul>
<p class="small">SDF Examples:</p>
<p class="small last">Sphere(center,radius) :  <strong>length(q,center) - radius</strong>
Plane(normal, dist) : <strong>dot(normal,q) - dist</strong></p>
</div>
<p class="small">SDFs are composable using R-functions, eg <strong>min</strong> and <strong>max</strong></p>
<ul class="small simple">
<li>SDF(Union(A,B)) ~ min(SDF(A),SDB(B))</li>
<li>SDF(Intersection(A,B)) ~  max(SDF(A),SDF(B))</li>
<li>SDF(Difference(A,B)) ~ max(SDF(A),-SDF(B))</li>
<li>SDF(!A) ~ -SDF(A)</li>
</ul>
<p class="small">Recursively applicable to CSG trees</p>
<ul class="small simple">
<li>-&gt; <strong>implicit SDF for arbitrary CSG composite solid</strong></li>
</ul>
<p class="small">Allows:</p>
<ul class="small simple">
<li>analytic representation of arbitrary solid</li>
<li>classification of point wrt solid</li>
<li>polygonization by isosurface extraction -&gt; fast OpenGL rasterized visualization</li>
</ul>
<p class="small"><span class="red">SDFs extremely useful for geometry debugging</span></p>
<p class="tiny">Rvachev-functions (R-functions) : sign uniquely determined by signs of arguments -&gt; parallel CSG operations</p>
</div>
<div class="slide" id="sdf-isosurface-extracted-polgonization-mesh-with-offset-gpu-raytrace">
<h1><span class="small">SDF Isosurface Extracted Polgonization Mesh with offset GPU raytrace</span></h1>
<img alt="/env/presentation/tboolean_interlocked_gpuoffset.png" class="align-center" src="/env/presentation/tboolean_interlocked_gpuoffset.png" style="width: 1000px;" />
</div>
<div class="slide" id="various-polygonization-approaches">
<h1><span class="small">Various Polygonization Approaches</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Polygonization that just works ?</p>
<p class="small">Not a solved problem, problems with some geometry</p>
<ul class="small last simple">
<li>very thin (eg PMT cathode)</li>
<li>combinations of shapes of different scales</li>
</ul>
</div>
<p class="small"><strong>Several Integrations of Open Source Polygonizations</strong></p>
<dl class="small docutils">
<dt>Marching Cubes</dt>
<dd>fill bbox with cubes, generate triangles for cubes with sign changes,
fixed resolution (<strong>miss features or too many tris</strong>)</dd>
<dt>Dual Contouring</dt>
<dd>multiresolution using octree (<strong>slow, finnicky</strong>)</dd>
<dt>Implicit Mesher</dt>
<dd>finds and follows surface, fast, fixed resolution, (<strong>needs help in finding</strong>)</dd>
</dl>
<p class="small"><strong>My own attempt (WIP)</strong></p>
<dl class="small docutils">
<dt>Hybrid Mesher</dt>
<dd>combining SDF classification with parametric generation, (<strong>complicated mesh joining</strong>)</dd>
</dl>
</div>
<div class="slide" id="debugging-the-translation-to-gpu-geometry">
<h1><span class="small">Debugging the Translation to GPU Geometry</span></h1>
<div class="sidebar">
<p class="first sidebar-title">SDF zero scanning</p>
<p class="small">Consider union of shapes</p>
<ul class="small last simple">
<li>coincident faces -&gt; internal zeros (artifact surfaces)</li>
<li>count SDF zeros along scanlines across geometry &quot;cage&quot;<ul>
<li>even crossings -&gt; expected</li>
<li>odd crossings -&gt;</li>
</ul>
</li>
</ul>
</div>
<blockquote class="small">
<p><strong>Geometry Debugging using SDFs</strong></p>
<ul class="simple">
<li>select points on solid surface from the primitives (composite SDF~0) -&gt; <em>parsurf</em> bounding box</li>
<li>SDF zero scanning</li>
<li>classify child volume surface points against parent volume SDF (or v.v)</li>
</ul>
<p><strong>Codegen C++ (nnode) and Python (CSG) Debugging Workflow</strong></p>
</blockquote>
<p class="small"><strong>Solid Level</strong></p>
<p class="small">Bounding box comparisons</p>
<ul class="small simple">
<li>eg G4Poly(via G4DAE) vs Opticks parametric surface</li>
</ul>
<p class="small"><strong>Structure Level</strong></p>
</div>
<div class="slide" id="advantages-of-fully-analytic-geometry">
<h1><span class="small">Advantages of fully analytic geometry</span></h1>
<ul class="small simple">
<li>Geometry equivalence within numerical precision between Geant4 and Opticks on the GPU.</li>
<li>Automated translation of Geant4 detector geometries into a GPU suitable form.</li>
<li>Drastically simplified Opticks adoption, due to automated geometry translation.</li>
<li>Allows Opticks to operate from Geant4 standard GDML files rather than tessellated G4DAE.</li>
</ul>
</div>
<div class="slide" id="scratch">
<h1><span class="small">Scratch</span></h1>
<p class="tiny">Extended to complemented solids using : Miss -&gt; Exit, never closer + flip normals</p>
<ul class="tiny simple">
<li>implementation currently limited to height &lt;= 7, maximum 255 nodes</li>
</ul>
</div>
<div class="slide" id="context-pages">
<h1><span class="small">Context Pages</span></h1>
<blockquote class="large">
<ul class="simple">
<li>Optical Photon Simulation Problem</li>
<li>Ray Traced Image Synthesis ≈ Optical Photon Simulation</li>
<li>Open Source Opticks</li>
<li>YouTube Video</li>
</ul>
<p>For more on Opticks see</p>
</blockquote>
<p class="huge large"><a class="reference external" href="https://bitbucket.org/simoncblyth/opticks">https://bitbucket.org/simoncblyth/opticks</a></p>
<p class="tiny">[1] LLR Workshop, <a class="reference external" href="https://simoncblyth.bitbucket.io/env/presentation/opticks_gpu_optical_photon_simulation_nov2016_llr.html">https://simoncblyth.bitbucket.io/env/presentation/opticks_gpu_optical_photon_simulation_nov2016_llr.html</a></p>
</div>
<div class="slide" id="jpmt-before-contact-2">
<h1><span class="i">JPMT Before Contact 2</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Optical Photon Problem</p>
<dl class="small docutils">
<dt><strong>Cosmic muon backgrounds</strong></dt>
<dd>many millions of optical photons in Daya Bay (more in JUNO)</dd>
</dl>
<ul class="small simple">
<li>optical propagation dominates <em>Geant4</em> CPU time, ~95% for Daya Bay, more for JUNO</li>
<li>severe CPU memory constraint</li>
</ul>
<p class="small">Optical photons:</p>
<ul class="small simple">
<li>produced by Cerenkov+Scintillation processes</li>
<li>yield only Photomultiplier PMT hits</li>
</ul>
<p class="small">Isolated nature -&gt; <strong>easily separated propagation</strong></p>
<p class="small last"><strong>Hybrid Solution Possible : Geant4 + Opticks</strong></p>
</div>
</div>
<div class="slide" id="ray-traced-image-synthesis-optical-photon-simulation">
<h1><span class="small">Ray Traced Image Synthesis ≈ Optical Photon Simulation</span></h1>
<div class="sidebar">
<p class="first sidebar-title">OptiX Pixel Calculation</p>
<img alt="/env/optix/samples/optix-ray-tracing-glasses.png" class="align-right" src="/env/optix/samples/optix-ray-tracing-glasses.png" style="width: 450px;" />
<p class="tiny last"><a class="reference external" href="http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf">http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf</a></p>
<!-- comment

Not a photo -->
</div>
<dl class="small docutils">
<dt>Geometry, light sources, optical physics -&gt;</dt>
<dd><ul class="first last simple">
<li>pixel values at image plane</li>
<li>photon parameters at detectors (eg PMTs)</li>
</ul>
</dd>
<dt><strong>Ray tracing has many applications</strong> :</dt>
<dd><ul class="first last simple">
<li>advertising, design, entertainment, games,...</li>
<li>BUT : most ray tracers just render images</li>
</ul>
</dd>
<dt><strong>NVIDIA OptiX</strong> had foresight to be less specific:</dt>
<dd><ul class="first last simple">
<li>general geometry intersection API</li>
<li><span class="red">OptiX is to ray tracing what OpenGL is to rasterization</span></li>
</ul>
</dd>
</dl>
<pre class="mypre">


</pre><dl class="small docutils">
<dt><strong>rasterization</strong></dt>
<dd>project 3D primitives onto 2D image plane, combine fragments into pixel values</dd>
<dt><strong>ray tracing</strong></dt>
<dd>cast rays thru image pixels into scene, recursively reflect/refract with
geometry intersected, combine returns into pixel values</dd>
</dl>
</div>
<div class="slide" id="opticksdocs">
<h1><span class="i">OpticksDocs</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Open Source Opticks</p>
<ul class="small simple">
<li><a class="reference external" href="http://simoncblyth.bitbucket.io/opticks/">http://simoncblyth.bitbucket.io/opticks/</a></li>
<li><a class="reference external" href="http://bitbucket.org/simoncblyth/opticks/">http://bitbucket.org/simoncblyth/opticks/</a></li>
</ul>
<p class="small">Documentation, install instructions. Repository.</p>
<ul class="small simple">
<li>Mac, Linux, Windows (*)</li>
<li>18 C++ projects, ordered by dependency</li>
<li>~250 &quot;Unit&quot; Tests (CMake/CTest)</li>
<li>20 integration tests: tpmt, trainbow, tprism, treflect, tlens, tnewton, tg4gun, ...</li>
<li>NumPy/Python analysis/debugging scripts</li>
</ul>
<p class="small">Geometry/event data use NumPy serialization:</p>
<pre class="small literal-block">
import numpy as np
a = np.load(&quot;photons.npy&quot;)
</pre>
<p class="tiny last">(*) Windows VS2015, non-CUDA only so far</p>
</div>
</div>
<div class="slide" id="debugging-coincident-subtractions">
<h1><span class="small">Debugging Coincident Subtractions</span></h1>
<p class="small">Switching subtraction into union with complemented -&gt; can see whats subtracted.</p>
<img alt="/env/opticks_refs/lvidx_69_ring_box_cuts_artifact.png" class="align-center" src="/env/opticks_refs/lvidx_69_ring_box_cuts_artifact.png" style="width: 900px;" />
</div>
<div class="slide" id="youtube-video">
<h1><span class="i">YouTube Video</span></h1>
<iframe width="1024" height="576" src="https://www.youtube.com/embed/CBpOha4RzIs?rel=0" frameborder="0" allowfullscreen></iframe><p class="tiny"><a class="reference external" href="https://www.youtube.com/watch?v=CBpOha4RzIs">https://www.youtube.com/watch?v=CBpOha4RzIs</a></p>
</div>
</div>
</body>
</html>
