.. meta::
   :title: Opticks IHEP EPD Seminar
   :description: (2024 April 18) JUNO, OptiX, Opticks
   :note0: 50 min 
   :url: https://indico.ihep.ac.cn/event/22301/

.. include:: my_s5defs.txt


.. comment

    * Reduce graphics, Add JUNO
    * ~/o/notes/story_of_opticks_review.rst
    * rainbow
    * issue laundry list

.. comment

    <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA OptiX 7, NVIDIA CUDA

    The 2023 International Workshop on the High Energy Circular Electron Positron Collider

    NVIDIA® OptiX™


:i:`Opticks : SEMINAR :  Optical Photon Simulation via GPU Ray Tracing from NVIDIA OptiX`
==========================================================================================

.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey;text-align:center;"> 
        The Story of <i>Opticks</i>, applying NVIDIA OptiX GPU ray tracing to Optical Photon Simulation
        <h2 style="background-color:lightgrey;text-align:center">
            Open source, https://bitbucket.org/simoncblyth/opticks 
        </h2>
    </h1>
    </header>
    </div>
    <!--img style="position:absolute; top:200px; LEFT:100px; WIDTH:200px; " src="juno/JUNO_logo.png"  /-->
    <div class="mycredit">
       <h2 style="background-color:lightgrey">
          Simon C Blyth, IHEP, CAS &mdash; IHEP EPD Seminar &mdash; 18 April 2024
       </h2>
    </div>

:i:`Opticks : SEMINAR :  Optical Photon Simulation via GPU Ray Tracing from NVIDIA OptiX` Talk
----------------------------------------------------------------------------------------------

.. class:: normal

    Opticks is an open source project that applies GPU ray tracing to optical photon simulation 
    and integrates this with Geant4. This can give drastic speedups of more than a factor of 1000.
    This approach removes memory and processing bottlenecks that can prevent the 
    optical photons from limiting simulations.  

    The actual speedup depends on your geometry and your effort in avoiding 
    geometry issues. 

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.



Outline : Opticks First Incarnation 
------------------------------------

.. image:: newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right

.. class:: tiny

   .. raw:: html

       <span>&nbsp;</span>

   * Optical Photon Simulation : Problem and background

     * JUNO Optical Photon Simulation Problem...
     * Optical photons limit many simulations => lots of interest in Opticks

   * Optical Photon Simulation ≈ Ray Traced Image Rendering

     * Rasterization vs Ray Tracing 
     * Spatial index acceleration structure, BVH algorithm 
     * CPU vs GPU architectures, Latency vs Throughput

   * Opticks Early History 

     * pre-History : Chroma investigations
     * Triangulated Geometry, G4DAE Geometry exporter 
     * Chroma + G4DAE -> NVIDIA OptiX + "Opticks"
     * Handling Huge Geometry (eg JUNO) with instancing 
     * NVIDIA OptiX 5 Ray Tracing Engine 
     * Triangulated Geometry Problems

   * Fully Analytic CSG 

     * Analytic PMT (12 parts, not 2928 triangles)
     * GPU Geometry starts from ray-primitive intersection
     * Torus : much more difficult/expensive than other primitives
     * Constructive Solid Geometry (CSG) : Which intersect ? 
     * CSG Problems : deep trees, coincident faces
     * Opticks Instancing : "Factorizes" Geometry

   * Porting the physics

     * Translate Geant4 Optical Physics to GPU (OptiX/CUDA)
     * Optical Photon Simulation : Deciding history on way to boundary
      
   * Validation of Opticks Simulation by Comparison with Geant4
   * Performance : Scanning from 1M to 400M Photons
   * NVIDIA Giveth and NVIDIA Taketh away ...

.. raw:: html

   <hr/>


Outline : Opticks First Incarnation  Talk
-----------------------------------------

.. class:: normal

    When presenting Optick I usually focus on the latest version and recent changes. 
    With this presentation, I aim to give a wider view giving 
    more of the story behind the development of Opticks. 
    But first, I need to introduce the context and some terminology 


Outline : Opticks Reborn 
--------------------------

.. image:: newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right

.. class:: tiny

   * NVIDIA OptiX 7 

     * Entirely new thin API => Full Opticks Re-implementation
     * OptiX Ray Tracing Engine -- Accessible GPU Ray Tracing

   * Opticks Re-implemented

     * "Foundry" Model : Shared CPU/GPU Geometry Context 
     * Two-Level Hierarchy : Instance transforms (IAS) over Geometry (GAS)
     * Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7
     * first renders with OptiX 7 
     * Ray trace render performance scanning 
     * n-Ary CSG "List-Nodes"
     * CSG discontinuous union   
     * Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow  
     * Primary Packages and Structs Of Re-Implemented Opticks
     * QUDARap : CUDA Optical Simulation Implementation
     * Validation by comparison with Geant4 

   * Selection of DetSim issues revealed/studied using Opticks

     * Crucial Importance of standalone (fast cycle) tests
     * CSG : (Cylinder - Torus) PMT neck : spurious intersects 
     * Geometry Overlaps, eg solidXJfixture
     * Unphysical PMT geometry and optical model 
     * Compare Reflected Polarization Impls for Brewster Angle Incidence
   
   * Re-implemented JUNO PMT Optical Model
 
     * G4OpBoundaryProcess : customized for JUNO PMT Optical Model (POM)
     * Validation with standalone tests, input photons  
     * Multi-Layer Thin Film (A,R,T) Calc using TMM (Custom4 Package)
     
   * Opticks performance with GPU PMT Optical Model

     * Pure Optical TorchGenstep scan 
     * Release Event Time
     * Absolute Comparison with ancient Opticks Meaurements
     * (Yuxiang Hu) Overall speedup check

   * Amdahls "Law" : Expected Speedup Limited by Serial Processing
   * Summary + Links 
   * Acknowledgements : G4 Collab. + DM Search Community + NVIDIA
   * Innovation : Lessons Learned, Three Laws of Software Development

   * Extras
 
     * NVIDIA Ada Lovelace : 3rd Generation RTX, RT Cores in Data-Center


Outline : Opticks Reborn  Talk
------------------------------

.. class:: normal

    This outline is for offline consumption...
    
 


`JUNO Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <p style="margin-bottom:7cm;" />

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


`JUNO Optical Photon Simulation Problem...` Talk
------------------------------------------------

.. class:: normal

   So, what is the problem with optical photon simulation ? 

   A muon travelling across the JUNO scintillator yields tens of millions 
   of optical photons, presenting memory and time challenges. 

   At every step of every photon intersects between rays representing the 
   photons and the geometry have to be found.  This is what limits the simulation. 

   Simulation is not alone in this bottleneck.


.. comment

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation and we
   are interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 


:small:`Optical photons limit many simulations => lots of interest in Opticks`
--------------------------------------------------------------------------------

.. class:: small

    +-----------+-----------------------------------------------------------------------------+
    | **EXPT**  | **Reactor neutrino**                                                        |  
    +-----------+-----------------------------------------------------------------------------+
    | Daya Bay  | neutrino oscillations                                                       |
    +-----------+-----------------------------------------------------------------------------+
    | JUNO      | mass heirarchy + oscillations  => :r:`NVIDIA CN Contacts`                   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Long baseline neutrino beam**                                             |
    +-----------+-----------------------------------------------------------------------------+
    | DUNE      | FermiLab->Sanford, LAr TPC, => Assistance from :b:`Fermilab Geant4 Group`   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrinoless double beta decay, dark matter, other search**               |
    +-----------+-----------------------------------------------------------------------------+
    | LZ        | LUX-ZEPLIN dark matter experiment, Sandford  => :r:`NVIDIA US Contacts`     |
    +-----------+-----------------------------------------------------------------------------+
    | LEGEND    | Large Enriched Germanium Experiment, Gran Sasso/SNOLAB                      |
    +-----------+-----------------------------------------------------------------------------+
    | SABRE     | dark matter direct-detection, Australia                                     |
    +-----------+-----------------------------------------------------------------------------+
    | AMoRE     | Mo-based Rare process Experiment, S.Korea                                   |
    +-----------+-----------------------------------------------------------------------------+
    | nEXO      | next Enriched Xenon Observatory, LLNL                                       |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrino telescope**                                                      |
    +-----------+-----------------------------------------------------------------------------+
    | KM3Net    | Cubic Kilometre Neutrino Telescope, Mediterranean                           |
    +-----------+-----------------------------------------------------------------------------+
    | IceCube   | IceCube Neutrino Observatory, South Pole                                    |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Air shower : gamma-ray and cosmic-ray observatory**                       |
    +-----------+-----------------------------------------------------------------------------+
    | LHAASO    | Large High Altitude Air Shower Observatory, Sichuan                         |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Accelerator**                                                             |
    +-----------+-----------------------------------------------------------------------------+
    | LHCb-RICH | LHCb ring imaging Cherenkov sub-detector, CERN => :r:`NVIDIA EU Contacts`   |
    +-----------+-----------------------------------------------------------------------------+



:small:`Optical photons limit many simulations => lots of interest in Opticks` Talk
-----------------------------------------------------------------------------------

.. class:: normal

    Many simulations are limited by optical photons. 
    So, there is lots of interest in Opticks.
    Several groups has assisted with Opticks development 
    by using their contacts with NVIDIA 

   

:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: :small:`Not a Photo, a Calculation`

    .. image:: ../optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    :b:`simulation` 
       photon parameters at sensors (PMTs) 

    :b:`rendering` 
       pixel values at image plane


.. raw:: html

    <p style="margin-bottom:2cm;" />


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :redbold:`both limited by ray geometry intersection, aka ray tracing`

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering` Talk
--------------------------------------------------------------------

.. class:: normal

    So, how can GPU ray tracing help with simulation. 

    There is a lot in common between optical photon simulation and ray traced image rendering.   
    Simulation needs photon parameters at sensors, rendering needs pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is widely used across many industries from advertising to games, so 
    there has been huge efforts to improve ray tracing performance, especially from NVIDIA. 
    



:i:`Rasterization vs Ray-tracing`
-----------------------------------

.. image:: nvidia/nv_rasterization.png
   :width: 550px
   :align: left

.. image:: nvidia/nv_raytrace.png
   :width: 550px
   :align: right


:i:`Rasterization vs Ray-tracing` Talk
--------------------------------------

.. class:: normal

   Ray tracing and rasterization are the two primary graphics rendering techniques. 

   Rasterization is the most common rendering technique
   
   * it starts from the objects in a scene, and projects them onto pixels in the image plane
   * this requires an approximate triangulated geometry, to have vertices to project 
   
   Ray tracing 

   * starts from the pixels, casts rays out into the 3D scene and finds intersects
   * this can use analytic geometry, without approximation (just like Geant4)   
   * its easier to create realistic images with ray tracing because it is closer to the physics

   Ray tracing is an overloaded term.  In some contexts it means just the ray transport
   from an origin to an intersection. But is also refers more generally to the rendering technique. 

.. comment

   https://www.youtube.com/watch?v=Mrixi27G9yM
   RTX Launch



``Spatial Index Acceleration Structure``
---------------------------------------------------

.. raw:: html

    <p style="margin-bottom:11cm;" />

.. sidebar:: :small:`Tree of Bounding Boxes (bbox)`

    .. class:: small

        * aims to minimize bbox+primitive intersects 
        * accelerates ray-geometry intersection


``Spatial Index Acceleration Structure`` Talk
---------------------------------------------

.. class:: normal

   The principal technique to accelerate ray geometry intersection 
   is an acceleration structure called a bounding volume hierarchy 
   
   This divides space into progressively smaller boxes which forms
   a spatial index.

   Traversing the tree of bounds allows to minimize tests
   needed to find an intersect.

   Much of the acceleration structure traversal 
   is done in the dedicated RT cores.




:small:`CPU vs GPU architectures, Latency vs Throughput`
------------------------------------------------------------

.. class:: small

    .. image:: nvidia/cpu_vs_gpu_architecture.png
       :width: 800px
       :align: center

.. class:: small

   Waiting for memory read/write, is major source of latency...

   **CPU : latency-oriented : Minimize time to complete single task** : :red:`avoid latency with caching` 
       * complex : caching system, branch prediction, speculative execution, ...

   **GPU : throughput-oriented : Maximize total work per unit time** : :red:`hide latency with parallelism` 
       * many simple processing cores, hardware multithreading, SIMD (single instruction multiple data)
       * simpler : :green:`lots of compute (ALU)`, at expense of cache+control
       * design assumes :red:`abundant parallelism`

   Effective use of **Totally different processor architecture** -> :red:`Total reorganization of data and computation`  
       

.. class:: tiny

    Understanding Throughput-oriented Architectures
    https://cacm.acm.org/magazines/2010/11/100622-understanding-throughput-oriented-architectures/fulltext

:small:`CPU vs GPU architectures, Latency vs Throughput` Talk
-------------------------------------------------------------

.. class:: small

   SMALL

   * The way latency is handled is the primary thing that distinguishes the GPU from the CPU
   * the crucial thing is that the parallelism of the task is the founding "assumption" of the design of GPUs 

   **Many dont realize quite how extremely parallel you can and should go**

   * i am not just talking a few thousand threads here, millions is better
   * the largest launch I have done is 400M threads limited by VRAM 
   * best way to really experience this is to develop graphics applications 
   * they really do run billions of small shader programs per second

   I recall my first experience of the visualization 
   performance of triangulated DayaBay geometry  
   drawn with a single OpenGL draw call, using a single VBO (vertex buffer object).
   It was shockingly smooth.
   
   What is perhaps not so commonly experienced is how extremely parallel  
   tasks need to be to make best use of the GPU. 

.. comment

   Latency hiding works using hardware multi-threading, so when one group of threads is blocked
   waiting to read from global memory for example : other groups of thread and be resumed. This 
   is only effective at hiding latency when there are enough other threads in flight at the same time.

   Porting CPU code to run on the GPU : is not a straightforward thing to do, because the archirecture is totally 
   different.  To make effective use of GPUs requires a total reorganization of data and compute. 


:small:`Understanding GPU Graphical Origins -> Effective GPU Computation` 
---------------------------------------------------------------------------------

.. sidebar:: :small:`OpenGL Rasterization Pipeline`

    .. image:: opengl/rasterization_pipeline_rhs.png
       :width: 450px
       :align: right


.. class:: small

    **GPUs evolved to rasterize 3D graphics at 30/60 fps** 

    * 30/60 "launches" per second, each handling millions of items 
    * :red:`literally billions of small "shader" programs run per second`   
   
    **Simple Array Data Structures (N-million,4)**

    * millions of vertices, millions of triangles 
    * vertex: **(x y z w)**  
    * colors: **(r g b a)** 
    
    **Constant "Uniform" 4x4 matrices : scaling+rotation+translation**

    * 4-component homogeneous coordinates -> easy projection

    **Graphical Experience Informs Fast Computation on GPUs**

    * array shapes similar to graphics ones are faster

      * "float4" 4*float(32bit) = 128 bit memory reads are favored 
      * Opticks photons use "float4x4" just like 4x4 matrices

    * GPU Launch frequency < ~30/60 per second   

      * avoid copy+launch overheads becoming significant
      * ideally : handle millions of items in each launch 


:small:`Understanding GPU Graphical Origins -> Effective GPU Computation`  Talk
-------------------------------------------------------------------------------

.. class:: normal

    Rasterization is the process of going from input 3D vertices 
    which are collections of 4 floats to pixel values. 

    **GPUs evolved to rasterize**

    When using GPUs you should keep these origins in mind. 

    * for example, copying or operating on float4s 4*32bits is faster that *float3* 
      128bits are better for alignment reasons 

    * graphics pipeline is based around 4x4 matrices 
      and 4 component homogeneous coordinates
 
    * graphics updates at something like 30/60 frames per second : so do not expect 
      to do thousands of launches per second, each launch has an overhead

    * performance is gained by doing more in each launch  





:small:`How to Make Effective Use of GPUs ? Parallel / Simple / Uncoupled`
------------------------------------------------------------------------------

.. sidebar:: :small:`Optical Photon Simulation`

    .. class:: small

        Abundant parallelism 
           * Many millions of photons 

        Low register usage 
           * Simple optical physics, texture lookups

        Little/No synchronization
           * Independent photons -> None 

        Minimize CPU<->GPU copies 
           * geometry copied at initialization
           * gensteps copied once per event
           * only hits copied back    

        :blue:`~perfect match for GPU acceleration` 



.. class:: small

    **Abundant parallelism**
       * many thousands of tasks (ideally millions)

    **Low register usage : otherwise limits concurrent threads** 
       * simple kernels, avoid branching  

    **Little/No Synchronization**
       * avoid waiting, avoid complex code/debugging

    **Minimize CPU<->GPU copies**
       * reuse GPU buffers across multiple CUDA launches 

    .. image:: 1px.png


    **How Many Threads to Launch ?**

    * can (and should) launch many millions of threads

      * :red:`mince problems as finely as feasible`

    * maximum thread launch size : so large its irrelevant
    * maximum threads inflight : #SM*2048 = 80*2048 ~ 160k

      * best latency hiding when launch > ~10x this ~ 1M 


.. class:: tiny    


    Understanding Throughput-oriented Architectures
    https://cacm.acm.org/magazines/2010/11/100622-understanding-throughput-oriented-architectures/fulltext

    NVIDIA Titan V: 80 SM, 5120 CUDA cores


:small:`How to Make Effective Use of GPUs ? Parallel / Simple / Uncoupled` Talk
-------------------------------------------------------------------------------

.. class:: normal

    Optical photon simulation is close to being an ideal 
    workload for GPUs 




Opticks pre-History : Chroma investigations 
--------------------------------------------

.. comment

   simulating processes like diffuse and specular reflections, 
   refraction, Rayleigh scattering and absorption. 


.. sidebar:: :small:`Chroma : S.Siebert, A.LaTorre`

    .. class:: small

        Chroma tracks photons through a :red:`triangle-mesh detector geometry`, 
        using BVH acceleration structure, authors claim:

        *With a CUDA GPU Chroma has propagated 2.5M photons per second 
        in a detector with 29k PMTs. This is 200x faster than GEANT4.*

        Issues:

        * :r:`limited to triangle mesh geometry` 
        * polygonization : can be difficult+approximate 
        * tri. approx. => cannot precisely match Geant4
        * pycuda impl. : difficult C++ integration

        Made many efficiency fixes to work on mobile GPU:

        :b:`https://bitbucket.org/simoncblyth/chroma/` 


.. class:: small


    Experimented with *Chroma* to speedup Daya Bay optical sim:

    * developed "G4DAE" Geant4 exporter of 3D DAE files

      * https://bitbucket.org/simoncblyth/g4dae

    * added DAE import to my Chroma fork
    * bought macbook pro (NVIDIA Geforce 750M GPU)

    **Chroma : Disadvantages**

    * No use of ray trace engine, eg NVIDIA OptiX
    * No use of dedicated ray trace hardware RT cores (RTX)
    
    **Chroma : Fundamental Problem,** :r:`triangles only`

    * best available polygonization, *G4Polyhedron*
    * some solids (eg *G4Polycone*) yield "cleaved" meshes   
    * viz. bug for *Geant4*, broken geometry for *Chroma*
    * *OpenMesh* surgery possible, but not automatic

Opticks pre-History : Chroma investigations  Talk
-------------------------------------------------

.. class:: normal

    While working on DYB simulation, I started looking 
    at photon acceleration with reweighting techniques. 
    Searching around, The only thing I found was Chroma. 

    Chroma needs triangles, so I developed a Geant4 geometry 
    exporter following the approach of GDML export but instead exporting 
    the geometry into a 3D file format called DAE. 
    This includes all the triangles.


:i:`chroma_camera_raycast`
----------------------------

``(g4daeview.py) Chroma Raycast of Daya Bay geometry (3x3 CUDA kernel lunches, 1.8s for 1.23M pixels, Geforce 750M GPU)``


:i:`chroma_camera_raycast` Talk
-------------------------------

.. class:: normal

    Chroma was developed on workstations with CPUs and GPUs and much more capable than my mac book pro laptop.  
    I had to make Chroma operate more efficiently in order to get it to even run at all.  
    Using interop techniques that enable OpenGL visualization and CUDA compute to share the 
    same GPU buffers made the vizualization much more efficient 


``G4DAE : DYB pool bottom, Chroma raycast`` 
----------------------------------------------------


.. raw:: html

     <p style="margin-bottom:14cm;" />


.. class:: normal

    ``(g4daeview.py) Chroma raycast render of triangulated geometry``


``G4DAE : DYB pool bottom, Chroma raycast``  Talk
-------------------------------------------------

.. class:: normal

    With this more closup view, you can see the trianglated approximate geometry. 



``G4DAE : DYB pool bottom, OpenGL render``
-------------------------------------------------


.. raw:: html

     <p style="margin-bottom:14cm;" />


.. class:: normal

    ``(g4daeview.py) OpenGL rasterized render of triangulated geometry``


``G4DAE : DYB pool bottom, OpenGL render`` Talk
-----------------------------------------------

.. class:: normal

   The same triangless are used by this OpenGL rasterized render, but thats not the 
   exactly the same geometry that Geant4 would be using.  




Triangulated Geometry : Great for Visualization
-------------------------------------------------

.. sidebar:: :small:`G4DAE Geometry Exporter`

    .. class:: small

        Exports *Geant4* geometry into **standard** 3D files:

        * standard digital asset exchange (DAE) 
        * volume tree: solid/physical+logical volumes
        * vertices, tri. from *G4Polyhedron* 
        * material/surface props. in *extra* XML elements

        * https://bitbucket.org/simoncblyth/g4dae 


.. class:: small

    **Many apps/libs can view/edit DAE/COLLADA files**

    * Meshlab, Blender, Sketchup, ...
    * macOS: Finder/Quickview/Preview/Xcode
    * threejs, pycollada, SceneKit, ...
    * OpenGL, WebGL, pyopengl, glumpy 
 
    **Triangle Visualization Advantage**

    * GPUs evolved to rasterize trianglated geometry 
    * Developed pyopengl/pycollada renderer 

      * entire geometry in single OpenGL draw call
      * :r:`shockingly fast on mobile GPU`

    **CUDA/OpenGL interoperation**

    * share GPU buffers between compute and visualization 
    * visualize steps of millions of photons within geometry   


Triangulated Geometry : Great for Visualization Talk
----------------------------------------------------

.. class:: normal

    A great advantage of triangles is the simplicity which allows standard and widely supported
    3D file formats to be used. 

    I recall the first occasion that I visualized the Dayabay geometry, I was shocked by 
    the speed and smoothness possible even with my laptop GPU. 


``Daya Bay Chroma Photon Propagation (1)``
--------------------------------------------

.. raw:: html

     <p style="margin-bottom:14cm;" />

.. class:: tiny

   ``(g4daeview.py) Chroma GPU photon propagation at 12 nanoseconds.  The photons are generated by Geant4 
   simulation of a 100 GeV muon travelling from right to left. 
   Photon colors indicate reemission (green), absorption(red),
   specular reflection (magenta), scattering(blue), no history (white).``


``Daya Bay Chroma Photon Propagation (1)`` Talk
-----------------------------------------------

.. class:: normal

   I also visualized optical photon propagations using OpenGL shaders.  


``Daya Bay Chroma Photon Propagation (2)``
------------------------------------------


.. raw:: html

     <p style="margin-bottom:14cm;" />

.. class:: tiny

   ``(g4daeview.py) Chroma GPU photon propagation at 14 nanoseconds. 
   The interface provides interactive control of the propagation time 
   allowing any stage of the propagation to be viewed by 
   scrubbing time backwards/forwards. The speed of this visualization 
   is achieved by interoperation of CUDA kernels and OpenGL shaders accessing
   the same GPU resident photon propagation data.`` 


``Daya Bay Chroma Photon Propagation (2)`` Talk
-----------------------------------------------

.. class:: normal

    The propagation visulaization uses a record array with photon histories
    at different times, so propagation time is an input to the visualization  
    which you can scrub backwards and forwards. 


``Daya Bay Chroma Photon Propagation (3)``
---------------------------------------------

.. raw:: html

     <p style="margin-bottom:14cm;" />

.. class:: tiny

   ``(g4daeview.py) Initial photon positions of a Geant4 simulated muon that crosses
   between the Dayabay Near hall ADs. Colors represent photon wavelengths. 
   Optical photons: collected in G4 StackAction, serialized, sent over ZeroMQ, deserialized, 
   presented using OpenGL GLSL shaders.`` 


``Daya Bay Chroma Photon Propagation (3)`` Talk
-----------------------------------------------

.. class:: normal

   This shows the initial positions of the photons. The photons are being collected 
   from Geant4 in a separate process and sent over the network via a message queue to
   the optical simulation and visualization process. 
    
   Resorting to using network adds complexity.



:small:`Opticks History : Chroma + G4DAE -> NVIDIA OptiX + "Opticks"`
-----------------------------------------------------------------------

.. sidebar:: GGeoview OptiX raycast

    .. image:: ../optix/raycast/optix-raycast-gui-001.png
       :width: 550px
       :align: right

    .. class:: tiny

        https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/


.. class:: small

    **Why switch to NVIDIA OptiX ?** 

    * OptiX : transparent multi-GPU with no effort 
    * NVIDIA supported package
    * NVIDIA expertise on keeping GPUs busy 
       
    * Chroma implemented with python/numpy/pycuda

      * C++ impl. needed for easy Geant4 integration 
     
    DBNS geometry raycast comparison using mobile GPU

    * NVIDIA OptiX : :red:`interactive ~30 fps` raycasting
    * Chroma : 1.8s per frame 

    Performance improvement ~50x


    **"Opticks" started as synthesis:**

    * Chroma : high level propagation loop structure
    * Geant4 : simulation details
    * Graphics : performance techniques
  
    Package name "Opticks", taken from world changing publication:

    (1704) **Sir Isaac Newton FRS** :b:`"Opticks: or, A Treatise of the Reflexions, Refractions, Inflexions and Colours of Light."`
 

:small:`Opticks History : Chroma + G4DAE -> NVIDIA OptiX + "Opticks"` Talk
--------------------------------------------------------------------------

.. class:: normal

   My struggles with Chroma performance, and realizing that a C++ implemention was needed to 
   easily integrate with Geant4 : made me look around for alternatives. I found NVIDIA OptiX. 
   When I compared the performance I got with OptiX to Chroma, I immediately jumped to focus 
   on OptiX, not Chroma.  Soon after that I picked the name "Opticks" as package name.    

   My experience of cross-language pkgs. 
   I like python for analysis and debug. But not for control or config. It is too flexible to do that well.  



:small:`NVIDIA® OptiX™ Ray Tracing Engine -- http://developer.nvidia.com/optix`
--------------------------------------------------------------------------------

.. sidebar:: OptiX Raytracing Pipeline

    .. class:: small

       Analogous to OpenGL rasterization pipeline:

    .. image:: ../optix/docs/optix-model.png
       :width: 450px
       :align: right

.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * **accelerates** ray-geometry intersections
   * simple : single-ray programming model
   * "...free to use within any application..."
   * :red:`access RT Cores[1] with OptiX 6.0.0+ via RTX™ mode`

   **NVIDIA expertise:**

   * :red:`~linear scaling up to 4 GPUs`
   * acceleration structure creation + traversal (Blue)
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

       ``https://developer.nvidia.com/rtx``

.. class:: small

   **User provides (Yellow):**

   * ray generation
   * geometry bounding box, intersects 


.. class:: tiny

   [1] Turing+ GPUs eg NVIDIA TITAN RTX 

:small:`NVIDIA® OptiX™ Ray Tracing Engine -- http://developer.nvidia.com/optix` Talk
------------------------------------------------------------------------------------

.. class:: normal

   OptiX splits up ray tracing task.
   It implements the difficult part, creating and traversing the acceleration structure. 
   Leaving everything else to the user to implement in CUDA programs.




   A great feature of NVIDIA OptiX at that time was multi-GPU support. 
   With 4 GPUs you could nearly get 4 times the performance, without any development effort. 


:i:`GGeoView`  
-----------------------------------------------------------------------------   


.. raw:: html

     <p style="margin-bottom:-0.5cm;" />

.. class:: tiny

   ``(GGeoView) Cerenkov photons from an 100 GeV muon travelling from right to left across Dayabay AD. 
   Primaries are simulated by Geant4, Cerenkov "steps" of the primaries are transferred to the GPU.  
   The dots represent OptiX calculated first intersections of GPU generated photons with colors 
   corresponding to material boundaries: (red) GdDopedLS/Acrylic
   (green) LiquidScintillator/Acrylic, (blue) Acrylic/LiquidScintillator,
   (white) IwsWater:UnstStainlessSteel, (grey) others.
   The red lines represent the positions and directions of the "steps" with an
   arbitrary scaling for visibility.`` 
       

:i:`GGeoView`   Talk
--------------------

.. class:: normal

    This is an OpenGL visualization, presenting the buffers of photon positions obtained from OptiX. 



:i:`Opticks History : Handling Huge Geometry (eg JUNO)`
----------------------------------------------------------- 

.. class:: large

   ``Opticks History : Handling Huge Geometry (eg JUNO) with instancing`` 


.. raw:: html

     <p style="margin-bottom:13cm;" />


.. class:: normal

   ``Instancing in OptiX and OpenGL avoids repetition of geometry data on GPU for repeated elements (eg PMTs). 
   [Image is composite of OpenGL rasterized event representation and OptiX raytraced triangulated geom]``  


:i:`Opticks History : Handling Huge Geometry (eg JUNO)` Talk
------------------------------------------------------------

.. class:: normal

    The JUNO geometry is much bigger than Dayabay. This is especially the case with the triangulated
    geometry with many millions of triangles. To get this to work it wa necessry to use geometry instancing. 
    This is a composited visualization, combining rasterized photon propagation with ray traced geometry. 
    It you look closely you can see that the geometry is still triangulated.  In order to make this work 


:small:`Ray Intersection with Transformed Object -> Geometry Instancing`
-----------------------------------------------------------------------------


.. |H2O| replace:: H\ :sub:`2`\ O

.. |IM| replace:: M\ :sup:`-1`

.. |IMT| replace:: M\ :sup:`-1T`

.. |NP| replace:: N\ :sup:`1`



.. figure:: instancing/ray_intersection_in_two_spaces_p308_shirley_ch13_half.png
    :width: 700px
    :align: right

    .. class:: small

        Fig 13.5 "Realistic Ray Tracing", Peter Shirley

    .. class:: normal

        :redbold:`Advantages apply equally to acceleration structures`

.. class:: small

   **Equivalent Intersects -> same** *t*

   1. **ray** with *ellipsoid* : **M*p**
   2. |IM| **ray** with *sphere* : **p**

   **Local Frame Advantages**

   1. simpler intersect (sphere vs ellipsoid)
   2. closer to origin -> better precision

   **Geometry Instancing Advantages**

   * many objects share local geometry

     * orient+position with 4x4 **M**

   * huge VRAM saving, less to copy 
   
   **Requirements**

   * must **not** normalize ray direction
   * normals transform differently 

     * |NP| = N * |IMT|   
     * (due to non-uniform scaling) 


:small:`Ray Intersection with Transformed Object -> Geometry Instancing` Talk
-----------------------------------------------------------------------------

.. class:: normal

    The basis for instancing is the equivalence of intersects in two spaces.

    For example a ray-ellipsoid intersect is equivalent to in inverse 
    transformed ray intersect with a sphere.

    Local frame intersects advantages...

    This illustrates with non-uniform scaling for an ellipoid but the idea is the 
    same for translations and rotations. 






:small:`Opticks History : Triangulated Geometry Problems`
-----------------------------------------------------------

.. class:: small

   * *G4Polyhedron* tesselation of union solids -> cleaved mesh 

     * visualization bug for *Geant4*, :r:`broken geometry if rely on tesselation for simulation`
     * manifests as reversed normals causing material mis-assignment
     * ~10% of Daya Bay solid tesselations had issues : fixed some with *OpenMesh* surgery : unable to automate

   * even when not broken, usually approximate geometry : cannot precisely match Geant4
   * PMT "Disco Ball" effect (smoothed vertex normals can reduce this)

.. class:: small

   :r:`triangulated geometry : not practical for general simulation, but very useful for fast visualization` 

  
.. image:: ../graphics/ggeoview/dpib-triangulated-pmt.png
   :width: 550px
   :align: left

.. image:: ../graphics/ggeoview/dpib-test-disco-ball.png
   :width: 550px
   :align: right


:small:`Opticks History : Triangulated Geometry Problems` Talk
--------------------------------------------------------------

.. class:: normal

   Using triangulated geometry for simulation has some problems.
  


:small:`Opticks History : Analytic PMT (12 parts, not 2928 triangles)`
---------------------------------------------------------------------------------

.. sidebar:: :small:`Analytic PMT (no triangles)` 

    .. image:: ../nuwa/detdesc/pmt/hemi-pmt-analytic-near-clipped.png
       :width: 550px
       :align: right

    .. class:: small

       Near clipped, orthographic projection : gives cutaway raytrace render 


.. class:: small

   NVIDIA OptiX provided no intersection (it just accelerated intersection) 

   * need first principals intersection code, solving polynomials 
   * started with PMT specific intersection code

   **Partition PMT at constituent joins (semi-manually)** 

.. image:: ../nuwa/detdesc/pmt/hemi-pmt-parts.png
   :width: 550px
   :align: left



:small:`Opticks History : Analytic PMT (12 parts, not 2928 triangles)` Talk
---------------------------------------------------------------------------

.. class:: normal

   NVIDIA OptiX is not restricted to triangles. It supports custom primitives. But you 
   have to implement the intersection yourself.  I started using this with DayaBays PMT  

 

:i:`Daya Bay Opticks Propagation : Triangulated + Analytic PMT`
-------------------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:15cm;" />

.. class:: small 

    ``Daya Bay Opticks Propagation : Triangulated geometry with Analytic PMT 
    [composite OptiX raytrace geometry + OpenGL rasterized Cerenkov photons]``


:i:`Daya Bay Opticks Propagation : Triangulated + Analytic PMT` Talk
--------------------------------------------------------------------

.. class:: normal

   Fortunately you can combine analytic PMTs with triangulated everything else. 

   Compositing means, depth buffer, ...

:small:`Opticks : GPU Geometry starts from ray-primitive intersection`
-------------------------------------------------------------------------------------------------

.. class:: small

   * 3D parametric ray : **ray(x,y,z;t) = rayOrigin  +  t * rayDirection** 
   * implicit equation of primitive : **f(x,y,z) = 0**  
   * -> polynomial in **t** , roots: **t > t_min**  -> intersection positions + surface normals

.. figure:: tboolean_parade_sep2017.png
   :width: 900px
   :align: center

   :red:`CUDA/OptiX intersection for ~10 primitives` -> :blue:`Exact geometry translation`

:small:`Opticks : GPU Geometry starts from ray-primitive intersection` Talk
---------------------------------------------------------------------------

.. class:: normal

    It is not practical to manually develop intersection for each shape in a geometry. 

    OptiX did not provide primitives, even triangles, at that time.
    You have to implement the intersect from first principals by solving polynomials.   



:small:`Torus : much more difficult/expensive than other primitives`
------------------------------------------------------------------------

.. sidebar:: Torus artifacts

    .. image:: tboolean_torus_orthographic_artifact.png
       :width: 400px
       :align: right

   .. image:: torus_eqn_sqrt.png
       :width: 400px
       :align: right

   .. image:: torus_eqn_quartic.png
       :width: 400px
       :align: right



.. class:: small

   3D parametric ray : **ray(x,y,z;t) = rayOrigin  +  t * rayDirection** 

   * ray-torus intersection -> solve quartic polynomial in **t**  
   *  A t^4 + B t^3 + C t^2 + D t + E = 0 

   High order equation 

   * very large difference between coefficients 
   * varying ray -> wide range of very coefficients
   * numerically problematic, requires double precision 
   * several mathematical approaches used, work in progress

   **Best Solution : replace torus**

   * eg model PMT neck with hyperboloid, not cylinder-torus


:small:`Torus : much more difficult/expensive than other primitives` Talk
-------------------------------------------------------------------------

.. class:: normal

    Most shapes are fairly easy to implement.  
    The torus, or doughnut shape, is not so sweet. 


:small:`Torus : different artifacts as change implementation/params/viewpoint`
--------------------------------------------------------------------------------

.. class:: small

   * :red:`Only use Torus when there is no alternative` 
   * especially avoid CSG combinations with Torus  

.. image:: torus_cloud_artifact_2017_08_14.png
   :width: 500px
   :align: left

.. image:: torus_cuts_artifact_2017_08_08.png
   :width: 550px
   :align: right

.. image:: torus_fan_artifact_2017_07_28.png
   :width: 350px
   :align: right
 


:small:`Torus : different artifacts as change implementation/params/viewpoint` Talk
-----------------------------------------------------------------------------------

.. class:: normal

   You get lots of artifacts. And even when eventually you do get something 
   to work, it doesnt work well in CSG combination. 
    




:small:`Constructive Solid Geometry (CSG)`
-------------------------------------------------------

.. sidebar:: CSG Binary Tree

    .. image:: hanrahan_example_of_solid_object_formed_using_csg.png
       :width: 450px
       :align: right

    .. class:: small

       Primitives combined via binary operators 


.. class:: small

   Simple *by construction* definition, implicit geometry.

   * **A, B** implicit primitive **solids** 
   * **A + B** : union (OR)
   * **A * B** : intersection (AND) 
   * **A - B** : difference (AND NOT) 
   * **!B** : complement (NOT) (inside <-> outside)

   CSG expressions 

   * non-unique: **A - B == A * !B**
   * represented by binary tree, primitives at leaves

   3D Parametric Ray : **ray(t) = r0 + t rDir**  


   **Ray Geometry Intersection**

   * primitive : find *t* roots of implicit eqn
   * composite : :red:`pick` primitive intersect, depending on CSG tree


.. class:: large

   :red:`How to pick exactly ?`


:small:`Constructive Solid Geometry (CSG)` Talk
-----------------------------------------------

.. class:: normal

    Detector geometry is usually composed of more complex shapes than just primitives.
    These shapes are usually represented using constructive solid geometry or CSG. 


:small:`CSG : Which primitive intersect to pick ?`
-------------------------------------------------------
    

.. sidebar:: In/On/Out transitions

    .. class:: small

    .. image:: hanrahan_example_of_solid_object_formed_using_csg_roth_diagram.png
       :width: 450px
       :align: right


.. class:: small

   Classical Roth diagram approach

   * find all ray/prim intersects
   * recursively combine inside intervals using CSG operator
   * works from leaves upwards

   Computational requirements:

   * find all intersects, store them, order them
   * recursive traverse

   BUT : **High performance on GPU requires**:

   * massive parallelism -> more the merrier
   * low register usage -> keep it simple
   * small stack size -> **avoid recursion** 

.. class:: large

   :red:`Classical approach not appropriate on GPU`


:small:`CSG : Which primitive intersect to pick ?` Talk
-------------------------------------------------------

.. class:: normal

    How to find intersects with CSG geometry.  The intersect will be onto one 
    of the constituent solids, but how to pick the intersect. One way is to 
    compute intervals and then combine them. But that involves lots of temporary storage.
    On the GPU the more resources you use the less you can do at once, so combining 
    intervals is not a good approach.  


:small:`Developed GPU CSG Impl. based on short note with the idea`  
---------------------------------------------------------------------

.. class:: small

   * "Ray Tracing CSG Objects Using Single Hit Intersections", Andrew Kensler (2006) **3 page note**
   * http://xrt.wikidot.com/doc:csg corrections from author of XRT Renderer 

.. image:: kensler/frontpage.png
   :width: 550px
   :align: left

.. image:: kensler/xrt_wikidot_csg.png
   :width: 550px
   :align: right


:small:`Developed GPU CSG Impl. based on short note with the idea`   Talk
-------------------------------------------------------------------------

.. class:: normal

    Searching for GPU CSG algorithms didnt yield much, but I did find
    a short note that described what looked like a low resource way to find
    CSG intersects. 



:small:`Ray intersection with general CSG binary trees, on GPU`
---------------------------------------------------------------------------------

.. sidebar:: Outside/Inside Unions

    .. class:: small

       dot(normal,rayDir) -> Enter/Exit

    .. image:: kensler_union_of_two_spheres_from_outside.png
       :width: 300px
       :align: center

    .. image:: kensler_union_of_two_spheres_from_inside.png
       :width: 300px
       :align: center

    .. class:: small

        * **A + B** boundary not inside other 
        * **A * B** boundary inside other 


.. class:: small

   Pick between pairs of nearest intersects, eg:

   =======================  ===========  ===============  ============== 
   *UNION* tA < tB           Enter B      Exit B           Miss B
   =======================  ===========  ===============  ============== 
   **Enter A**               ReturnA      :blue:`LoopA`    ReturnA
   **Exit A**                ReturnA      ReturnB          ReturnA 
   **Miss A**                ReturnB      ReturnB          ReturnMiss
   =======================  ===========  ===============  ============== 

   * *Nearest hit intersect algorithm* [1] avoids state

     * sometimes :blue:`Loop` : advance **t_min** , re-intersect both 
     * classification shows if inside/outside

   * *Evaluative* [2] implementation emulates recursion: 

     * :red:`recursion not allowed` in OptiX intersect programs
     * bit twiddle traversal of complete binary tree 
     * stacks of postorder slices and intersects 

   * :red:`Identical geometry to Geant4` 

     * solving the same polynomials 
     * near perfect intersection match



.. class:: tiny

    [1] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
        with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
 
    [2] https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h
        Similar to binary expression tree evaluation using postorder traverse. 


:small:`Ray intersection with general CSG binary trees, on GPU` Talk
--------------------------------------------------------------------

.. class:: normal

   The Algorithm reduces the problem to a choice between intersects
   that is applied recursively to the tree of nodes that represents the shape. 



:small:`CSG Complete Binary Tree Serialization -> simplifies GPU side`
---------------------------------------------------------------------------------

.. sidebar:: Bit Twiddling Navigation

    .. class:: small

        * parent(i) = i/2 = i >> 1 

        * leftchild(i) = 2*i = i << 1

        * rightchild(i) = 2*i + 1 = (i << 1) + 1

        * leftmost(height)  =  1 << height


.. class:: small

    Geant4 solid -> CSG binary tree (leaf primitives, non-leaf operators, 4x4 transforms on any node)

    Serialize to **complete binary tree** buffer:
 
    * no need to deserialize, no child/parent pointers
    * bit twiddling navigation :red:`avoids recursion`
    * simple approach profits from small size of binary trees 
    * BUT: very inefficient when unbalanced 

    **Height 3 complete binary tree with level order indices:**
.. raw:: html

    <pre class="mypre">
                                                       depth     elevation

                         1                               0           3   

              10                   11                    1           2   

         100       101        110        111             2           1   
                        
     1000 1001  1010 1011  1100 1101  1110  1111         3           0   
    </pre>
    <hr/>

.. class:: small

    **postorder_next(i,elevation) = i & 1 ? i >> 1 : (i << elevation) + (1 << elevation) ;**   // from pattern of bits
 
.. class:: tiny

   Postorder tree traverse visits all nodes, starting from leftmost, such that children 
   are visited prior to their parents.



:small:`CSG Complete Binary Tree Serialization -> simplifies GPU side` Talk
---------------------------------------------------------------------------

.. class:: normal

   CSG implementations need a way to represent a tree of nodes, and a way to
   traverse those nodes in postorder. Postorder traverals visit child nodes prior to parents. 
   Using a complete binary tree enabled me to devise tree navigation by bit twiddling, just 
   by using the pattern of the bits in the complete binary tree.  

   This approach works well for small trees, but it is inefficient for large trees of depth 4 or more. 




:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace`
--------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:8cm;" />


.. class:: small

    ``Pure analytic CSG Daya Bay near geometry, auto-converted from Geant4 to Opticks GPU geometry, 
    NVIDIA OptiX GPU raytrace render [no triangles]``


:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace` Talk
-----------------------------------------------------------

.. class:: normal

   Using that GPU CSG algorithm enabled : pure analytic ray trace-ing.  So that means the 
   geometry is not approximate any more, it can match Geant4 intersects very closely. 
   Its because the two implementations are solving the same polynomials. 


:i:`j1808_top_rtx`
--------------------

.. class:: small

    ``Pure analytic CSG JUNO geometry, auto-converted from Geant4 to Opticks GPU geometry, 
    NVIDIA OptiX GPU raytrace render [no triangles] (GGeoView)``


:i:`j1808_top_rtx` Talk
-----------------------

.. class:: normal

   The upshot is that full Geant4 detector geometries
   can be automatically translated into NVIDIA OptiX geometries.

   This is an OptiX ray trace image from the chimney region at the 
   top of the JUNO scintillator sphere.
    

:i:`j1808_top_ogl`
--------------------


.. class:: small

    ``Approximate triangulated JUNO geometry [note impingement of torus guide tube and acrylic "sphere"], OpenGL rasterized render (GGeoView)``


:i:`j1808_top_ogl` Talk
-----------------------

.. class:: normal

   This is an OpenGL rasterized image, using the approximate triangulated 
   geometry. Opticks manages analytic and triangulated geometry together.  



:small:`Deep CSG tree from complex solids, can cause performance issue`
-------------------------------------------------------------------------------------------------

.. class:: small 

    * Dayabay ESR reflector : disc with 9 holes
    * JUNO "fastener"

.. image:: lvidx_57_esr_deep_tree_disc_with_holes.png
   :width: 550px
   :align: left

.. image:: x016_deeptree.png
   :width: 550px
   :align: right


:small:`Deep CSG tree from complex solids, can cause performance issue` Talk
----------------------------------------------------------------------------

.. class:: normal

   Performance issue 


:small:`Subtraction of thin CSG_CYLINDER -> speckle in the  hole`
-------------------------------------------------------------------------------------------------

.. class:: small

   CSG_DISC implemented to handle disc like cylinders : intersects at middle (z1+z2)/2 and offsets, :red:`avoids issue`

.. image:: ../opticks_refs/speckle_lvTopESR.png
   :width: 600px
   :align: left

.. image:: ../opticks_refs/tboolean_esr_speckle_centered_on_pole_delta_10-3.png
   :width: 500px
   :align: right


:small:`Subtraction of thin CSG_CYLINDER -> speckle in the  hole` Talk
----------------------------------------------------------------------

.. class:: normal

   CSG is a convenient way to define complex shapes, but it is inherently fragile
   and has problems when there are coincident faces. Which is actually very common.
   It is often easy to fix but not always, and its difficult to automate.  


:small:`Coincident Faces are Primary Cause of Issues : Fake Intersects`
-------------------------------------------------------------------------------------------------

.. sidebar:: Cylinder - Cone 

    .. class:: small

       Coincident endcaps -> issue 

    .. image:: ../opticks_refs/lvidx_83_tbool_coincidence_artifact_at_cylinder_base.png
       :width: 450px
       :align: center

    .. class:: small

       Grow subtracted cone downwards, avoids coincidence : **does not change composite solid**

.. class:: small

    Coincidences common (alignment too tempting?). To fix:

    * **A-B** : grow correct dimension of subtracted shape
    * **A+B** : grow smaller interface shape into bigger, making join

    * :red:`case-by-case fixes straightforward, not so easy to automate`
    * :blue:`need to design joints like a carpenter (with overlaps)` 

    .. image:: ../opticks_refs/opticks_tscan_29_nzero_5_OcrGdsPrt.png
       :width: 500px
       :align: left

   

:small:`Coincident Faces are Primary Cause of Issues : Fake Intersects` Talk
----------------------------------------------------------------------------

.. class:: normal

   Need to design CSG like a carpenter with overlaps to avoid coincident faces.



:small:`Debugging Coincident Subtractions`
-------------------------------------------------------------------------------------------------

.. class:: small

   Switching subtraction into union with complemented -> can see whats subtracted.

.. image:: ../opticks_refs/lvidx_69_ring_box_cuts_artifact.png
   :width: 900px
   :align: center

:small:`Debugging Coincident Subtractions` Talk
-----------------------------------------------

.. class:: normal

   Converting a CSG subtraction into union allows seeing what is being subtracted. 


:small:`Opticks : translates G4 geometry to GPU, without approximation`
------------------------------------------------------------------------------------

.. sidebar:: Volumes -> Boundaries 

    .. class:: small

      **Ray tracing favors Boundaries**

      Material/surface boundary : 4 indices

      * outer material (parent)
      * outer surface (inward photons, parent -> self)
      * inner surface (outward photons, self -> parent)
      * inner material (self)

      Primitives labelled with unique boundary index

      * ray primitive intersection -> boundary index
      * texture lookup -> material/surface properties

      **Material/Surface/Scintillator properties**

      * interpolated to standard wavelength domain
      * interleaved into "boundary" texture  
      * "reemission" texture for wavelength generation 


.. class:: small

    Geant4 Solids+Volumes -> Opticks CSG,GGeo -> GPU

    * simpler : no G4DAE+GDML export/import

    **Structure of Volumes**

    * repeated geometry instances identified (progeny digests)
    * instance transforms used in OptiX/OpenGL geometry 
    * merge CSG trees into global + instance buffers 


:small:`Opticks : translates G4 geometry to GPU, without approximation` Talk
----------------------------------------------------------------------------

.. class:: normal

   The CSG implementation enables the full translation without approximation 


:small:`Opticks Instancing : "Factorizes" Geometry`
----------------------------------------------------------------------------------------


.. sidebar:: :small:`Form of GPU Detector Geometry`

    .. class:: small

        **GAS**
           * intersection + bbox CUDA programs
           * buffers: CSG nodes, transforms, planes
            
        **IAS**
           * transforms and references to **GAS** 
           * identity info, boundary tex. refs

        **Boundary GPU Texture, interleaving:**
           * material props
           * surface props


    .. raw:: html

         <hr/>

    .. class:: small

       **JUNO: ~300,000 GVolume -> ~10 GMergedMesh**

       *repeated GMergedMesh* 
          | thousands of instance transforms
          | consolidates < 10 *GVolume* 

       *remainder GMergedMesh* 
          | one identity instance transform
          | consolidates ~ few hundred *GVolume*



.. class:: small

   Structural volumes vs solid shapes 
      | distinction for convenience only, :redbold:`distinction is movable` 

   JUNO: ~300,000 GVolume : **mostly small repeated groups** (PMTs)

   **GGeo/GInstancer**

   0. GVolume **progeny digest** : shapes+transforms -> :red:`subtree ident.` 
   1. find repeated **digests**, disqualifying repeats inside others
   2. label all nodes with repeat index, non-repeated remainder : 0 

   For each repeat+remainder create **GMergedMesh**:

   * collecting transforms, identity -> instance arrays 
   * merged volumes+solids  

     * **GMesh**: concatenated arrays: triangles, indices 
     * **GParts**: concatenated arrays: CSG nodes + transforms  
     * transforms applied -> :red:`gets into instance frame`   
     * :bluebold:`Consolidation : structural volumes -> compound solid`

   **GMergedMesh** -> **IAS+GAS** 
 
   * OptiX6 : ~10(IAS + GAS)  OptiX7: 1 IAS + ~10 GAS 
      

.. class:: tiny

   https://bitbucket.org/simoncblyth/opticks/src/master/ggeo/GInstancer.hh
     

:small:`Opticks Instancing : "Factorizes" Geometry` Talk
--------------------------------------------------------

.. class:: normal

    * 2nd step of the translation is a factorization into geometry instances.

    * think of the geometry as large tree of volumes
    * each node in the tree has a subtree of other nodes
    * defining a progeny digest for each node makes it possible to find repeated subtrees

      * crucially this does not need any special identification from the user, so it can be automated
    
    * the instance transforms of the repeats can then be collected, and the remainder nodes 
      that are not repeated enough become the global remainder with an associated identity transform 
 




:small:`Opticks : Translate Geant4 Optical Physics to GPU (OptiX/CUDA)`
--------------------------------------------------------------------------

.. sidebar:: :small:`GPU Resident Photons`

    .. class:: small

       **Seeded on GPU** 
          associate photons -> *gensteps* (via seed buffer)
 
       **Generated on GPU, using genstep param:**
         * number of photons to generate
         * start/end position of step
         * *gensteps* : hybrid CPU+GPU generation

       **Propagated on GPU**
          :red:`Only photons hitting PMTs copied to CPU`


       Thrust: **high level C++ access to CUDA**

       .. figure:: /env/numerics/thrust/thrust.png
          :width: 300px
          :align: right

       * https://developer.nvidia.com/Thrust
       
                  
.. class:: small

    :blue:`OptiX : single-ray programming model` -> line-by-line translation

    **CUDA Ports of Geant4 classes**
      * G4Cerenkov (only generation loop) 
      * G4Scintillation (only generation loop) 
      * G4OpAbsorption
      * G4OpRayleigh 
      * G4OpBoundaryProcess (only a few surface types)

    **Modify Cerenkov + Scintillation Processes**
      * collect *genstep*, copy to GPU for generation
      * :red:`avoids copying millions of photons to GPU`

    **Scintillator Reemission**
      * fraction of bulk absorbed "reborn" within same thread
      * wavelength generated by reemission texture lookup

    **Opticks (OptiX/Thrust GPU interoperation)** 
      * **OptiX** : upload gensteps 
      * **Thrust** : seeding, distribute genstep indices to photons
      * **OptiX** : launch photon generation and propagation
      * **Thrust** : pullback photons that hit PMTs 
      * **Thrust** : index photon step sequences (optional)



:small:`Opticks : Translate Geant4 Optical Physics to GPU (OptiX/CUDA)` Talk
----------------------------------------------------------------------------

.. class:: normal

    In addition to the geometry the optical physics is also needed on the GPU.

    * fortuntely it was straightforward to port the geant4 implementations to CUDA



:small:`Optical Photon Simulation : Deciding history on way to boundary`
--------------------------------------------------------------------------

.. sidebar:: :small:`Possible Histories`

    .. image:: to_boundary.png
       :width: 500px
       :align: center

    .. class:: small

        * optical photon simulation straightforward : as only a few processes
        * BUT : principals are the same as full MC 

.. class:: small

    1. intersect ray with geometry -> distance to boundary
    2. lookup absorption length, scattering length for material
       depending on wavelength 

       * *Opticks* uses GPU texture interpolation 

    3. "role dice" : characteristic lengths -> stochastic distances 

    :red:`Pick winning process from smallest distance` 
   
.. raw:: html

    <pre class="mypretiny">
    boundary_distance = from_geometry  # no random number needed
    absorption_distance = -absorption_length * ln(u0) 
    scattering_distance = -scattering_length * ln(u1) 
    ## u0, u1 uniform randoms in [0,1] : distances always +ve 
    </pre>

.. class:: small

    If scatter:
   
    4. pick new photon direction at random
    5. set polarization perpendicular to new direction (transverse) 
       and in same plane as direction and initial polarization  
    6. **rejection-sampling used to pick new polarization** 
       such that angle between old and new follows cos^2 distribution  

    7. then repeat from 1. 

  
    :red:`Theory (eg Rayleigh scattering) -> PDFs used in the simulation`    



.. comment

   How to actually use Monte Carlo method to implement an optical photon simulation...



:small:`Optical Photon Simulation : Deciding history on way to boundary` Talk
-----------------------------------------------------------------------------

.. class:: normal

   The optical simulation can be split into two sections:

   * propagate_to_boundary 
   * propagate_at_boundry 



:i:`Geant4OpticksWorkflow`
----------------------------

:i:`Geant4OpticksWorkflow` Talk
-------------------------------

.. class:: small

    SMALL
    So : how can an external optical photon simulation be integrated with Geant4 ?

    In the standard workflow the Geant4 Scintillation and 
    Cerenkov processes calculate a number of photons 
    and then loop generating these and collecting them 
    as secondaries
     
    In the hybrid workflow, this generation is split 
    between the CPU and GPU with "Gensteps" acting as the bridge. 
    These Genstep parameters include the number of photons, positions and everything 
    else needed in the generation loop.

    Result is a very simple port of the generation loop to the GPU. 

    Its doubly helpful to generate photons on GPU, as then
    they take no CPU memory. 
  
    So can entirely offload photon memory to the GPU with only hits needing CPU memory. 

    Also this keeps the overheads low as gensteps are typically a factor of 100 smaller
    than photons.   
 
    The geometry is also needed on the GPU, with all 
    material and surface properties.
     


:small:`Validation of Opticks Simulation by Comparison with Geant4`  
--------------------------------------------------------------------


.. sidebar:: :small:`Random Aligned Bi-Simulation`

    .. class:: small

        Same inputs to *Opticks* and *Geant4*:

        * CPU generated photons 
        * GPU generated randoms, fed to *Geant4*

        Common recording into *OpticksEvents*:

        * compressed photon step record, up to 16 steps
        * persisted as *NumPy* arrays for python analysis   

        Aligned random consumption, direct comparison:

        * ~every **scatter, absorb, reflect, transmit** 
          at matched positions, times, polarization, wavlen



.. class:: small


   **Bi-simulations of all JUNO solids, with millions of photons**

   mis-aligned histories
       mostly < 0.25%, < 0.50% for largest solids    
       
   deviant photons within matched history
       < 0.05% (500/1M) 
 
   **Primary sources of problems**

   * grazing incidence, edge skimmers
   * incidence at constituent solid boundaries 


   **Primary cause : float vs double** 
      
   *Geant4* uses *double* everywhere, *Opticks* only sparingly (observed *double* costing 10x slowdown with RTX) 

   **Conclude** 

   * :blue:`neatly oriented photons more prone to issues than realistic ones`
   * perfect "technical" matching not feasible
   * instead shift validation to more realistic full detector "calibration" situation    


:small:`Validation of Opticks Simulation by Comparison with Geant4`   Talk
--------------------------------------------------------------------------

.. class:: normal

   Aligned bi-simulation very efficiently finds discrepancies. Because it 
   is a direct comparison unclouded by statistical variation : so issues show up 
   very clearly.   

   Comparing individual solids shows discrepancies at the fraction of a percent level.

   Main cause is float vs double. 






:i:`scan-pf-check-GUI-TO-SC-BT5-SD`
--------------------------------------

:i:`scan-pf-check-GUI-TO-SC-BT5-SD` Talk
----------------------------------------

.. class:: normal

   This GUI allows interactive selection between tens of millions 
   of photons based on their histories.  

   Here its showing the photons that scattered before boundary transmitting straight 
   through to surface detect.

   Its implemented by indexing the photon histories using some very fast 
   GPU big integer sorting provided by CUDA Thrust, 
   and using OpenGL shaders to switch between selections.

   The 64-bit integers hold up to 16 4-bit flags for each step of the photon.

   All of this is done using interop capabilities of OpenGL/CUDA/Thrust and OptiX
   so GPU buffers can be written to and rendered inplace with no copying around.


:i:`scan-pf-check-GUI-TO-BT5-SD`
----------------------------------

:i:`scan-pf-check-GUI-TO-BT5-SD` Talk
-------------------------------------

.. class:: normal

   The GUI also provides interactive time scrubbing of the propagation 
   of tens of millions of photons. 

   This is some nanoseconds later for a different history category. 
  
   I created this GUI to help with debugging the simulation. 


.. comment

     * DELL Precision 7920T Workstation
     * Intel Xeon Silver 4114, 2.2GHz, 40 cores, 65G 
     * NVIDIA Quadro RTX 8000, 48G 

     * DELL Precision 7920T Workstation
     * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 65G  
     * NVIDIA TITAN RTX, 24G
     * NVIDIA TITAN V, 12G






:small:`Performance : Scanning from 1M to 400M Photons`  
---------------------------------------------------------------

.. sidebar:: :small:`Test Hardware + Software`

     .. class:: small

         **Workstation**

         * DELL Precision 7920T Workstation
         * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 62G  
         * NVIDIA Quadro RTX 8000 (48G) 
    
         **Software**

         * Opticks 0.0.0 Alpha 
         * Geant4 10.4p2 
         * NVIDIA OptiX 6.5.0
         * NVIDIA Driver 435.21
         * CUDA 10.1

         **IHEP GPU Cluster**

         * 10 nodes of 8x NVIDIA Tesla GV100 (32G) 




.. class:: small

     **Full JUNO Analytic Geometry j1808v5**

     * "calibration source" genstep at center of scintillator

     **Production Mode : does the minimum**

     * only saves hits  
     * skips : genstep, photon, source, record, sequence, index, ..
     * no *Geant4* propagation (other than at 1M for extrapolation)

     **Multi-Event Running, Measure:**

     :red:`interval` 
       avg time between successive launches, including overheads:
       (upload gensteps + :blue:`launch` + download hits)

     :blue:`launch` 
       avg of 10 OptiX launches


     * overheads < 10% beyond 20M photons



:small:`Performance : Scanning from 1M to 400M Photons`   Talk
--------------------------------------------------------------

.. class:: normal

   Emitting millions of photons from the center of the scintillator 
   and timing the interval and launch times of the propagation 
   provides a measure of the performance of a geometry.
   
   By interval, I mean the time between suceessive launches : so this 
   covers all the overheads of copying the gensteps to the GPU and 
   pulling back the hits to the CPU.

   Overheads are less than 10%    



.. comment

    .. sidebar:: :small:`Genstep/Hit Copying Overheads`

         .. class:: small

             **launch**
               time of each OptiX launch (avg of 10)

             **interval, including overhead**
               time between subsequent launches (avg of 9)

             :red:`Mostly < 10% Overhead beyond 20M photons`






:i:`scan-pf-1_NHit`
---------------------

.. raw:: html

     <pre>








     </pre>


.. sidebar:: :small:`Photon Launch Size : VRAM Limited`

     .. class:: small


         **NVIDIA Quadro RTX 8000 (48 GB)**

         * photon 4*4 floats : 64 bytes
         * curandState       : 48 bytes 

         **400M photons** x :blue:`112 bytes` ~ 45G  



:i:`scan-pf-1_NHit` Talk
------------------------

.. class:: normal

    The first check is that you get the expected number of hits 
    as a function of the number of photons.

    The photon parameters takes 64 bytes and curandState takes 48 bytes
     
    So thats 112 bytes per photon, so the limit on the number 
    of photons that can be simulated in a single launch with this 48G 
    GPU is a bit more than 400M.


:i:`scan-pf-1_Opticks_vs_Geant4 2`
------------------------------------

.. raw:: html

    <pre>
   


 
    </pre>


.. class:: small

    .. table:: 
        :align: center

        +--------------------+----------------------------+------------------+
        | JUNO analytic, 400M photons from center         |  Speedup         |
        +====================+============================+==================+
        | Geant4 Extrap.     | 95,600 s (26 hrs)          |                  | 
        +--------------------+----------------------------+------------------+
        | Opticks RTX ON (i) | 58 s                       |   1650x          |
        +--------------------+----------------------------+------------------+


:i:`scan-pf-1_Opticks_vs_Geant4 2` Talk
---------------------------------------

.. class:: normal

   This compares the extrapolated Geant4 propagation time with the Opticks launch
   interval with RTX on.   The speedup is more than a factor of 1000.   Need to 
   use a log scale to make them both visible. 

   For 400M photons, Geant4 takes more than a day, Opticks takes less than a minute.   

   This is with analytic geometry. Speedup is a lot more with triangles.



:i:`scan-pf-1_Opticks_Speedup 2`
---------------------------------

.. raw:: html
  
     <pre>









     </pre>

.. class:: small

     .. table:: 
        :align: center

        +-------------------------+------------------+------------------+
        | JUNO analytic, 400M photons from center    |   Speedup        |
        +=========================+==================+==================+
        | Opticks RTX ON (i)      | 58s              |   1650x          |
        +-------------------------+------------------+------------------+
        | Opticks RTX OFF (i)     | 275s             |   350x           |
        +-------------------------+------------------+------------------+
        | Geant4 Extrap.          | 95,600s (26 hrs) |                  |
        +-------------------------+------------------+------------------+


:i:`scan-pf-1_Opticks_Speedup 2` Talk
-------------------------------------

.. class:: normal

    This is the same information shown as a ratio.





``CHEP 2019 Plenary, Adelaide, Australia``
---------------------------------------------

``CHEP 2019 Plenary, Adelaide, Australia`` Talk
-----------------------------------------------

.. class:: normal

    This photo shows me presenting this at the CHEP plenary



NVIDIA Giveth and NVIDIA Taketh away ...
------------------------------------------

.. class:: small 

   +------+------------------------------------------------------------------------------------------------------+
   | 2006 |  CUDA 1.0                                                                                            |
   +------+------------------------------------------------------------------------------------------------------+
   | 2009 |  NVIDIA OptiX 1.0                                                                                    |
   +------+------------------------------------------------------------------------------------------------------+
   | 2018 |  NVIDIA: "World's first ray tracing GPU" : ray trace dedicated RT cores, RTX, :b:`10 Giga Rays/s`    | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2019 | Opticks: [1st Gen. RTX GPU] OptiX 6.5, JUNO analytic: 58s 400M photons (7M photons/s, ~70M rays/s)   | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2019 |  NVIDIA OptiX 7.0 : **ENTIRELY NEW API**  :r:`=> Opticks needs full re-implementation`               | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2021 |  NVIDIA Engineers assist Opticks dev. for 6->7 in series of seven meetings (LBNL, LZ )               | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2022 |  3rd generation RTX : expect > 4x ray trace performance of 1st gen.                                  |   
   +------+------------------------------------------------------------------------------------------------------+

NVIDIA Giveth and NVIDIA Taketh away ... Talk
---------------------------------------------

.. class:: normal


    IN 2019 NVIDIA introduced an entirely new OptiX API, which effectively meant that Opticks
    had to be full re-implemented

    In 2018 NVIDIA introduced a GPU with hardware dedicated to accelerating ray tracing.
    NVIDIA claims it can reach 10 billion ray geometry intersections per second
    with a single GPU. 

    Assuming each simulated photon costs 10 rays, that means the upper limit per GPU is 
    1 billion photons/second.

    





:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`GPU Ray Tracing APIs Converged`

    .. class:: small

        * 3 APIs (DXR,VKRay,OptiX7) over RTX 
        * Driver updates :r:`independent of application`  
        * Support new GPUs, performance improvements 

.. class:: small

    **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

    * low-level CUDA-centric thin API (Vulkan-ized)
    * headers only (no library, impl in Driver) 
    * Minimal host state,  :red:`All host functions are thread-safe`
    * GPU launches : explicit, asynchronous (CUDA streams)
    * :strike:`near perfect scaling to 4 GPUs, for free` 
    * :strike:`Shared CPU/GPU geometry context` 

      * :r:`=> NEED CPU/GPU GEOMETRY MODEL + TRANSLATOR`

    * :strike:`GPU memory management`
    * :strike:`Multi-GPU support`


.. class:: small

    **Advantages of 6->7 transition**

    * More control/flexibility over everything 
    * :b:`Keep pace with state-of-the-art GPU ray tracing` 
    * Fully benefit from current + future GPUs : RT cores, RTX 

.. class:: small

    **BUT:** :r:`demanded full re-implementation of Opticks` 
     


:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation` Talk
--------------------------------------------------------------------------------------

.. class:: normal

   * OptiX 7 is an entirely new API, dropping many features used by the old Opticks
   * re-implementation of almost all of Opticks was necessary

   [Notes: No need to read slide, just the above comments]



:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing`
--------------------------------------------------------------------------

.. sidebar:: :small:`Flexible Ray Tracing Pipeline` 

    .. class:: small

        :g:`Green: User Programs`,  :e:`Grey: Fixed function/HW`

    .. image:: nvidia/optix7/OptiX-API.png
       :width: 450px
       :align: right

    .. class:: small

        :b:`Analogous to OpenGL rasterization pipeline` 


.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * :r:`Programmable GPU-accelerated Ray-Tracing Pipeline`
   * Single-ray shader programming model using CUDA
   * ray tracing acceleration using RT Cores (RTX GPUs)
   * "...free to use within any application..."

   **OptiX features**

   * acceleration structure creation + traversal (eg BVH)
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

   ``https://developer.nvidia.com/rtx/ray-tracing/optix``

.. class:: small

   **User provides (Green):**

   * ray generation
   * geometry bounding boxes
   * intersect functions 
   * instance transforms

   :r:`Same high level model in OptiX 7, everything else new` 
   

:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing` Talk
-----------------------------------------------------------------------------

.. class:: normal

   While all details changed in the giant leap from OptiX 6=>7 
   the high level structure mostly remained.  

   NVIDIA OptiX makes GPU ray tracing accessible 

   * it divides up the ray tracing workflow 
   * the green boxes represent user provided CUDA programs, including:

     * ray generation : where Opticks generates photons and steers the simulation
     * intersection : where the CSG geometry is implemented 

   * geometry has to be translated into a GPU appropriate easily serialized form



:small:`"Foundry" Model : Shared CPU/GPU Geometry Context`
-----------------------------------------------------------------------------------------------------

.. sidebar:: :small:`IAS < Inst < Solid < Prim < Node`

    .. class:: small

        * **Inst** : 4x4 tran. + **Solid** ref. ( **Inst** -> 1 **IAS** )
        * **Solid** : 1 or more **Prim**  : ( **Solid** -> **GAS** )
        * **Prim** : 1,3,7,15,31,... **Node**  : (**Prim** ~ *G4VSolid*) 

    .. raw:: html

        <pre class="mypretiny">
        struct CSGFoundry
        {
           void upload(); <span class="redbold">// to GPU </span> 
        ...
           std::vector&lt;CSGSolid&gt;  solid ; // compounds (eg PMT)
           std::vector&lt;CSGPrim&gt;   prim ;
           std::vector&lt;CSGNode&gt;   node ; // shapes, operators

           std::vector&lt;float4&gt; plan ; // planes
           std::vector&lt;qat4&gt;   tran ; // CSG transforms
           std::vector&lt;qat4&gt;   itra ; // inverse CSG transforms
           std::vector&lt;qat4&gt;   inst ; // instance transforms

           <span class="redbold">// entire geometry in four GPU allocations</span>
           CSGPrim*    d_prim ; 
           CSGNode*    d_node ; 
           float4*     d_plan ; 
           qat4*       d_itra ;    
         };
        </pre>

    .. class:: small

        :bluebold:`referencing by offset, count`  

.. class:: small

    **Geometry model designed for CPU/GPU**

    * very different to Geant4 model (dense tree of C++ objects)
    * :r:`replaces geometry context dropped in OptiX 6->7` 
    * array-based -> simple, inherent serialization + persisting 
    * entire geometry in 4 GPU allocations 

    **Simple CPU/GPU intersect headers** 

    :b:`https://github.com/simoncblyth/opticks/tree/master/CSG` 
        **csg_intersect_tree.h/csg_intersect_node.h/...**


.. raw:: html

    <pre>

    </pre>

.. class:: tiny

   **GAS** : Geometry Acceleration Structure

   **IAS** : Instance Acceleration Structure
   
   **CSG** : Constructive Solid Geometry 


:small:`"Foundry" Model : Shared CPU/GPU Geometry Context` Talk
---------------------------------------------------------------

.. class:: small

   SMALL 
   The Foundry geometry model comprises : Inst, Solid, Prim and Node

   Starting from the bottom:

   * the Node are CSG constituent shapes or operators
   * the Prim reference a range of Node forming serialized complete binary trees
   * the Solid reference one or more Prim
   * the Inst reference one or more Solid 

   **Prim:** are equivalent to G4VSolid

   **Solid:** are compound Prim, each type of PMT corresponds to a Solid 

   **Inst:** are 4x4 transforms with index refererences to Solid 

   The model is designed to work with the OptiX 7 acceleration structures:

   * Solid -> GAS (Geometry Acceleration Structure)
   * Inst  -> IAS (Instance Acceleration Structure)

   The JUNO geometry of 300,000 volumes is factorized into 10 Solid which 
   are referenced from a single instance acceleration structure. 
    
   The array-based simplicity makes it fast to upload to GPU, 
   with the entire geometry in 4 GPU allocations. 




.. comment

    Translation, initially 2 step::

               X4      CSG_GGeo
        Geant4 --> GGeo -->  CSG   

    Later one step::
 
                U4/tree
        Geant4 -> stree/CSG 




:small:`Two-Level Hierarchy : Instance transforms (IAS) over Geometry (GAS)`
-------------------------------------------------------------------------------

.. class:: small

    **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


.. class:: small

    .. figure:: nvidia/tlas_blas_two_level_hierarchy.png
        :width: 800px
        :align: right 

        https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

.. class:: small

   AS
      Acceleration Structure

   **IAS** (aka TLAS) 
      :b:`4x4 transforms, refs to GAS`
       
   **GAS** (aka BLAS)
      | :b:`custom primitives : AABB` 
      | triangles : vertices, indices

   AABB
      axis-aligned bounding box 


   **SBT : Shader Binding Table**

   Flexibly binds together:
 
   1. geometry objects
   2. shader programs 
   3. data for shader programs

   **Hidden in OptiX 1-6 APIs**



:small:`Two-Level Hierarchy : Instance transforms (IAS) over Geometry (GAS)` Talk
---------------------------------------------------------------------------------

.. class:: normal

   OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
   The other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
   This is because OptiX supports multiple instance levels. 
   But the simple two level is faster as that can be done on the RT cores.

   Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  





:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7`
-------------------------------------------------------------------------------

.. sidebar:: :small:`CSGFoundry Model`

    .. class:: small

        * :b:`array-based -> simple serialization + upload`
        * entire geometry in 4 GPU allocations 
        * factorized using subtree digests 

.. class:: small

    **Geant4 Geometry Model (JUNO: 300k PV, deep hierarchy)**

    +----+---------------------------+---------------------------------------------+ 
    | PV | *G4VPhysicalVolume*       | placed, refs LV                             |
    +----+---------------------------+---------------------------------------------+ 
    | LV | *G4LogicalVolume*         | unplaced, refs SO                           |
    +----+---------------------------+---------------------------------------------+ 
    | SO | *G4VSolid,G4BooleanSolid* | binary tree of SO "nodes"                   |
    +----+---------------------------+---------------------------------------------+ 

    **Opticks CSGFoundry Geometry Model** (index references)

    +---------------+----------------------------------------------------------------------------+----------------------------+
    | struct        | Notes                                                                      |  Geant4 Equivalent         |
    +===============+============================================================================+============================+
    | *CSGFoundry*  | vectors of the below, easily serialized + uploaded + :r:`used on GPU`      | None                       |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *qat4*        | 4x4 transform refs *CSGSolid* using "spare" 4th column (:b:`becomes IAS`)  | Transforms ref from PV     |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGSolid*    | refs sequence of *CSGPrim*                                                 | Grouped Vols + Remainder   | 
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGPrim*     | bbox, refs sequence of *CSGNode*, root of CSG Tree of nodes                | root *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGNode*     | CSG node parameters (JUNO: ~23k *CSGNode*)                                 | node *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+

    **NVIDIA OptiX 7 Geometry Acceleration Structures (JUNO: 1 IAS + 10 GAS, 2-level hierarchy)**

    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | IAS | Instance Acceleration Structures | JUNO: 1 IAS created from vector of ~50k *qat4* (JUNO)                   |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | GAS | Geometry Acceleration Structures | JUNO: 10 GAS created from 10 *CSGSolid* (which refs *CSGPrim,CSGNode* ) |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 

.. class:: small

    :r:`JUNO : Geant4 ~300k volumes "factorized" into 1 OptiX IAS referencing ~10 GAS`


:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7` Talk
---------------------------------------------------------------------------------

.. class:: normal

   The tables illustrates three geometry models.

   The CSGFoundry geometry model in the middle was designed 
   to enable translation between the Geant4 and OptiX models. 




:i:`cxr_overview_emm_t0_elv_t_moi__ALL_with-debug-disable-xj.jpg`
------------------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:2cm;" />


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        * :redbold:`purely analytic CSG, no triangles` 
      
        +--------------------------------------------+
        |  raytrace 2M pixels 1920x1080              |
        +======================+=====================+
        | **NVIDIA TITAN RTX** | 0.0091s (~110 FPS)  |
        | (1st gen. RT Cores)  |                     |
        +----------------------+---------------------+


:i:`cxr_overview_emm_t0_elv_t_moi__ALL_with-debug-disable-xj.jpg` Talk
----------------------------------------------------------------------

.. class:: normal

   Here is a ray trace render of JUNO using OptiX 7 
   There are no triangles here, this is a purely analytic ray trace with 
   the exact same geometry that the simulation uses.

   [Notes: ~10s slide, just the comment] 




.. comment

    :i:`cxr_min__eye_-10,0,0__zoom_1__tmin_0.1__sChimneyAcrylic_altview.jpg`
    -------------------------------------------------------------------------

    ``Raytrace render view from inside JUNO Water Buffer``

    .. s5_talk::

       Here is a view from inside the JUNO Water Buffer showing the PMTs
       pointing down at the acrylic sphere that contains the scintillator. 



.. comment

    :i:`cxr_min__eye_-30,0,5__zoom_1__tmin_25__sChimneyAcrylic_tmin_cutaway.jpg`
    ------------------------------------------------------------------------------

    ``ray TMIN cuts away sphere`` 

    .. s5_talk::

       Unlike with rasterization clipping, setting a ray tracing TMIN cuts away a sphere. 


    :i:`cxr_min__eye_-30,0,5__zoom_1__tmin_25__sChimneyAcrylic_skip_target_acrylic.jpg`
    ------------------------------------------------------------------------------------

    ``ELV=t94,95 ./cxr_min.sh  ## skip sTarget sAcrylic``

    .. s5_talk::

       Skipping the acrylic sphere and scintillator target allows to see more of the PMTs
       

.. comment

    `Increase TMAX to avoid cutoff`


:i:`cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_increased_TMAX.jpg`
-----------------------------------------------------------------------------------

``Raytrace render view from inside JUNO Water Buffer``


:i:`cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_increased_TMAX.jpg` Talk
--------------------------------------------------------------------------------------

.. class:: normal

    Klop



.. comment

    :i:`cxr_min__eye_-10,0,-30__zoom_0.5__tmin_0.1__sChimneyAcrylic_photon_eye_view.jpg`
    --------------------------------------------------------------------------------------

    ``ELV=t94,95 ./cxr_min.sh ## skip sTarget sAcrylic : upwards view`` 

    .. s5_talk::

       Here is a photon eye view from inside the scintillator, looking upwards towards the Chimney. 


:i:`cxr_overview_emm_image_grid_overview`
-------------------------------------------

``Comparison of ray traced render times of different geometry`` 
  ``simple way to find issues, eg over complex CSG, overlarge BBox`` 


:i:`cxr_overview_emm_image_grid_overview` Talk
----------------------------------------------

.. class:: normal

   Comparisons of ray trace rendering times for different geometriess 
   provides simple way to look for performance issues


.. comment

    :i:`scan_emm_jpg_select.txt_coarse.jpg`
    -----------------------------------------

    :i:`cxr_view_emm_t0_elv_t142_eye_-1,-1,-1,1__zoom_1__tmin_0.4__sWaterTube_skip_sBottomRock.jpg`
    -------------------------------------------------------------------------------------------------

    ``Render inside JUNO water buffer : PMTs, chimney, support sticks`` 


    .. s5_talk::

       Acceleration structure creation is a black box, so have to adopt an experimental 
       approach to finding the best geometry modelling to use.   


:i:`image_grid_elv_scan.jpg`
------------------------------

``Spot the differences : from volume exclusions``

:i:`image_grid_elv_scan.jpg` Talk
---------------------------------

.. class:: normal

   If you look closely at the renders you can see differences 
   from the exclusion of single volume types. Doing this for 
   all volume types allows to sort the volumes by their 
   impact on the performance. 


.. comment

    vi $HOME/j/issues/scan_elv_jpg_select.txt  ## manually prepare list of 9 jpg with visible diffs
    export JPGLIST=$HOME/j/issues/scan_elv_jpg_select.txt
    open -n $(cat $JPGLIST)
    cx
    JPGLIST=$JPGLIST ./image_grid.sh 




.. comment

    cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_explain_the_grey.jpg
    --------------------------------------------------------------------------------

    Maybe a TMAX issue again ?





:small:`cxr_overview.sh ELV scan 1080x1920 2M (NVIDIA TITAN RTX)`
---------------------------------------------------------------------

.. class:: small

    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |idx|        -e|       time(s)    |      relative    |    enabled geometry description                                              |
    +===+==========+==================+==================+==============================================================================+
    |  0|      t133|        0.0077    |        0.9347    |    EXCL: sReflectorInCD                                                      |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  1|       t37|        0.0079    |        0.9518    |    EXCL: GLw1.bt08_bt09_FlangeI_Web_FlangeII                                 |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  2|       t74|        0.0079    |        0.9616    |    EXCL: GZ1.B06_07_FlangeI_Web_FlangeII                                     |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  ...                                                                                                                              |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 35|         t|        0.0083    |        1.0000    |    ALL                                                                       |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  ...                                                                                                                              |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |141|       t50|        0.0097    |        1.1750    |    EXCL: GLb1.up01_FlangeI_Web_FlangeII                                      |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |142|       t39|        0.0097    |        1.1751    |    EXCL: GLw1.bt10_bt11_FlangeI_Web_FlangeII                                 |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |143|      t123|        0.0097    |        1.1753    |    EXCL: PMT_3inch_inner1_solid_ell_helper                                   |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |144|       t46|        0.0097    |        1.1758    |    EXCL: GLb1.up05_FlangeI_Web_FlangeII                                      |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |145|       t16|        0.0102    |        1.2320    |    EXCL: sExpRockBox                                                         |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+

.. class:: small

    :r:`Dynamic geometry : excluding volumes of each of 146 solids (after excluding slowest: solidXJfixture)` 

    * time range : 0.0077->0.0102 s (~ +-20% )  
    * reproducibility ~+-10%

    :b:`Small time range suggests no major geometry performance issues remain, after excluding slowest`

    * :r:`solids with deep CSG trees (eg solidXJfixture) can cause >2x slow downs`  


:small:`cxr_overview.sh ELV scan 1080x1920 2M (NVIDIA TITAN RTX)` Talk
----------------------------------------------------------------------

.. class:: normal

    You might think that the geometry without any exclusions would be the slowest, but 
    that is not the case. Varying the geometry changes the details of the acceleration structure. 
    Here the time range from fastest to slowest is rather small, suggesting there are 
    no major geometry performance problems left. 

    This is only the case after I excluded some problematic geometry. 
 
 





:small:`n-ary CSG Compound "List-Nodes" => Much Smaller CSG trees`
-------------------------------------------------------------------

.. sidebar:: :small:`Complex CSG => Tree Overheads`

    .. image:: GeoChain_Darwin/XJfixtureConstruction/CSGOptiXRenderTest/cvd0/50001/ALL/top_i0_/cxr_geochain_XJfixtureConstruction_ALL_upper.jpg 
          :align: right
          :width: 500px



.. class:: small


   :r:`Communicate shape more precisely`
       :r:`=> better suited intersect alg => less resources => faster` 

   Generalized Opticks CSG into three levels : tree < node < leaf 

   * `csg_intersect_tree.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_tree.h>`_ 
   * `csg_intersect_node.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h>`_
   * `csg_intersect_leaf.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_leaf.h>`_

   :b:`Generalizes binary to n-ary CSG trees`

   * list-node references sub-nodes by **subNum** **subOffset**

   CSG_CONTIGUOUS Union
      user guarantees contiguous, like G4MultiUnion of prim

   CSG_DISCONTIGUOUS Union
      user guarantees no overlaps, eg "union of holes" to be CSG subtracted : :r:`=> simple, low resource intersect` 

   CSG_OVERLAP Intersection
      user guarantees overlap, eg general G4Sphere: inner radius, thetacut, phicut


   :r:`Promising approach to avoid slowdowns from complex CSG solids`


:small:`n-ary CSG Compound "List-Nodes" => Much Smaller CSG trees` Talk
-----------------------------------------------------------------------

.. class:: normal

   Complex solids like this one with deep CSG trees can cause 
   large slowdowns.  In an attempt to reduce the performance degradation 
   I have generalize Opticks CSG to support list nodes in order to 
   reduce tree size and avoid large tree overheads. 


.. comment

    :small:`CSG_CONTIGUOUS Union : n-ary (not bin-ary) CSG intersection`
    -----------------------------------------------------------------------

    .. class:: small

        * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_contiguous`

    .. sidebar:: :small:`Alg works : but many TODOs`

        .. class:: small

           * integer templating : suit resources to shape
           * try sort networks, bitonic sort, ... 
           * compare performance with unbalanced trees
           * iterate implementation whilst measuring perf.


    .. class:: small

        1. *zeroth pass* : find **nearest_enter** and count first exits
        2. if zero exits => outside compound => return **nearest_enter**
        3. *first pass* : collect enter distances, **farthest_exit**
        4. order enter indices making **enter** distances ascend

           * :r:`n-ary : store, sort enters` :b:`(cf bin-ary : compare two)`
           * :b:`no tree overheads, but must store+sort distances`

        5. *2nd pass* : loop over enters in distance order 

           * contiguous requirement : **enter < farthest_exit** so far  
           * find Exits for Enters that qualify as contiguous, update farthest_exit

        6. return **farthest_exit** that qualifies as contiguous


    .. raw:: html

        <pre class="mypre15">
                 +----------------+     +-------------------+                  DISJOINT MUST BE DISQUALIFIED
                 |B               |     |D                  |                   
            +----|----+      +----|-----|----+       +------|----------+             +-----------+
            |A   |    |      |C   |     |    |       |E     |          |             |           |
            |    |    |      |    |     |    |       |      |          |             |           |
            | 0 E1    X2     E3  X4    E5   X6      E7     X8        [X9]           E10         X11
            |    |    |      |    |     |    |       |      |          |             |           |
            |    |    |      |    |     |    |       |      |          |             |           |
            +----|----+      +----|-----|----+       +------|----------+             +-----------+
                 |                |     |                   |
                 +----------------+     +-------------------+

                 E           E          E            E                               E 
                      X           X          X              X          X                         X
         </pre>



    .. s5_talk::

       Communicating the geometry more precisely enables a better suited intersection 
       algorithm to be used. This reduces resources and increases performance. 

       [notes: dont need to explain the algorithm in detail, important point is just the above comment] 




:small:`CSG_DISCONTIGUOUS Union : CSG intersection`
---------------------------------------------------------------

.. class:: small

    * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_discontiguous`

    :r:`User guarantees : absolutely no overlapping between constituents`

.. raw:: html

    <pre class="mypre15">
     +-------+          +-------+          +-------+          +-------+         +-------+      
     |       |          |       |          |       |          |       |         |       |      
     |       |          |       |          |       |          |       |         |       |      
     +-------+          +-------+          +-------+          +-------+         +-------+       

     +-------+          +-------+          +-------+          +-------+         +-------+      
     |       |          |       |          |       |          |       |         |       |      
     |       |          |       |          |       |          |       |         |       |      
     +-------+          +-------+          +-------+          +-------+         +-------+       

     </pre>


.. class:: small

    * => very simple low resource intersection : **closest Enter or Exit**

    * :b:`More closely suiting algorithm to geometry => better performance`
    * this can help with "holes" subtracted from another solid : the "holes" usually do not overlap 

:small:`CSG_DISCONTIGUOUS Union : CSG intersection` Talk
--------------------------------------------------------

.. class:: normal

   Again more precise communication of intent for geometry -> better performance
   as it enables a very low resource intersection appoach to be used and it can 
   avoid tree overheads.  
















.. comment

    :i:`OptiX Title Banner`
    ------------------------

    .. raw:: html

         <p style="margin-bottom:165mm;" />

    .. class:: huge

        https://developer.nvidia.com/rtx/ray-tracing/optix

    .. s5_talk::

        Most NVIDIA OptiX users are involved with realistic image rendering. 
        Fortunately OptiX exposes an intersection API which makes
        it applicable to simulation. So all the effort NVIDIA has expended 
        in accelerating ray tracing becomes directly applicable to simulation. 






Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow
-------------------------------------------------------------

.. class:: small

    .. table::
        :align: center

        +--------------------------------------------------+
        | :b:`https://bitbucket.org/simoncblyth/opticks`   |
        +--------------------------------------------------+


.. raw:: html

    <p style="margin-bottom:13cm;" />

.. class:: small

    Opticks API : split according to dependency -- Optical photons are GPU "resident", only hits need to be copied to CPU memory 


Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow Talk
--------------------------------------------------------

.. class:: normal

    This shows how Opticks is integrated with Geant4. The geometry is translated 
    and uploaded to the GPU at initialization.

    Cerenkov or Scintillation gensteps, the blue lines, are the generation parameters 
    uploaded to the GPU so optical photon generation can be done there.

    This allows the optical photon simulation to be entirely offloaded  
    to the GPU with only collected hits requiring memory on the CPU.
 

Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2
--------------------------------------------------------

.. sidebar:: :small:`Offload Optical Simulation to GPU`

   .. class:: small

      * :r:`translate Geant4 geometry to OptiX GPU`  

        * intersect functions
        * instance transforms
        * GPU textures for mat/surf properties

      * CUDA port of Geant4 generation+propagation

        * cuRAND random number generation
        * may small QUDARap headers implement optical simulation 


Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2 Talk
----------------------------------------------------------

.. class:: normal

    In general, I found that directly porting the optical physics has been straightforward.
    Most of problems and effort of Opticks been with the geometry, because the 
    geometry model needs to be very different from the deep tree of volumes of Geant4.




:small:`Primary Packages and Structs Of Re-Implemented Opticks`
-----------------------------------------------------------------

.. sidebar:: :small:`Flexible Multi-Package Organization`

    .. class:: small

         **Code Organized by Dependency (not "Topic")**
     
         * :r:`maximizes: utility, re-use, ease of testing` 
         * => "GPU" code usable+tested on CPU 

         **Many small header-only implementations** 

         * common CPU/GPU headers   



.. class:: small 

   *SysRap* : many small CPU/GPU headers
     * *stree.h,snode.h* : geometry base types
     * *sctx.h* *sphoton.h* : event base types
     * *NP.hh* : serialization into NumPy .npy format files     

   *QUDARap* 
     * *QSim* : optical photon simulation steering
     * *QScint,QCerenkov,QProp,...* : modular CUDA implementation 

   *U4*
     * *U4Tree* : convert geometry into *stree.h*
     * *U4* : collect gensteps, return hits 

   *CSG*
     * *CSGFoundry/CSGSolid/CSGPrim/CSGNode* geometry model
     * *csg_intersect_tree.h* *csg_intersect_node.h* *csg_intersect_leaf.h* : CPU/GPU intersection functions 

   *CSGOptiX*
     * *CSGOptiX.h* : manage geometry convert from *CSG* to OptiX 7 *IAS* *GAS*, pipeline creation
     * *CSGOptiX7.cu* : compiled into ptx that becomes OptiX 7 pipeline

       * includes QUDARap headers for simulation   
       * includes *csg_intersect_tree.h,..* headers for CSG intersection    
     
   *G4CX*
     * *G4CXOpticks* : Top level Geant4 geometry interface


:small:`Primary Packages and Structs Of Re-Implemented Opticks` Talk
--------------------------------------------------------------------

.. class:: normal

   [HMM: COULD SKIP THIS ONE?]

   Opticks code is split into multiple packages by-dependency, not by-topic
   This means that more of the code has less dependencies, making 
   it more useful and easier to test.   

   Using mocking,  most of the "GPU" code can be tested on CPU.  

   [Notes: <30s slide, mainly for offline consumption, no need to read out]



.. comment

    :small:`Full re-implementation of Opticks for NVIDIA OptiX 7 API` 
    --------------------------------------------------------------------

    .. class:: small

        * :r:`Huge change unavoidable from new OptiX API` --> :b:`So profit from rethink of simulation code` --> **2nd impl advantage** 

        +------------------------------------------+--------------------------------------------------------+
        |  Old simulation (OptiXRap)               |  New simulation (QUDARap/qsim.h + CSGOptiX, CSG)       | 
        +==========================================+========================================================+
        |  * implemented on top of old OptiX API   | * pure CUDA implementation                             |
        |                                          | * :r:`OptiX use kept separate, just for intersection`  |
        |                                          |                                                        |
        +------------------------------------------+--------------------------------------------------------+
        |  * monolithic .cu                        | * many small headers                                   |
        |  * GPU only implementation               | * many GPU+CPU headers                                 |
        |  * deep stack of support code            | * shallow stack : QUDARap depends only on SysRap       | 
        +------------------------------------------+--------------------------------------------------------+
        |  * most code in GPU only context,        | * strict code segregation                              |
        |    even when not needing OptiX or CUDA   |                                                        |
        |                                          |   * :r:`code not needing GPU in SysRap not QUDARap`    |
        +------------------------------------------+--------------------------------------------------------+
        |  * testing : GPU only, coarse            | * :r:`testing : CPU+GPU , fine-grained`                |
        |                                          | * curand mocking on CPU                                | 
        +------------------------------------------+--------------------------------------------------------+
        |  * limited CPU/GPU code sharing          | * maximal sharing : SEvt.hh, sphoton.h, ...            |
        +------------------------------------------+--------------------------------------------------------+
        |  * timeconsuming manual random alignment | * :b:`new systematic approach to random alignment`     |  
        |    conducted via debugger                |                                                        |
        +------------------------------------------+--------------------------------------------------------+

        **Goals of re-implementation : flexible, modular GPU simulation, easily testable, less code**

        * code reduction, sharing as much as possible between CPU and GPU
        * fine grained testing on both CPU and GPU, with GPU curand mocking 
        * profit from several years of CUDA experience, eg QSim.hh/qsim.h host/device counterpart pattern:

          * hostside initializes and uploads device side counterpart --> :r:`device side hits ground running` 


    .. s5_talk::

        Embracing the change : might as well profit from a rethink 

        [Notes: dont read out as too much text, just read a few of the highlighted]









:small:`QUDARap : CUDA Optical Simulation Implementation`
------------------------------------------------------------

.. sidebar:: :small:`CPU Pre-Init of GPU Counterpart`

    .. class:: small

        hh
           instanciate device .h **on host**, upload constituents (eg texture buffers),  
           set constituent device pointers into .h instance, upload .h instance to GPU  
        h
           simple device header, testable on CPU 
            
        --> :r:`device side hits ground running` 


.. class:: small

    **CPU/GPU Counterpart Code Organization for Simulation**

    +-------------------------------+-----------------+-----------------------+
    |                               | CPU             | GPU                   |
    +===============================+=================+=======================+
    | context steering              | QSim.hh         |  qsim.h               |  
    +-------------------------------+-----------------+-----------------------+
    | curandState setup             | QRng.hh         |  qrng.h               |
    +-------------------------------+-----------------+-----------------------+
    | property interpolation        | QProp.hh        |  qprop.h              |
    +-------------------------------+-----------------+-----------------------+
    | event handling                | QEvent.hh       |  qevent.h             |
    +-------------------------------+-----------------+-----------------------+
    | Cerenkov generation           | QCerenkov.hh    |  qcerenkov.h          |
    +-------------------------------+-----------------+-----------------------+
    | Scintillation generation      | QScint.hh       |  qscint.h             |
    +-------------------------------+-----------------+-----------------------+
    | texture handling              | QTex.hh         |  cudaTextureObject_t  |
    +-------------------------------+-----------------+-----------------------+
    

    * :r:`facilitate fine-grained modular testing` 
    * bulk of GPU code in simple to test headers 

      * test most "GPU" code on CPU,  eg using mock curand

    * *QUDARap* does not depend on OptiX -> more flexible -> simpler testing    



:small:`QUDARap : CUDA Optical Simulation Implementation` Talk
--------------------------------------------------------------

.. class:: normal

    Of course in addition to geometry intersections the simulation also 
    needs the optical physics. The QUDARap package is a pure CUDA port 
    of the Geant4 optical simulation, with no OptiX dependency. 

    [Notes: mainly of intersect for people writing CUDA code, a useful pattern] 


.. comment

       +---------------------------------------+
       | **A** (GPU) CSGOptiX/qsim.h           |
       +=======================================+
       |  qsim => sctx/sevent/SEvt             |
       +---------------------------------------+

       +---------------------------------------+
       | **B** (CPU) U4Recorder                |
       +=======================================+
       | G4StepPoint => sctx/sevent/SEvt       |
       +---------------------------------------+



:small:`Validation of Opticks Simulation(A) by Comparison with Geant4 Sim. (B)`
--------------------------------------------------------------------------------

.. sidebar:: :small:`A+B photon histories => SEvt`

   .. class:: small

      * **A** : CSGOptiX : qsim => SEvt
      * **B** : U4Recorder : G4StepPoint => SEvt 

      +---------------------------------------+
      | **Opticks Event** : sysrap/SEvt.hh    |
      +=======================================+ 
      | sevent.h sctx.h sphoton.h srec.h ...  |
      +---------------------------------------+
      | :r:`serialize to NumPy .npy arrays`   |
      +---------------------------------------+

      => A-B comparison, matplotlib/pyvista plotting

      +------------+------------+------------------+
      |  array     | shape      |  notes           |  
      +============+============+==================+
      | inphoton   | (n,4,4)    | input photons    |
      +------------+------------+------------------+
      | photon     | (n,4,4)    | final photons    |
      +------------+------------+------------------+
      | record     | (n,32,4,4) | photon histories |
      +------------+------------+------------------+
      | seq        |  (n,2,2)   | uint64 histories |   
      +------------+------------+------------------+
      | aux        | (n,32,4,4) | extra point info |       
      +------------+------------+------------------+
      | sframe     | (4,4,4)    | target M2W W2M   |
      +------------+------------+------------------+

      :b:`Record of every point of every photon`


.. class:: small 

   **A and B always same photon counts (due to gensteps)** 

   1. direct comparison when simulations are random aligned
   2. when not aligned : statistical Chi2 history comparison

      * compare history frequencies, Chi2 points to issues

   **Primary Issue : double vs float, also:**

   * geometry bugs : overlaps, coincident faces 
   * grazing incidence, edge skimmers

   After debugged : :b:`fraction of percent diffs` 



   

:small:`Validation of Opticks Simulation(A) by Comparison with Geant4 Sim. (B)` Talk
------------------------------------------------------------------------------------

.. class:: normal

    The Opticks simulation is validated by comparison with the Geant4 simulation. 

    Full details of the optical photon propagations from both simulations 
    are collected into Opticks Events and persisted to NumPy arrays. 
    Allowing NumPy analysis to compare the photon propagations. 




.. comment

   **Optical Performance : Very dependent on geometry + modelling**

   After avoiding geometry problems : G4Torus, deep CSG trees

   * :r:`have achieved > 1500x Geant4 [1]` 
   * :b:`removes optical bottlenecks : memory + processing` 

   .. class:: tiny 

      [1] Single threaded Geant4 10.4.2, NVIDIA Quadro RTX 8000 (48G), 1st gen RTX, ancient JUNO geom, OptiX 6.5, ancient Opticks 
     



:small:`Optical Simulation Comparison : Statistical OR Direct`
----------------------------------------------------------------

.. class:: small

    Statistical Chi-squared comparison of photon history occurence between two simulations

    * powerful metric to find discrepancies between simulations (eg from near-degenerate geometry)

.. raw:: html
 
    <pre class="mypretiny">
    c2sum/c2n:c2per(C2CUT)  280.88/188:1.494 (30)

    np.c_[siq,_quo,siq,sabo2,sc2,sabo1][0:25]  ## A-B history frequency chi2 comparison 
        0   TO BT BT BT BT SD                                             33322  33343    0.0066        1      2  
        1   TO BT BT BT BT SA                                             28160  28070    0.1441        8      0  
        2   TO BT BT BT BT BT SR SA                                        6270   6268    0.0003    10363  10565  
        3   TO BT BT BT BT BT SA                                           4552   4649    1.0226     8398   8433  
        4   TO BT BT BT BT BT SR BR SR SA                                  1154   1186    0.4376    21156  21014  
        5   TO BT BT BT BT BT SR BR SA                                      923    989    2.2782    20241  20201  
        6   TO BT BT BT BT BR BT BT BT BT BT BT AB                          946    958    0.0756    10389   8432  
        7   TO BT BT BT BT BT SR SR SA                                      901    942    0.9121    10399  10410  
        8   TO BT BT AB                                                     878    895    0.1630       26    102  
        9   TO BT BT BT BT BT SR BT BT BT BT BT BT BT AB                    615    635    0.3200    20974  22027  
       10   TO BT BT BT BT BR BT BT BT BT AB                                571    601    0.7679     8459   9208  
       11   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SA                    533    537    0.0150     7312   7299  
       <span class="r">12   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SD        503    396   12.7353    12018  11465</span>  
       13   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SD                    480    497    0.2958     7974   7967  
       14   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SA        412    411    0.0012    11467  11471  
       15   TO BT BT BT BT BT SR SR SR SA                                   383    396    0.2169    10362  10368  
     </pre>

.. class:: small

    When causes of discrepancy cannot be identified statistically

    * use common input photons + aligned random consumption between simulations 
    * enable direct photon-to-photon comparison of simulations : reveals precisely where simulations diverge

    :b:`Comparison of two independent optical simulation implementations : ideal way find issues`


:small:`Optical Simulation Comparison : Statistical OR Direct` Talk
-------------------------------------------------------------------

.. class:: normal

    Ideal 



:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_yy_frame_close.png`
----------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:130mm;" />

.. class:: small

    ``Green : start position (100k input photons)`` 

    ``Red : end position,  Cyan : other position``


:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_yy_frame_close.png` Talk
-----------------------------------------------------------

.. class:: normal

    3D pyvista view of photon points here from input photons shown in green. 
    The squares indicates the target frame.


:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_b.png`
-------------------------------------------

.. class:: small

   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   ``cd ~/j/ntds ; N=1 ./ntds.sh ana``  

.. raw:: html

    <p style="margin-bottom:150mm;" />

.. class:: small

   :b:`Geant4/U4Recorder 3D photon points transformed into target frame, viewed in 2D`
 

:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_b.png` Talk
----------------------------------------------

.. class:: normal

   This is a 2D view of the target frame, showing intersection positions on the
   PMT mask and inside the PMT. 



:i:`B_V1J008_N1_OIPF_NNVT:0:1000_gridxy.png`
----------------------------------------------


::

     export OPTICKS_INPUT_PHOTON=GridXY_X1000_Z1000_40k_f8.npy
     export OPTICKS_INPUT_PHOTON_FRAME=NNVT:0:1000

     MODE=3 EDL=1 N=0 EYE=500,0,2300 CHECK=not_first ~/j/ntds/ntds.sh ana


.. raw:: html

    <p style="margin-bottom:110mm;" />
    

::

    Photon step points from grid of input photons target NNVT:0:1000 (POM:1)


:i:`B_V1J008_N1_OIPF_NNVT:0:1000_gridxy.png` Talk
-------------------------------------------------

.. class:: normal

    This is a 3D pyvista view of photon points from a grid of input photons. 
    Looking closely you can distinguish the type of PMT 
    by the size of ring inside. 


:i:`cxr_min__eye_1,0,5__zoom_2__tmin_0.5__NNVT:0:1000_demo.jpg`
-----------------------------------------------------------------

``ray traced renders : exact same geometry "seen" by simulation``


:i:`cxr_min__eye_1,0,5__zoom_2__tmin_0.5__NNVT:0:1000_demo.jpg` Talk
--------------------------------------------------------------------

.. class:: normal

    This is a ray trace render targetting the same group of PMTs. 
    You can see the same pattern of PMTs from the ray trace and from the simulation. 



:small:`Selection of DetSim issues revealed/studied using Opticks`
--------------------------------------------------------------------

.. sidebar:: :small:`Opticks testing features`

    .. class:: small

         **Enabling detailed DetSim/G4 checks**

         * U4Recorder writing Opticks SEvt
         * history chi2 comparison
         * random aligned running : direct comparison 
         * "simtrace" : 2D sliced geometry rendering 
         * 3D raytraced + rasterized rendering  
         * commandline controlled (reproducible) rendering 
         * radial-theta-phi "RTP" frame targetting
         * input photon running, local frame targetting
         * 0-dependency PMT data access (NP.hh)
         * :r:`standalone fast cycle testing`

         Comparison of two optical sim. impl

         * :b:`powerful way to find issues with both impl.` 



.. class:: small

   **Geometry Issues**

   * PMT_20inch_body : "cylinder - torus" neck -> polycone
   * PMT_20inch_inner : 31 node tree -> 1 node
   * AdditionAcrylic : avoid pointless CSG hole subtraction
   * profligate G4IntersectionSolid "Z-cut" PMT => actually cut tree 
   * NNVT : MaskTail impinges MaskVirtual
   * HAMA : BodySolid impinges MaskTail

   **Physics issues**

   * G4Cerenkov_modified stale/undefined sin2Theta bug
   * PMTSimParamSvc::get_pmt_ce efficiency > 1. at low theta (NNVT, NNVT_HighQE)
   * solidXJfixture : ~10/64 overlaps with fasteners
   * BirksConstant1 : 1,000,000x TOO BIG
   * PMT Optical Model (fastsim based), single PMT test reveals:

     * 4-volume PMT, 2 fakes kludge-up fastsim "region" 
     * reflected+refracted polarization incorrect
     * propagation at Pyrex (not Vacuum) speed inside PMT
     * mid-vacuum reflect, refract, absorb, detect, "tunneling" 

   * Wrong velocity after reflection/refraction due to process mis-ordering 


:small:`Selection of DetSim issues revealed/studied using Opticks` Talk
-----------------------------------------------------------------------

.. class:: normal

   * when developing a new simulation, its inevitable that will need to develop lots of tools for testing
   * many of them are directly applicable to testing DetSim and Geant4 
   * as a result I found many DetSim bugs, and developed fixes for many of them 
   * biggest fix was a re-implementation of the PMT optical model
     moving from the fastsim approach to a custom boundary process approach 
 


.. comment

    .. image:: tboolean_12_raytrace.png
       :width: 550px
       :align: left

    .. image:: tboolean_12_rasterized.png
       :width: 1000px
       :align: center

    .. image:: tboolean_12_raytrace.png
       :width: 1200px
       :align: center


Crucial Importance of Standalone (fast cycle) tests
------------------------------------------------------


.. sidebar:: :small:`Standalone Advantage`

    .. class:: small

        * Full control of code 
        * Fast build 
        * Fast cycle 

        :r:`make change, see impact in seconds, not minutes`

        **Investigated Geometry Classes**
 
    .. raw:: html

       <pre class="mypretiny">
       Tub3inchPMTV3Manager.hh
       HamamatsuR12860PMTManager.hh
       NNVTMCPPMTManager.hh
       NNVTMaskManager.hh
       HamamatsuMaskManager.hh
       XJfixtureConstruction.hh
       FastenerAcrylicConstruction.hh
       SJFixtureConstruction.hh
       XJanchorConstruction.hh
       SJReceiverConstruction.hh
       SJCLSanchorConstruction.hh
       SJReceiverFasternConstruction.hh
       </pre>


.. class:: small

    **How standalone tests created:**


    * added *IGeomManager* standalone base to 12 investigated classes 

      * depends only on Geant4 (Custom4)

        * less dependencies => more useful 

      * enables testing separate from JUNOSW, eg:

        * One PMT tests of JUNO PMT Optical Model  
        * Geant4/Opticks 2D slice renders to reveal overlaps
        * Opticks 3D rendering 


    .. raw:: html

        <pre class="mypretiny">
         38 #ifdef PMTSIM_STANDALONE
         39 #include "PMTSIM_API_EXPORT.hh"
         40 class PMTSIM_API HamamatsuR12860PMTManager : public IGeomManager {
         41 #else
         42 class HamamatsuR12860PMTManager: public IPMTElement,
         43                                  public ToolBase {
         44 #endif
        </pre>

.. class:: small

    * 0-dependency PMT data access by serialize/de-serialize 
        
      * PMT data access from anywhere, including GPU 
      * NP.hh NPFold.h : save PMT data into NumPy .npy files

        * https://github.com/simoncblyth/np/


Crucial Importance of Standalone (fast cycle) tests Talk
--------------------------------------------------------

.. class:: normal

    Primary tool to find issues is standalone testing : because of the fast cycle



:i:`CSG : (Cylinder - Torus) PMT neck : spurious intersects`
---------------------------------------------------------------------------------

``CSG : (Cylinder - Torus) PMT neck : spurious intersects``

.. class:: small

    OptiX 5.5 raytrace comparing two PMT neck models:

    1. Ellipsoid + Hyperboloid + Cylinder
    2. Ellipsoid + :red:`(Cylinder - Torus)` + Cylinder 

    * poor precision of torus intersects => spurious intersects


:i:`CSG : (Cylinder - Torus) PMT neck : spurious intersects` Talk
-----------------------------------------------------------------

.. class:: normal

    One of the first fixes, was PMT neck geometry. 


:i:`body_solid_nurs`
----------------------

.. class:: small

   ``X4IntersectTest shows Geant4 also has spurious intersects from G4Torus``

:i:`body_solid_nurs` Talk
-------------------------

.. class:: normal

    That torus neck issue also effected purely Geant4 



:i:`cxr_view_solidXJfixture:55:-3_cam_1_eye_8,-4,-4_zoom_1_tmin_0.1`
---------------------------------------------------------------------

.. raw:: html

   <p style="margin-bottom:12cm;" />
 

``EYE=8,-4,-4 LOOK=0,0,0 MOI=solidXJfixture:55:-3 ./cxr_view.sh`` 
    ``view directly at the fixture, but not visible as uni_acrylic1 in front``


:i:`cxr_view_solidXJfixture:55:-3_cam_1_eye_8,-4,-4_zoom_1_tmin_0.1` Talk
-------------------------------------------------------------------------

.. class:: normal

    fixture is hidden underneath the foot  


.. comment

    :i:`cxr_view_solidXJfixture:55:-3_cam_1_eye_4,-2,-2_zoom_1_tmin_0.1`
    ---------------------------------------------------------------------

    .. raw:: html

       <p style="margin-bottom:12cm;" />
     

    ``EYE=4,-2,-2 LOOK=0,0,0 MOI=solidXJfixture:55:-3 ./cxr_view.sh`` 
        ``closer, at same angle of view``

        
    :i:`cxr_view_solidXJfixture:55:-3_cam_1_eye_2,-1,-1_zoom_1_tmin_0.1`
    ---------------------------------------------------------------------

    .. raw:: html

       <p style="margin-bottom:12cm;" />
     

    ``EYE=2,-1,-1 LOOK=0,0,0 MOI=solidXJfixture:55:-3 ./cxr_view.sh`` 
        ``even closer, at same angle of view``



:i:`cxr_view_solidXJfixture:55:-3_cam_1_eye_1,-0.5,-0.5_zoom_1_tmin_0.1`
-------------------------------------------------------------------------

``EYE=1,-0.5,-0.5 LOOK=0,0,0 MOI=solidXJfixture:55:-3 ./cxr_view.sh`` 
    ``closer again, at same angle of view : fixture now visible, coincidence speckle between spherically curved uni_acrylic1 base and sAcrylic``

:i:`cxr_view_solidXJfixture:55:-3_cam_1_eye_1,-0.5,-0.5_zoom_1_tmin_0.1` Talk
-----------------------------------------------------------------------------

.. class:: normal

   fixture is underneath the foot




:i:`image_grid_cxr_solidXJfixture:XX:-3`
-----------------------------------------

:i:`image_grid_cxr_solidXJfixture:XX:-3` Talk
---------------------------------------------

.. class:: normal

    Grid of 64 images showing all the solidXJfixture from same RTP frame viewpoint for each

    LOOK=0,0,0
        origin of the RTP frame is the center of the solidXJfixture
        obtained from its axis-aligned bounding box

    EYE=2,-1,-1 
        ^  ----- 
        |      45 degrees in tangential theta-phi directions
        | 
        2 units of extent outwards radially


    Variations in radius and clashes between solidXJfixture and uni_acrylic1 and uni1 are visible)   





:i:`FewPMT_2942_Unphysical_cross_geometry_vac_reflect.png`
------------------------------------------------------------

:i:`FewPMT_2942_Unphysical_cross_geometry_vac_reflect.png` Talk
---------------------------------------------------------------

.. class:: normal

    Tunneling and reflect in vacuum 


:i:`FewPMT_demo0.png`
----------------------

.. raw:: html

    <p style="margin-bottom:172mm;" />

.. class:: small

   Compare Unnatural/Natural N=0/1 geometry simulations by skipping N=0 Pyrex/Pyrex + Vacuum/Vacuum fake points


:i:`FewPMT_demo0.png` Talk
--------------------------

.. class:: normal

    Unnatural HAMA and NNVT geometries.






:i:`FewPMT_demo.png`
-----------------------


.. raw:: html

    <p style="margin-bottom:172mm;" />

.. class:: small

   two_pmt layout with HAMA, NNVT (Natural Geometry N=1)


:i:`FewPMT_demo.png` Talk
-------------------------

.. class:: normal

    Natural HAMA and NNVT geometries.






:small:`Compare Reflected Polarization Impls for Brewster Angle Incidence`
---------------------------------------------------------------------------

.. class:: small 

   * `opticks/src/master/sysrap/tests/sboundary_test.sh <https://bitbucket.org/simoncblyth/opticks/src/master/sysrap/tests/sboundary_test.sh>`_ : build, run, plot


.. image:: sboundary_test/figs/sboundary_test/pvcap/AOI_BREWSTER_linear_polarization_by_reflection.png
    :width: 550px

.. image:: sboundary_test/figs/sboundary_test/pvcap/AOI_BREWSTER_reflect_alt_pol.png
    :width: 550px

.. class:: small

    +---------------------------------------------------------------------+------------------------------------------------+
    | G4OpBoundaryProcess/qsim.h/sboundary.h : Only S-polarized survives  | junoPMTOpticalModel::Reflect : very different  |
    +---------------------------------------------------------------------+------------------------------------------------+

    * incident from left (-X), surface normal vertically upwards (+Z), intersection point in middle, 
    * Colored lines represent polarization directions of 128 photons before and after Reflection 
    * Reflected using ``sboundary.h`` (validated against ``G4OpBoundaryProcess``)
    * Compared with ``sboundary.h:alt_pol`` that duplicates ``junoPMTOpticalModel::Reflect``  

    Brewster (or polarizing) incident angle th1 : ``tan(th1) = n2/n1  ;  th1 + th2 = pi/2``


:small:`Compare Reflected Polarization Impls for Brewster Angle Incidence` Talk
-------------------------------------------------------------------------------

.. class:: normal

    Another bug was not polarizing on reflection.  
    The difference is very clear at the Brewster angle as illustrated here. 





:small:`G4OpBoundaryProcess : customized for JUNO PMT Optical Model (POM)`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`Custom Boundary POM`

    .. raw:: html 

       <pre class="mypretiny">
         +---------------pmt-Pyrex----------------+
         |                                        |
         |                                        |
         |                                        |
         |       +~inner~Vacuum~~~~~~~~~~~+       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       +                        +       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       +------------------------+       |
         |                                        |
         |                                        |
         |                                        |
         +----------------------------------------+
       </pre>

    .. class:: small

       ``OpSurfaceName[0] == '@'``

       * ``local_z>0`` : does MultiLayer ART calc 
       * ``!(local_z>0)`` : standard *mirror_opsurf*

.. class:: small
 
   **Custom Boundary Process : Advantages**

   * natural geometry, no fakes
   * standard Geant4 polarization, propagation, time 
   * less code, simpler code
   * simpler Geant4 step history (no fakes)
   * same geometry on GPU+CPU, easier Opticks validation  
   * half the geometry objects to model PMT (4->2)

   +----------------------+-----------------------+
   | Old FastSim POM      | 4 Solid, 4 LV, 4 PV   |
   +----------------------+-----------------------+
   | Custom Boundary POM  | 2 Solid, 2 LV, 2 PV   | 
   +----------------------+-----------------------+



   **Disadvantages**

   * maintain Custom4 C4OpBoundaryProcess  
   * updating Geant4 needs care if G4OpBoundaryProcess changed

.. raw:: html 

    <p style="margin-bottom:1cm;" />

.. class:: large

   :b:`Advantages far outweigh disadvantages`
     * :r:`JUNOSW MERGED May 25, 2023`

.. class:: normal

    https://github.com/simoncblyth/customgeant4/
 


:small:`G4OpBoundaryProcess : customized for JUNO PMT Optical Model (POM)` Talk
-------------------------------------------------------------------------------

.. class:: normal

   Square PMT for illustration purposes. 

   Using a custom boundary process provides a natural fix for the issues
   encountered when using FastSim to model a custom surface with the
   advantage that it enables use of a natural geometry with no kludging. 






:small:`Multi-Layer Thin Film (A,R,T) Calc using TMM Calc (Custom4 Package)`
------------------------------------------------------------------------------

.. sidebar:: :small:`TMM : Transfer Matrix Method`
 
   .. image:: tmm/multi-layer-stack.png
       :align: center
       :width: 400px

   .. class:: small

       **multi-layer thin films, coherent calc:**

       * complex refractives indices, thicknesses
       * => (A,R,T)  (Absorb, Reflect, Transmit)
       * Used from **C4OpBoundaryProcess**  

       :r:`header-only GPU/CPU` : **C4MultiLayrStack.h**       
    
       https://github.com/simoncblyth/customgeant4/

.. class:: small


    C4OpBoundaryProcess.hh
       G4OpBoundaryProcess with C4CustomART.h 
    
    C4CustomART.h
       integrate custom boundary process and TMM calculation

    C4MultiLayrStack.h : :b:`CPU/GPU TMM calculation of (A,R,T)` 
       based on complex refractive indices and layer thicknesses 
 
       * GPU: **using thrust::complex** CPU:**using std::complex**

    :r:`Custom4: Simplifies JUNO PMT Optical Model + Geometry` 

.. image:: GEOM/FewPMT/U4SimtraceTest/1/figs/U4SimtraceTest/mpcap/FewPMT_demo.png
   :width: 580px
   :align: left


.. comment
 
    .. image:: Custom4/Custom4_README.png
       :width: 580px
       :align: left


:small:`Multi-Layer Thin Film (A,R,T) Calc using TMM Calc (Custom4 Package)` Talk
---------------------------------------------------------------------------------

.. class:: normal

   Customizing the Geant4 boundary process allows a very natural 
   way to support calculation of thin film interference effects 
   using the transfer matrix method. That is implemented in a 
   single header that is used both on CPU and GPU.  

   This slide summarizes recent work that enables the JUNO PMT geometry 
   to be simplified and also enables the same PMT geometry to be used 
   for the Geant4 and Opticks simulations. 




:i:`LayrTest__R12860_Aspa.png`
---------------------------------

:i:`LayrTest__R12860_Aspa.png` Talk
-----------------------------------

.. class:: normal

    Aspa : This is just showing the absorption, the dotted lines are the average of the S and P polarizations




Opticks performance with GPU PMT Optical Model
------------------------------------------------

::

    TEST=large_scan ~/opticks/cxs_min.sh 
    

.. class:: small

    Generate 20 optical only (Torch) events with 0.1M->100M photons starting from CD center, 
    gather and save only Hits.

    * uses CSGOptiXSMTest executable (no Geant4 dependency)

::

    OPTICKS_RUNNING_MODE=SRM_TORCH  ## "Torch" running enables num_photon scan
    OPTICKS_NUM_PHOTON=H1:10,M2,3,5,7,10,20,40,60,80,100
    OPTICKS_NUM_EVENT=20
    OPTICKS_EVENT_MODE=Hit


.. class:: small

   * no Geant4 initialization (~150s) : load and upload geometry in ~2s 
   * BUT with MAX_PHOTON 100M, uploading curandState costs 20s


   +---------------------------------------------------------------+--------------------------------------------+ 
   |   Test Hardware                                               |  Notes                                     |
   +===============================================================+============================================+
   |  DELL Precison Workstation with NVIDIA TITAN RTX(24G)         | :b:`Primary test hardware`                 |
   +---------------------------------------------------------------+--------------------------------------------+
   |  DELL Precision Workstation with NVIDIA TITAN V(12G)          | VRAM limited                               |
   +---------------------------------------------------------------+--------------------------------------------+
   |  DELL Precision Workstation with NVIDIA Quadro RTX 8000 (48G) | TODO : push to memory limit ~400M photons  |
   +---------------------------------------------------------------+--------------------------------------------+
   |  GPU cluster nodes with NVIDIA V100 (32GB)                    | TODO: Production Config Testing, expect    |
   |                                                               | ~250M photon per launch limit              | 
   +---------------------------------------------------------------+--------------------------------------------+

 
Opticks performance with GPU PMT Optical Model Talk
---------------------------------------------------

.. class:: normal

    Using Torch gensteps allows the number of photons to be scanned



:i:`ALL1_scatter_10M_photon_22pc_hit_alt.png`
----------------------------------------------


.. raw:: html

    <p style="margin-bottom:150mm;" />
 


``~/o/cxs_min.sh  ## 2.2M hits from 10M photon TorchGenstep, 3.1 seconds``


:i:`ALL1_scatter_10M_photon_22pc_hit_alt.png` Talk
--------------------------------------------------

.. class:: normal

    2.2M hits in 3.1 seconds


:i:`ALL1_scatter_10M_photon_22pc_hit.png`
-------------------------------------------

.. comment

   PLOT=scatter MODE=3 PUB=10M_photon_22pc_hit ~/o/cxs_min.sh pvpub


:i:`ALL1_scatter_10M_photon_22pc_hit.png` Talk
----------------------------------------------

.. class:: normal

    Shadows in the distribution of hits are apparent  




.. comment

    :i:`N7_Substamp_ALL_Hit_vs_Photon__linear.png`
    ------------------------------------------------

    .. s5_talk::

       Linear relationship between photons and hits 


:i:`S7_Substamp_ALL_Hit_vs_Photon__linear.png`
------------------------------------------------


:i:`S7_Substamp_ALL_Hit_vs_Photon__linear.png` Talk
---------------------------------------------------

.. class:: normal

   Linear relationship between photons and hits, Release and Debug build results look the same  



.. comment

    :small:`Optimizing separate "Release" build in addition to "Debug" build`
    ---------------------------------------------------------------------------


    .. class:: small

       **Release** preprocessor macros : adds: **PRODUCTION** , removes: **DEBUG_TAG, DEBUG_PIDX,...**

       * remove debug array collection (eg photon step point records)
       * remove debug code from GPU kernels 
       * :r:`lots more mileage here : more can be removed from Release kernel`


       **Examine flattened kernel source CSGOptiX/CSGOptiX7.cu (103k lines) : all includes included**

       ::

           ~/opticks/preprocessor.sh > /tmp/out.cc   ## using gcc -E -C -P 

       * :b:`see what the compiler sees` 
       * enables finding inadvertent doubles + printf

       **Grepping Kernel PTX : Parallel Thread Execution ~Assembly code** 

       * :b:`examine first stage output from compilation`

       Grepping PTX for doubles and printf, and then removing from source : **opticks-ptx** bash function eg::

           grep \\.f64 $OPTICKS_PREFIX/ptx/CSGOptiX_generated_CSGOptiX7.cu.ptx

       * with OptiX 6.5 removing doubles had large performance improvements, no big effects yet with 7.5



    .. s5_talk::

        The Release build aims to minimize processing to absolute essentials only, 
        with no Debug/validation activity. There is likely significantly further slimming 
        that can be done. 




.. comment


    :i:`N7_Substamp_ALL_Etime_vs_Photon__34s_100M_debug.png`
    ---------------------------------------------------------

    .. raw:: html

        <p style="margin-bottom:80mm;" />
     

    .. class:: center

        Debug : 0.341 seconds per million photons


    .. s5_talk::

        Currently not much difference betweem the Debug and Release builds 




:i:`S7_Substamp_ALL_Etime_vs_Photon__100M_31s_Release.png`
-----------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:80mm;" />


.. class:: center

    Release : 0.314 seconds per million photons


:i:`S7_Substamp_ALL_Etime_vs_Photon__100M_31s_Release.png` Talk
---------------------------------------------------------------

.. class:: normal

    Currently Release running only something like 20% less time than Debug





:i:`scan-pf-1_Opticks_vs_Geant4 3`
------------------------------------


.. raw:: html

    <p class="mytopbox">Absolute Comparison with ancient Opticks Measurements.. ? [Below presented at CHEP 2019] 58s / 400M photons</p>
    <pre>
   


 
    </pre>


.. class:: small

    .. table:: 
        :align: center

        +--------------------+----------------------------+------------------+
        | JUNO analytic, 400M photons from center         |  Speedup         |
        +====================+============================+==================+
        | Geant4 Extrap.     | 95,600 s (26 hrs)          |                  | 
        +--------------------+----------------------------+------------------+
        | Opticks RTX ON (i) | 58 s                       |   1650x          |
        +--------------------+----------------------------+------------------+


:i:`scan-pf-1_Opticks_vs_Geant4 3` Talk
---------------------------------------

.. class:: normal

   I make a simple comparison of propagation time for nominal 400M photons
   between the ancient meaurements and the current 100M photon measurement extrapolated. 


   This compares the extrapolated Geant4 propagation time with the Opticks launch
   interval with RTX on.   The speedup is more than a factor of 1000.   Need to 
   use a log scale to make them both visible. 

   For 400M photons, Geant4 takes more than a day, Opticks takes less than a minute.   

   This is with analytic geometry. Speedup is a lot more with triangles.




:small:`Absolute Comparison with ancient Opticks Measurements ?`
--------------------------------------------------------------------------


.. class:: small

    .. table:: 
        :align: center

        +------------------------+----------------------------+------------------+----------------------------------------+
        | JUNO analytic, 400M photons from center             |  Speedup         |   Notes                                |
        +========================+============================+==================+========================================+
        | Geant4 Extrap.         | 95,600 s (26 hrs)          |                  |  Ancient (2019)                        |
        +------------------------+----------------------------+------------------+----------------------------------------+
        | Opticks RTX ON (i)     | 58 s                       |   1650x          |  Ancient (2019)                        |
        +------------------------+----------------------------+------------------+----------------------------------------+
        | :r:`JUNOSW+Opticks 1st`| :r:`124 s (~2x slower)`    |  :r:`"770x"`     |  :r:`extrapolated from 31s for 100M`   |
        +------------------------+----------------------------+------------------+----------------------------------------+ 
        

.. class:: small

   Practically everything different between these measurements : :b:`nevertheless, its natural to compare`  
 
   1. NVIDIA OptiX 6.5 -> 7.5 [entirely new API] => Opticks almost entirely re-implemented 
   2. JUNO geometry : more complex than 4 years ago(?) : despite efforts to simplify 
   3. :r:`JUNO PMT Optical Model (POM) (traditional vs "bouncy" with complex {A,R,T} TMM calculation)` 
   4. NVIDIA RTX 8000 (48G) vs NVIDIA TITAN RTX (24G)  [similar spec other than VRAM]  
   5. Geant4 setup : :b:`Geant4 is not a good candle : far too flexible`

.. sidebar:: :small:`~300 ns photon lifetime limit ?`

   .. class:: small

        * long path photons : relevant ? how expensive ?  
        * :r:`TODO : try chop tail`

        :: 
 
            OPTICKS_MAX_BOUNCE=32 ## curr.
            OPTICKS_MAX_NS=300    ## IDEA

.. class:: small

   **Expected Primary Cause of 2x slowdown** : :r:`"bouncy" POM`

   * many more photons living longer, not "mopped" up by PMTs
   * bouncing around inside PMT, visiting multiple PMTs
   * more bounces -> :r:`every bounce costing a ray trace` 
   * more divergence -> less parallelism 


:small:`Absolute Comparison with ancient Opticks Measurements ?` Talk
---------------------------------------------------------------------

.. class:: normal

   Practically everything is different between these measurements, but nevertheless its natural to compare







:i:`hit_position_wavelength_time.png`
---------------------------------------


.. raw:: html

    <p style="margin-bottom:-10mm;" />

.. class:: normal

    **Yuxiang Hu** : Gamma Event at CD center  : Comparison of JUNOSW with JUNOSW+Opticks

.. class:: normal

    Hit position, wavelength and time comparison

.. raw:: html

    <p style="margin-bottom:130mm;" />


.. class:: small

   * :b:`TODO: propagation comparison to understand ~2% hit difference`  


:i:`hit_position_wavelength_time.png` Talk
------------------------------------------

.. class:: normal

   I am glad to show some results from Yuxiang, its not just me working on Opticks. 



:i:`gamma_event_at_center.png`
---------------------------------

.. raw:: html

    <p style="margin-bottom:-10mm;" />

.. class:: normal

    **Yuxiang Hu** : Gamma Event at CD center  : Comparison of JUNOSW with JUNOSW+Opticks

.. raw:: html

    <p style="margin-bottom:-5mm;" />

.. class:: normal

    +----------------------------------------------+----------+-------------------------------------------+
    |  Overall speedup [JSW/(JSW+Opticks)]         |  ~60X    |  :b:`UN-OPTIMIZED + PRELIM`               |
    +----------------------------------------------+----------+-------------------------------------------+

.. raw:: html

    <p style="margin-bottom:130mm;" />


.. class:: small

   [Calculation: same TMM header as JUNOSW, Lookup: using uploaded "ART" texture (Megabytes)]

   * :b:`TODO: higher energies, muon, multi-muon, ...`  

:i:`gamma_event_at_center.png` Talk
-----------------------------------

.. class:: normal

    This speedup is an overall speedup by comparing standard and plus-opticks jobs. 
    Overall speedups are much smaller than optical only speedups as they account for 
    the non-parallelizable portion of the work.




:small:`Amdahls "Law" : Expected Speedup Limited by Serial Processing`
--------------------------------------------------------------------------------------------

.. sidebar:: :small:`S(n) Expected Speedup`

    .. comment

       :width: 1176px
       :height: 358px
       :width: 588px 
       :height: 179px
            
    .. image:: parallel/amdahl.png
       :width: 392px 
       :height: 112px
       :align: center


    .. class:: small

        *P* 
             parallelizable proportion
        *1-P*
             non-parallelizable portion
        *n*
             parallel speedup factor  



optical photon simulation, P ~ 99% of CPU time  

* -> potential overall speedup S(n) is 100x 
* even with parallel speedup factor >> 1000x  



**Must consider processing "big picture"**

* remove bottlenecks one by one
* re-evaluate "big picture" after each  


:small:`Amdahls "Law" : Expected Speedup Limited by Serial Processing` Talk
---------------------------------------------------------------------------

.. class:: normal

   Serial Portion of processing determines the overall 
   speedup because this goes to zero 




:i:`amdahl_p_sensitive.png`
-----------------------------

.. class:: small

    .. image:: parallel/amdahl.png
       :width: 392px 
       :height: 112px
       :align: center


:i:`amdahl_p_sensitive.png` Talk
--------------------------------

.. class:: normal

   Having a large parallel speedup of 1000x or so 
   is only actually useful to overall speedup when the 
   parallel fraction is large over 98 percent or, 
   otherwise the serial portion limits performance. 



:small:`How much parellelized speedup actually useful to overall speedup?`
---------------------------------------------------------------------------

.. class:: small

   :r:`Very dependant on the parallel fraction`

   +---------------------------------------------------------------------------------------------------------------+
   |  **Theoretical Overall Speedup for various parallel fractions and parallelized speedups**                     |
   +-------------------+-------------------------------+-----------------------------------------------------------+
   |                   |   Parallelized Speedup        |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+
   | Parallel Fraction |   100x  |   1000x   | limit   |    Notes                                                  |
   +===================+=========+===========+=========+===========================================================+
   |     95%           |   17x   |   20x     |  20x    |  Little benefit beyond ~100x parallelized speedup         |
   +-------------------+---------+-----------+---------+                                                           |
   |     96%           |   20x   |   24x     |  25x    |                                                           |
   +-------------------+---------+-----------+---------+                                                           |
   |     97%           |   25x   |   32x     |  33.3x  |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+
   |     98%           |   34x   |   48x     |  50x    |  Substantial benefit from more parallelized speedup       |
   +-------------------+---------+-----------+---------+                                                           | 
   |     99%           |   50x   |   91x     | 100x    |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+


::

    In [1]: run ~/opticks/ana/amdahl.py

    In [2]: Amdahl.Overall_Speedup(np.array([100,1000,np.inf]),0.95)
    Out[2]: array([16.807, 19.627, 20.   ])

    In [3]: Amdahl.Overall_Speedup(np.array([100,1000,np.inf]),0.99)
    Out[3]: array([ 50.251,  90.992, 100.   ])


:small:`How much parellelized speedup actually useful to overall speedup?` Talk
-------------------------------------------------------------------------------

.. class:: normal

    This is the same information numerically 


:small:`Summary`
------------------

.. sidebar:: :small:`Extra Benefits of Adopting Opticks`

   .. class:: small

      * high performance novel visualization
      * detailed photon instrumentation, validation 
      * comparisons find issues with both simulations:
       
        * complex geometry, overlaps, bugs... 

      :r:`=> using Opticks improves CPU simulation too !!`

.. raw:: html

     <p style="margin-bottom:5mm;" />

..

  *Opticks* : state-of-the-art GPU ray traced optical simulation integrated with *Geant4*
  with automated geometry translation for use with NVIDIA OptiX 7+ API.   

.. raw:: html

     <p style="margin-bottom:15mm;" />

.. class:: normal

  * NVIDIA Ray Trace Performance continues rapid progress (2x each generation) 
  * **any simulation limited by optical photons can benefit from Opticks**
  * more photon limited -> more overall speedup (99% -> 100x)

:small:`Summary` Talk
---------------------

.. class:: normal

    Opticks brings state-of-the-art GPU ray tracing performance to optical photon 
    simulations. 

    The detailed validations needed when adopting a new simulation has a 
    hidden benefit in that detailed comparisons reveal problems with both 
    simulations. Adopting Opticks means you will 
    improve your CPU simulation whilst also giving you a GPU simulation.  
 


Links
-------

.. table::
    :align: center

    +--------------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks        | day-to-day code repository              |                   
    +--------------------------------------------------+-----------------------------------------+
    | https://github.com/simoncblyth/opticks           | month-to-month code repository          |
    +--------------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io                 | presentations and videos                |
    | https://simoncblyth.github.io                    |                                         | 
    | https://juno.ihep.ac.cn/~blyth                   |                                         | 
    +--------------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                      | forum/mailing list archive              |
    +--------------------------------------------------+-----------------------------------------+
    | email: ``opticks+subscribe@groups.io``           | subscribe to mailing list               |
    +--------------------------------------------------+-----------------------------------------+ 
    | ``simon.c.blyth@gmail.com``                      | any questions                           |   
    +--------------------------------------------------+-----------------------------------------+ 


:small:`Summary` Talk
---------------------

.. class:: normal

    Links to get you started with using Opticks are listed here.
    


:small:`Acknowledgements : G4 Collab. + DM Search Community + NVIDIA`
------------------------------------------------------------------------------------

.. sidebar:: :small:`Acknowledgements`

   .. class:: small

       **LBNL + LZ + NVIDIA** : 2021 
           7 NVIDIA engineer meetings on OptiX 7 API

       **Manchester U. + LHCb-RICH + NVIDIA** : 2022 
           UK GPU Hackathon : optimization guidance

       **IHEP+NTU/JUNO+Dayabay**
           Many years supporting my work on Opticks 

       **Special Mentions**

       Dr Hans Wentzel, Fermilab, Geant4 group
           Many years of assistance with testing Opticks 

       Dr Tao Lin, IHEP
           Expert help on JUNOSW + practicalities 

       Yuxiang Hu, IHEP 
           Help on Opticks+JUNOSW testing 

           




.. class:: small

    +---------------------------------------------------------------------------------------------------------------------------------------+
    |  :r:`Developing Opticks would not have been possible without longterm support and assistance from many organizations and individuals` |
    +---------------------------------------------------------------------------------------------------------------------------------------+

    +-------------------------------------------------------------------------------------------+
    | :b:`ALSO : Assistance of many with promoting Opticks to a wide audience are acknowledged` |
    +-------------------------------------------------------------------------------------------+


    **Geant4 11.0+ (Dec 2021) : Opticks Advanced Example** 

    * **CaTS : Calorimeter+Tracker Sim. LArTPC (DUNE)**
    * :r:`Hans Wentzel, Fermilab Geant4 Group`
    * *...demonstrates how to use Opticks for the creation and propagation of optical photons...*
    * https://geant4.web.cern.ch/download/release-notes/notes-v11.0.0.html


    **Dark Matter Search Community (XENON,LZ,DARWIN,..)** 

    Dark-matter And Neutrino Computation Explored (DANCE) 

    * Input to Snowmass 2021
    * https://arxiv.org/pdf/2203.08338.pdf
    * *...Opticks package may provide a solution to the tracking of optical photons...*

:small:`Acknowledgements : G4 Collab. + DM Search Community + NVIDIA` Talk
--------------------------------------------------------------------------

.. class:: normal

    The Fermilab Geant4 Group was an early adopter of Opticks and has assisted by 
    developing a Geant4 advanced example demonstrating Opticks which 
    has been in the Geant4 distribution since 2021. 

    A group of experiments from the Dark Matter search community 
    made a significant contribution to Opticks development by organizing 
    a series of meetings with NVIDIA engineers that were very useful to 
    guide a re-implementation of Opticks to work with a completely new OptiX API. 
   

.. comment

    https://gitlab.cern.ch/geant4/geant4/-/tree/master/examples/advanced/CaTS 




Innovation Lessons Learned
----------------------------

.. class:: small 
      
    * development is always iterative 

      * leaping to solutions does not happen
      * aim to stay headed in right general direction 

    * development progresses issue-by-issue

      * most time is spent fixing issues 
      * software works only after someone has fixed the issues for you

    * development skills and domain knowledge continually improve with experience 

      * starting fresh, although painful, often quicker and easier than working with old code 
      * pragmatic reality : have to do both, develop new and work with old 
      * 2nd/3rd/.. implementations much simpler and better than the 0th  

    * when learning, best to not be constrained by existing code

      * learn in unconstrained standalone tests 
      * but develop API usable from existing code 
      * develop from many standalone examples, that become tests 


Innovation Lessons Learned Talk
-------------------------------

.. class:: normal

    Innovation Lessons Learned


Three Laws of Good Software Design + Development
---------------------------------------------------

.. sidebar:: :small:`KEY : Units + Unit testing`

    .. class:: small

        Complex problems : Many simple units 

        * each unit with test ready to run 
        * dive into code in seconds 

        Tame complexity : :r:`Divide and Conquer`


.. raw:: html

    <p style="margin-bottom:15mm;" />

.. class:: small 

   +--------------------------------------------------------------+
   |                                                              |
   |  1. **Arrange fast development cycle** : :b:`TOP PRIORITY`   | 
   |                                                              |
   |  * seconds to make change and see outcome, not minutes       |  
   |  * <1s cycletime : no waiting, :r:`focussed development`     | 
   |  * cheap cycles => great code                                |
   |                                                              |
   |  .. raw:: html                                               |
   |                                                              |
   |       <p style="margin-bottom:5mm;" />                       |
   +--------------------------------------------------------------+
   |                                                              |
   |  2. **Always minimize dependencies**                         |
   |                                                              |
   |  * just good design : code more useful                       |
   |  * organize code by dependency, NOT TOPIC                    |
   |  * dependency is fundamental, topic just opinion             |
   |  * use serialization to cut dependencies                     |
   |                                                              |
   |  .. raw:: html                                               |
   |                                                              |
   |       <p style="margin-bottom:5mm;" />                       |
   +--------------------------------------------------------------+
   |                                                              |
   |  3. **Unit tests are your most powerful tool**               |
   |                                                              |
   |  * not just for testing, also for development+documenting    |
   |  * use serialization + mocking to simplify tests             |   
   |                                                              |
   |  .. raw:: html                                               |
   |                                                              |
   |       <p style="margin-bottom:5mm;" />                       |
   +--------------------------------------------------------------+


   https://simoncblyth.bitbucket.io/env/presentation/standalone_20230930_cpp_test_debug_ana_with_numpy.html 

Three Laws of Good Software Design + Development Talk
-----------------------------------------------------

.. class:: normal

    Three laws

:huge:`Extras Follow`
------------------------

* NVIDIA Ada : 3rd Generation RTX
* Hardware accelerated Ray tracing (RT Cores) in the Data Center
* US restricts export of highest performing GPUs 

:huge:`Extras Follow` Talk
--------------------------

.. class:: normal

   Extras


:small:`NVIDIA Ada : 3rd Generation RTX`
--------------------------------------------------------------------------

.. class:: small

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 4090 (2022)** 

     * 16,384 CUDA Cores, 24GB VRAM, USD 1599

   * :r:`Continued large ray tracing improvements:` 

     * **Ada** ~2x ray trace over **Ampere** (2020), 4x with DLSS 3
     * **Ampere** ~2x ray trace over **Turing** (2018)  
    
   * DLSS : Deep Learning Super Sampling 

     * AI upsampling, not applicable to optical simulation



:small:`NVIDIA Ada : 3rd Generation RTX` Talk
---------------------------------------------

.. class:: normal

    NVIDIA GPU Ray Tracing performance has continued to improve rapidly.
    With a rough doubling in ray tracing performance
    with each generation of NVIDIA RTX GPUs and we are now at the 3rd generation. 

    [Notes to Presenter]
    [<20s slide : No need to read the slide, just say the above comment]    


:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center`
-------------------------------------------------------------------------

.. sidebar:: :small:`Data Center GPUs with RT Cores`

    .. class:: small

        * :b:`An Established part of NVIDIA Lineup`

        +--------------+------------------+-----------------+  
        |              |    NVIDIA L40    | NVIDIA L4       |   
        +==============+==================+=================+
        |  Release     |   2022/10        |  2023/03        |   
        +--------------+------------------+-----------------+  
        |  GPU Arch    |   Ada Lovelace   |  Ada Lovelace   |        
        +--------------+------------------+-----------------+  
        |  VRAM        |   48 GB gddr6    | 24 GB gddr6     |   
        +--------------+------------------+-----------------+  
        |  TDP         |    300W          |  :r:`72W`       |   
        +--------------+------------------+-----------------+  
        |  Form factor |    dual slot     |  :r:`1-slot`    |   
        +--------------+------------------+-----------------+  
        | CUDA Core    |    18,176        |   7,680         |    
        +--------------+------------------+-----------------+  
        | :b:`RT Core` |:b:`142 (3rd gen)`|:b:`60 (3rd gen)`|    
        +--------------+------------------+-----------------+  
        | Tensor Core  |    568 (4th gen) |   240 (4th gen) |    
        +--------------+------------------+-----------------+  
        |  FP32        |    90.5 TFLOPS   |  30 TFLOPS      |   
        +--------------+------------------+-----------------+  
        |  FP16(*)     |    181 TFLOPS    |  121 TFLOPS     |   
        +--------------+------------------+-----------------+  
        | Predecessor  |    A40           |    T4           |   
        +--------------+------------------+-----------------+  

        (*) x2 with Sparsity 


.. class:: small


    **NVIDIA L4 Tensor Core GPU (Released 2023/03)**

    * Ada Lovelace GPU architecture
    * :r:`universal accelerator for graphics and AI workloads` 
    * :b:`small form-factor, easy to integrate, power efficient` 
    * PCIe Gen4 x16 slot without extra power
    * Google Cloud adopted for G2 VMs, successor to **NVIDIA T4**
    * **NVIDIA L4 likely to become a very popular GPU**

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    `NVIDIA L4 Tensor Core GPU (Data Center, low profile+power)`

:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center` Talk
----------------------------------------------------------------------------

.. class:: normal

    Hardware Accelerated Ray Tracing is becoming much more commonly available, 
    with NVIDIA offering a range of data center GPUs with RT cores. 

    [Notes: <20s slide, just mention above comments]

.. comment

    The current boom in interest in AI is only going to increase this trend. 





:small:`US restricts export of highest performing GPUs`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`Performance Density Threshold`

    .. raw:: html

         <pre class="mypretiny">
       +----------------------------------------------------+
         | total proc. performance (TFLOPs)                   |
         | ------------------------------ < 5.92 TFLOPs mm^-2 |
         | applicable die area (mm^2)                         |
         +----------------------------------------------------+

         ([0],[1] for full rule details )
         </pre>


.. sidebar:: :small:`China+HK : ~22% NVIDIA revenue (2023 Q3)`

    .. class:: small

         :r:`=> Bound to provide GPUs just below threshold`  

.. class:: small

     [0] *GPUs above performance threshold require export permits*


.. raw:: html

     <p style="margin-bottom:2cm;" />

.. class:: small

     [1] **Federal Register on 10/25/2023 : restriction details**

     * based on a "performance density" definition 

.. raw:: html

     <p style="margin-bottom:2cm;" />

.. class:: small

     [2] **NVIDIA filing to US Securities and Exchange Commission** 

     *...additional licensing requirements for exports to China...*

     *...(including but not limited to the A100, A800, H100, H800, L40, L40S, and RTX 4090)* 

.. raw:: html

     <p style="margin-bottom:2cm;" />


.. class:: tiny

     [0] https://www.theregister.com/2023/10/19/china_biden_ai/

     [1] https://public-inspection.federalregister.gov/2023-23055.pdf

     [2] https://www.sec.gov/ix?doc=/Archives/edgar/data/1045810/000104581023000217/nvda-20231017.htm


:small:`US restricts export of highest performing GPUs` Talk
------------------------------------------------------------

.. class:: normal

    China is something like 20-25% of the world market for GPUs, 
    so NVIDIA has no choice : it is bound to introduce
    GPUs with specs just underneath threshold. 




