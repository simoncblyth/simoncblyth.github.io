.. meta::
   :title: Opticks CEPC Workshop 
   :description: (2023 Octobe) JUNO, OptiX, Opticks
   :note0: 30 min 
   :url0: https://indico.ihep.ac.cn/event/19316/sessions/12209/#20231027

.. include:: my_s5defs.txt

.. comment 
  
    Things to add

    * expts with optical photon limitations, interested in Opticks 
    * Opticks Geant4 example
    * Opticks for CEPC

    Possible things to add

    * describe raytrace rendering 
    * describe validation techniques : aligned, statistical comparison  

.. comment

    Opticks : GPU Optical Photon Simulation using NVIDIA OptiX 7 and NVIDIA CUDA

    Opticks is an open source project that accelerates optical photon simulation by
    integrating NVIDIA GPU ray tracing, accessed via the NVIDIA OptiX 7 API, with
    Geant4 toolkit based simulations. A single NVIDIA Turing architecture GPU has
    been measured to provide optical photon simulation speedup factors exceeding
    1500 times single threaded Geant4 with a full JUNO analytic GPU geometry
    automatically translated from the Geant4 geometry. Optical physics processes of
    scattering, absorption, scintillator reemission and boundary processes are
    implemented in CUDA based on Geant4.  Wavelength-dependent material and surface
    properties as well as inverse cumulative distribution functions for reemission
    are interleaved into GPU textures providing fast interpolated property lookup
    or wavelength generation.

    In this work we describe the near complete re-implementation of geometry and
    optical simulation required to adopt the entirely new NVIDIA OptiX 7 API, with
    the implementation now directly CUDA based with OptiX usage restricted to
    providing intersects.  The new Opticks features a modular many small header
    design that provides fine grained testing both on GPU and CPU as well as
    substantial code reductions from CPU/GPU sharing.  Enhanced modularity has
    enabled CSG tree generalization to support "list-nodes", similar to
    G4MultiUnion, that improve performance for complex CSG solids.  Recent addition
    of support for interference effects in boundaries with multiple thin layers,
    such as anti-reflection coatings and photocathodes, using CUDA compatible
    transfer matrix method (TMM) calculations of reflectance, transmittance and
    absorptance is also reported.


    * complete re-implementation of geometry 
    * complete re-implementation of optical simulation
    * CSG tree generalizations to support "list-nodes" to improve handling of complex CSG solids
    * multi-thin-layer TMM 

    * list of packages (?)


.. comment

    <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA® OptiX™ 7, NVIDIA® CUDA™

    The 2023 International Workshop on the High Energy Circular Electron Positron Collider


:i:`Opticks : GPU Optical Photon Simulation via NVIDIA OptiX 7 and NVIDIA CUDA` 
========================================================================================

.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey;text-align:center;"> 
        <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA OptiX
        <h2 style="background-color:lightgrey;text-align:center">
            Open source, https://bitbucket.org/simoncblyth/opticks 
        </h2>
    </h1>
    </header>
    </div>
    <!--img style="position:absolute; top:200px; LEFT:100px; WIDTH:200px; " src="juno/JUNO_logo.png"  /-->
    <div class="mycredit">
       <h2 style="background-color:lightgrey">
          Simon C Blyth, IHEP, CAS &mdash; CEPC Workshop &mdash; Offline and Software session &mdash; Nanjing, 27 October 2023
       </h2>
    </div>

.. s5_talk:: 


    Opticks is an open source project that applies GPU ray tracing to optical photon simulation 
    and integrates this with Geant4. This can give drastic speedups of more than a factor of 1000.
    This approach removes memory and processing bottlenecks that can prevent the 
    optical photons from limiting simulations.  

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.



Outline
---------

.. image:: newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right

.. class:: small

    .. raw:: html

       <span>&nbsp;</span>

    * Optical Photon Simulation : Context and Problem

      * Optical Photon Simulation Problem...
      * Optical Photon Simulation ≈ Ray Traced Image Rendering

    * NVIDIA Tools to create Solution   

      * NVIDIA Ada Lovelave : 3rd Generation RTX, RT Cores in Data-Center
      * NVIDIA OptiX Ray Tracing Engine
      * NVIDIA OptiX 7 : Entirely new thin API, BVH Acceleration Structure

    * Opticks : Introduction + Full Re-implementation

      * Geant4 + Opticks Hybrid Workflow : External Optical Photon Simulation
      * Full re-implementation for NVIDIA OptiX 7 API
      * *CSGFoundry* Geometry Model, Translation to GPU 
      * Ray trace render performance scanning 
      * n-Ary CSG "List-Nodes"
      * QUDARap : CUDA Optical Simulation Implementation
      * Validation 

    * Opticks : New Features 

      * Multi-Layer Thin Film (A,R,T) Calc using TMM (Custom4 Package)

    * Summary + Links 

.. raw:: html

   <hr/>


.. s5_talk::
    
    This aim of this talk is to explain how GPU ray tracing is integrated 
    with Geant4 



.. comment

    :i:`JUNO_Intro_2`
    ------------------

    .. s5_talk::

        I guess JUNO needs no introduction here. 

        One thing to note however is the scale : JUNO will soon become the worlds 
        largest liquid scintillator detector with a 35m diameter sphere of scintillator. 

    .. comment 

        JUNO will soon start data taking, it will be the worlds largest liquid scintillator detector,
        with a 20 kiloton spherical volume of scintillator instrumented with  
        almost 50 thousand PMTs. The diameter of the sphere is 35 meters. 


`JUNO Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <p style="margin-bottom:7cm;" />

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


.. s5_talk::

   A muon travelling across the JUNO scintillator yields tens of millions 
   of optical photons, presenting memory and time challenges. 

   Most of the time is taken finding intersections between photons and geometry 
   Simulation is not alone in this bottleneck.


.. comment

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation and we
   are interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 


:small:`Optical photons limit many simulations => lots of interest in Opticks`
--------------------------------------------------------------------------------

.. class:: small

    +-----------+-----------------------------------------------------------------------------+
    | **EXPT**  | **Reactor neutrino**                                                        |  
    +-----------+-----------------------------------------------------------------------------+
    | Daya Bay  | neutrino oscillations                                                       |
    +-----------+-----------------------------------------------------------------------------+
    | JUNO      | mass heirarchy + oscillations  => :r:`NVIDIA CN Contacts`                   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Long baseline neutrino beam**                                             |
    +-----------+-----------------------------------------------------------------------------+
    | DUNE      | FermiLab->Sanford, LAr TPC, => Assistance from :b:`Fermilab Geant4 Group`   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrinoless double beta decay, dark matter, other search**               |
    +-----------+-----------------------------------------------------------------------------+
    | LZ        | LUX-ZEPLIN dark matter experiment, Sandford  => :r:`NVIDIA US Contacts`     |
    +-----------+-----------------------------------------------------------------------------+
    | LEGEND    | Large Enriched Germanium Experiment, Gran Sasso/SNOLAB                      |
    +-----------+-----------------------------------------------------------------------------+
    | SABRE     | dark matter direct-detection, Australia                                     |
    +-----------+-----------------------------------------------------------------------------+
    | AMoRE     | Mo-based Rare process Experiment, S.Korea                                   |
    +-----------+-----------------------------------------------------------------------------+
    | nEXO      | next Enriched Xenon Observatory, LLNL                                       |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrino telescope**                                                      |
    +-----------+-----------------------------------------------------------------------------+
    | KM3Net    | Cubic Kilometre Neutrino Telescope, Mediterranean                           |
    +-----------+-----------------------------------------------------------------------------+
    | IceCube   | IceCube Neutrino Observatory, South Pole                                    |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Air shower : gamma-ray and cosmic-ray observatory**                       |
    +-----------+-----------------------------------------------------------------------------+
    | LHAASO    | Large High Altitude Air Shower Observatory, Sichuan                         |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Accelerator**                                                             |
    +-----------+-----------------------------------------------------------------------------+
    | LHCb-RICH | LHCb ring imaging Cherenkov sub-detector, CERN => :r:`NVIDIA EU Contacts`   |
    +-----------+-----------------------------------------------------------------------------+



.. s5_talk::

    Its not only JUNO that has an optical photon simulation
    problem. People from all these experiments are interested
    to use Opticks.
    Some groups  developments assisted Opticks development 
    by arranging contacts with NVIDIA 
   


:small:`Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA`
------------------------------------------------------------------------------------

.. sidebar:: :small:`Assistance from NVIDIA engineers`

   .. class:: small

       :b:`Organized by interested experiments`

       **LBNL + LZ** : 2021 

       7 meeting series
         OptiX 7 API migration

       **Univ. Manchester + LHCb-RICH** : 2022 

       UK GPU Hackathon
         optimization guidance


.. class:: small

    **Geant4 11.0+ (Dec 2021) : Opticks Advanced Example** 

    * **CaTS : Calorimeter and Tracker Simulation**

      * for Liquid Argon TPC, eg DUNE

    * :r:`Hans Wentzel, Fermilab Geant4 Group`
    * *...demonstrates how to use Opticks for the creation and propagation of optical photons...*
    * https://geant4.web.cern.ch/download/release-notes/notes-v11.0.0.html


    **Dark Matter Search Community (XENON,LZ,DARWIN,..)** 

    Dark-matter And Neutrino Computation Explored (DANCE) 

    * Input to Snowmass 2021
    * https://arxiv.org/pdf/2203.08338.pdf
    * *...Opticks package may provide a solution to the tracking of optical photons...*


.. s5_talk::

    The Fermilab Geant4 Group was an early adopter of Opticks and has assisted by 
    developing a Geant4 advanced example demonstrating Opticks which 
    has been in the Geant4 distribution since 2021. 

    A group of experiments from the Dark Matter search community 
    made a significant contribution to Opticks development by organizing 
    a series of meetings with NVIDIA engineers that were very useful to 
    guide a re-implementation of Opticks to work with a completely new OptiX API. 
   

.. comment

    https://gitlab.cern.ch/geant4/geant4/-/tree/master/examples/advanced/CaTS 

:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: :small:`Not a Photo, a Calculation`

    .. image:: ../optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    :b:`simulation` 
       photon parameters at sensors (PMTs) 

    :b:`rendering` 
       pixel values at image plane


.. raw:: html

    <p style="margin-bottom:2cm;" />


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :redbold:`both limited by ray geometry intersection, aka ray tracing`

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


.. s5_talk::

    So how can GPU ray tracing help with simulation. 

    Actually, there is a lot in common between optical photon simulation and ray traced image rendering.   
    Simulation needs photon parameters at sensors, rendering needs pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is widely used across many industries from advertising to games, so 
    there has been huge efforts to improve ray tracing perfromance, especially from NVIDIA. 
    


:i:`SIGGRAPH_2018_Announcing_Worlds_First_Ray_Tracing_GPU`
------------------------------------------------------------

.. raw:: html 

    <pre>







    </pre>


.. class:: huge 

    .. table:: 
       :align: right

     
       +----------------------------+
       |  :white:`10 Giga Rays/s`   |
       +----------------------------+


.. s5_talk::

    In 2018 NVIDIA introduced a GPU with hardware dedicated to accelerating ray tracing.
    NVIDIA claims it can reach 10 billion ray geometry intersections per second
    with a single GPU. 

    Assuming each simulated photon costs 10 rays, that means the upper limit per GPU is 
    1 billion photons/second.





:small:`NVIDIA Ada : 3rd Generation RTX`
--------------------------------------------------------------------------

.. class:: small

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 4090 (2022)** 

     * 16,384 CUDA Cores, 24GB VRAM, USD 1599

   * :r:`Continued large ray tracing improvements:` 

     * **Ada** ~2x ray trace over **Ampere** (2020), 4x with DLSS 3
     * **Ampere** ~2x ray trace over **Turing** (2018)  
    
   * DLSS : Deep Learning Super Sampling 

     * AI upsampling, not applicable to optical simulation



.. s5_talk::

    NVIDIA GPU Ray Tracing performance has continued to improve rapidly.
    With a rough doubling in ray tracing performance
    with each generation of NVIDIA RTX GPUs and we are now at the 3rd generation. 

    [Notes to Presenter]
    [<20s slide : No need to read the slide, just say the above comment]    


:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center`
-------------------------------------------------------------------------

.. sidebar:: :small:`Data Center GPUs with RT Cores`

    .. class:: small

        * :b:`An Established part of NVIDIA Lineup`

        +--------------+------------------+-----------------+  
        |              |    NVIDIA L40    | NVIDIA L4       |   
        +==============+==================+=================+
        |  Release     |   2022/10        |  2023/03        |   
        +--------------+------------------+-----------------+  
        |  GPU Arch    |   Ada Lovelace   |  Ada Lovelace   |        
        +--------------+------------------+-----------------+  
        |  VRAM        |   48 GB gddr6    | 24 GB gddr6     |   
        +--------------+------------------+-----------------+  
        |  TDP         |    300W          |  :r:`72W`       |   
        +--------------+------------------+-----------------+  
        |  Form factor |    dual slot     |  :r:`1-slot`    |   
        +--------------+------------------+-----------------+  
        | CUDA Core    |    18,176        |   7,680         |    
        +--------------+------------------+-----------------+  
        | :b:`RT Core` |:b:`142 (3rd gen)`|:b:`60 (3rd gen)`|    
        +--------------+------------------+-----------------+  
        | Tensor Core  |    568 (4th gen) |   240 (4th gen) |    
        +--------------+------------------+-----------------+  
        |  FP32        |    90.5 TFLOPS   |  30 TFLOPS      |   
        +--------------+------------------+-----------------+  
        |  FP16(*)     |    181 TFLOPS    |  121 TFLOPS     |   
        +--------------+------------------+-----------------+  
        | Predecessor  |    A40           |    T4           |   
        +--------------+------------------+-----------------+  

        (*) x2 with Sparsity 


.. class:: small


    **NVIDIA L4 Tensor Core GPU (Released 2023/03)**

    * Ada Lovelace GPU architecture
    * :r:`universal accelerator for graphics and AI workloads` 
    * :b:`small form-factor, easy to integrate, power efficient` 
    * PCIe Gen4 x16 slot without extra power
    * Google Cloud adopted for G2 VMs, successor to **NVIDIA T4**
    * **NVIDIA L4 likely to become a very popular GPU**

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    `NVIDIA L4 Tensor Core GPU (Data Center, low profile+power)`

.. s5_talk::

    Hardware Accelerated Ray Tracing is becoming much more commonly available, 
    with NVIDIA offering a range of data center GPUs with RT cores. 

    [Notes: <20s slide, just mention above comments]

.. comment

    The current boom in interest in AI is only going to increase this trend. 


:small:`(From Nov 17, 2023) : US will restrict export of highest performing GPUs`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`Performance Density Threshold`

    .. raw:: html

         <pre class="mypretiny">
         +----------------------------------------------------+
         | total proc. performance (TFLOPs)                   |
         | ------------------------------ < 5.92 TFLOPs mm^-2 |
         | applicable die area (mm^2)                         |
         +----------------------------------------------------+

         ([0],[1] for full rule details )
         </pre>


.. sidebar:: :small:`NVIDIA, AMD, Intel`

    .. class:: small

         :b:`will likely introduce China targetted GPUs just under threshold`


.. class:: small

     [0] *GPUs with performance above threshold require export permits*


.. raw:: html

     <p style="margin-bottom:2cm;" />

.. class:: small

     [1] **Federal Register on 10/25/2023 : restriction details**

     * based on a "performance density" definition 

.. raw:: html

     <p style="margin-bottom:2cm;" />

.. class:: small

     [2] **NVIDIA filing to US Securities and Exchange Commission** 

     *...additional licensing requirements for exports to China...*

     *...(including but not limited to the A100, A800, H100, H800, L40, L40S, and RTX 4090)* 

.. raw:: html

     <p style="margin-bottom:2cm;" />


.. class:: tiny

     [0] https://www.theregister.com/2023/10/19/china_biden_ai/

     [1] https://public-inspection.federalregister.gov/2023-23055.pdf

     [2] https://www.sec.gov/ix?doc=/Archives/edgar/data/1045810/000104581023000217/nvda-20231017.htm


.. s5_talk::

    China is something like 25% of the world market for GPUs, 
    so I think its almost a certainty that NVIDIA with introduce
    GPUs with specs just underneath the threshold. 



:i:`OptiX Title Banner`
------------------------

.. raw:: html

     <p style="margin-bottom:165mm;" />

.. class:: huge

    https://developer.nvidia.com/rtx/ray-tracing/optix

.. s5_talk::

    Most NVIDIA OptiX users are involved with realistic image rendering. 
    Fortunately OptiX exposes an intersection API which makes
    it applicable to simulation. So all the effort NVIDIA has expended 
    in accelrating ray tracing becomes directly applicable to simulation. 


:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing`
--------------------------------------------------------------------------

.. sidebar:: :small:`Flexible Ray Tracing Pipeline` 

    .. class:: small

        :g:`Green: User Programs`,  :e:`Grey: Fixed function/HW`

    .. image:: nvidia/optix7/OptiX-API.png
       :width: 450px
       :align: right

    .. class:: small

        :b:`Analogous to OpenGL rasterization pipeline` 


.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * :r:`Programmable GPU-accelerated Ray-Tracing Pipeline`
   * Single-ray shader programming model using CUDA
   * ray tracing acceleration using RT Cores (RTX GPUs)
   * "...free to use within any application..."

   **OptiX features**

   * acceleration structure creation + traversal (eg BVH)
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

   ``https://developer.nvidia.com/rtx/ray-tracing/optix``

.. class:: small

   **User provides (Green):**

   * ray generation
   * geometry bounding boxes
   * intersect functions 
   * instance transforms

   

.. s5_talk::

   NVIDIA OptiX makes GPU ray tracing accessible 

   * it divides up the ray tracing workflow 
   * the green boxes represent user provided CUDA programs, including:

     * ray generation : where Opticks generates photons and steers the simulation
     * intersection : where the CSG geometry is implemented 

   * geometry has to be translated into a GPU appropriate easily serialized form





``Spatial Index Acceleration Structure``
---------------------------------------------------

.. raw:: html

    <p style="margin-bottom:11cm;" />

.. sidebar:: :small:`Tree of Bounding Boxes (bbox)`

    .. class:: small

        * aims to minimize bbox+primitive intersects 
        * accelerates ray-geometry intersection


.. s5_talk::

   The principal technique to accelerate ray geometry intersection 
   is an acceleration structure called a bounding volume hierarchy 
   
   This divides space into progressively smaller boxes which forms
   a spatial index.

   Traversing the tree of bounds allows to minimize tests
   needed to find an intersect.

   Much of the acceleration structure traversal 
   is done in the dedicated RT cores.






:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`GPU Ray Tracing APIs Converged`

    .. class:: small

        * 3 APIs (DXR,VKRay,OptiX7) over RTX 
        * Driver updates :r:`independent of application`  
        * Support new GPUs, performance improvements 

.. class:: small

    **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

    * low-level CUDA-centric thin API (Vulkan-ized)
    * headers only (no library, impl in Driver) 
    * Minimal host state,  :red:`All host functions are thread-safe`
    * GPU launches : explicit, asynchronous (CUDA streams)
    * :strike:`near perfect scaling to 4 GPUs, for free` 
    * :strike:`Shared CPU/GPU geometry context`
    * :strike:`GPU memory management`
    * :strike:`Multi-GPU support`


.. class:: small

    **Advantages of 6->7 transition**

    * More control/flexibility over everything 
    * :b:`Keep pace with state-of-the-art GPU ray tracing` 
    * Fully benefit from current + future GPUs : RT cores, RTX 

.. class:: small

    **BUT:** :r:`demanded full re-implementation of Opticks` 
     


.. s5_talk::

   * OptiX 7 is an entirely new API, dropping many features used by the old Opticks
   * re-implementation of almost all of Opticks was necessary

   [Notes: No need to read slide, just the above comments]



Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow
-------------------------------------------------------------

.. class:: small

    .. table::
        :align: center

        +--------------------------------------------------+
        | :b:`https://bitbucket.org/simoncblyth/opticks`   |
        +--------------------------------------------------+


.. raw:: html

    <p style="margin-bottom:13cm;" />

.. class:: small

    Opticks API : split according to dependency -- Optical photons are GPU "resident", only hits need to be copied to CPU memory 


.. s5_talk::

    This shows how Opticks is integrated with Geant4. The geometry is translated 
    and uploaded to the GPU at initialization.

    Cerenkov or Scintillation gensteps, the blue lines, are the generation parameters 
    uploaded to the GPU so optical photon generation can be done there.

    This allows the optical photon simulation to be entirely offloaded  
    to the GPU with only collected hits requiring memory on the CPU.
 

Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2
--------------------------------------------------------

.. sidebar:: :small:`Offload Optical Simulation to GPU`

   .. class:: small

      * :r:`translate Geant4 geometry to OptiX GPU`  

        * intersect functions
        * instance transforms
        * GPU textures for mat/surf properties

      * CUDA port of Geant4 generation+propagation

        * cuRAND random number generation
        * may small QUDARap headers implement optical simulation 


.. s5_talk::

    In general, I found that directly porting the optical physics has been straightforward.
    Most of problems and effort of Opticks been with the geometry, because the 
    geometry model needs to be very different from the deep tree of volumes of Geant4.




:small:`How to Make Effective Use of GPUs ? Parallel / Simple / Uncoupled`
------------------------------------------------------------------------------

.. sidebar:: :small:`Optical Photon Simulation`

    .. class:: small

        Abundant parallelism 
           * Many millions of photons 

        Low register usage 
           * Simple optical physics, texture lookups

        Little/No synchronization
           * Independent photons -> None 

        Minimize CPU<->GPU copies 
           * geometry copied at initialization
           * gensteps copied once per event
           * only hits copied back    

        :blue:`~perfect match for GPU acceleration` 



.. class:: small

    **Abundant parallelism**
       * many thousands of tasks (ideally millions)

    **Low register usage : otherwise limits concurrent threads** 
       * simple kernels, avoid branching  

    **Little/No Synchronization**
       * avoid waiting, avoid complex code/debugging

    **Minimize CPU<->GPU copies**
       * reuse GPU buffers across multiple CUDA launches 

    .. image:: /env/presentation/1px.png


    **How Many Threads to Launch ?**

    * can (and should) launch many millions of threads

      * :red:`mince problems as finely as feasible`

    * maximum thread launch size : so large its irrelevant
    * maximum threads inflight : #SM*2048 = 80*2048 ~ 160k

      * best latency hiding when launch > ~10x this ~ 1M 


.. class:: tiny    


    Understanding Throughput-oriented Architectures
    https://cacm.acm.org/magazines/2010/11/100622-understanding-throughput-oriented-architectures/fulltext

    NVIDIA Titan V: 80 SM, 5120 CUDA cores


.. s5_talk::

    Optical photon simulation is close to being an ideal 
    workload for GPUs 




:small:`Primary Packages and Structs Of Re-Implemented Opticks`
-----------------------------------------------------------------

.. sidebar:: :small:`Flexible Multi-Package Organization`

    .. class:: small

         **Code Organized by Dependency (not "Topic")**
     
         * :r:`maximizes: utility, re-use, ease of testing` 
         * => "GPU" code usable+tested on CPU 

         **Many small header-only implementations** 

         * common CPU/GPU headers   



.. class:: small 

   *SysRap* : many small CPU/GPU headers
     * *stree.h,snode.h* : geometry base types
     * *sctx.h* *sphoton.h* : event base types
     * *NP.hh* : serialization into NumPy .npy format files     

   *QUDARap* 
     * *QSim* : optical photon simulation steering
     * *QScint,QCerenkov,QProp,...* : modular CUDA implementation 

   *U4*
     * *U4Tree* : convert geometry into *stree.h*
     * *U4* : collect gensteps, return hits 

   *CSG*
     * *CSGFoundry/CSGSolid/CSGPrim/CSGNode* geometry model
     * *csg_intersect_tree.h* *csg_intersect_node.h* *csg_intersect_leaf.h* : CPU/GPU intersection functions 

   *CSGOptiX*
     * *CSGOptiX.h* : manage geometry convert from *CSG* to OptiX 7 *IAS* *GAS*, pipeline creation
     * *CSGOptiX7.cu* : compiled into ptx that becomes OptiX 7 pipeline

       * includes QUDARap headers for simulation   
       * includes *csg_intersect_tree.h,..* headers for CSG intersection    
     
   *G4CX*
     * *G4CXOpticks* : Top level Geant4 geometry interface


.. s5_talk::

   Opticks code is split into multiple packages by-dependency, not by-topic
   This means that more of the code has less dependencies, making 
   it more useful and easier to test.   

   Using mocking,  most of the "GPU" code can be tested on CPU.  

   [Notes: <30s slide, mainly for offline consumption, no need to read out]



.. comment

    :small:`Full re-implementation of Opticks for NVIDIA OptiX 7 API` 
    --------------------------------------------------------------------

    .. class:: small

        * :r:`Huge change unavoidable from new OptiX API` --> :b:`So profit from rethink of simulation code` --> **2nd impl advantage** 

        +------------------------------------------+--------------------------------------------------------+
        |  Old simulation (OptiXRap)               |  New simulation (QUDARap/qsim.h + CSGOptiX, CSG)       | 
        +==========================================+========================================================+
        |  * implemented on top of old OptiX API   | * pure CUDA implementation                             |
        |                                          | * :r:`OptiX use kept separate, just for intersection`  |
        |                                          |                                                        |
        +------------------------------------------+--------------------------------------------------------+
        |  * monolithic .cu                        | * many small headers                                   |
        |  * GPU only implementation               | * many GPU+CPU headers                                 |
        |  * deep stack of support code            | * shallow stack : QUDARap depends only on SysRap       | 
        +------------------------------------------+--------------------------------------------------------+
        |  * most code in GPU only context,        | * strict code segregation                              |
        |    even when not needing OptiX or CUDA   |                                                        |
        |                                          |   * :r:`code not needing GPU in SysRap not QUDARap`    |
        +------------------------------------------+--------------------------------------------------------+
        |  * testing : GPU only, coarse            | * :r:`testing : CPU+GPU , fine-grained`                |
        |                                          | * curand mocking on CPU                                | 
        +------------------------------------------+--------------------------------------------------------+
        |  * limited CPU/GPU code sharing          | * maximal sharing : SEvt.hh, sphoton.h, ...            |
        +------------------------------------------+--------------------------------------------------------+
        |  * timeconsuming manual random alignment | * :b:`new systematic approach to random alignment`     |  
        |    conducted via debugger                |                                                        |
        +------------------------------------------+--------------------------------------------------------+

        **Goals of re-implementation : flexible, modular GPU simulation, easily testable, less code**

        * code reduction, sharing as much as possible between CPU and GPU
        * fine grained testing on both CPU and GPU, with GPU curand mocking 
        * profit from several years of CUDA experience, eg QSim.hh/qsim.h host/device counterpart pattern:

          * hostside initializes and uploads device side counterpart --> :r:`device side hits ground running` 


    .. s5_talk::

        Embracing the change : might as well profit from a rethink 

        [Notes: dont read out as too much text, just read a few of the highlighted]


:small:`Two-Level Hierarchy : Instance transforms (TLAS) over Geometry (BLAS)`
-------------------------------------------------------------------------------

.. class:: small

    **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


.. class:: small

    .. figure:: nvidia/tlas_blas_two_level_hierarchy.png
        :width: 800px
        :align: right 

        https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

.. class:: small

   AS
      Acceleration Structure

   TLAS (aka **IAS**) 
      4x4 transforms, refs to BLAS
       
   BLAS (aka **GAS**)
      | triangles : vertices, indices
      | custom primitives : AABB 

   AABB
      axis-aligned bounding box 


   **SBT : Shader Binding Table**

   Flexibly binds together:
 
   1. geometry objects
   2. shader programs 
   3. data for shader programs

   **Hidden in OptiX 1-6 APIs**



.. s5_talk::

   OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
   Other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
   This is because OptiX supports multiple instance levels. 
   But the simple two level is faster as that can be done on the RT cores.

   Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  


:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7`
-------------------------------------------------------------------------------

.. sidebar:: :small:`CSGFoundry Model`

    .. class:: small

        * :b:`array-based -> simple serialization + upload`
        * entire geometry in 4 GPU allocations 
        * factorized using subtree digests 

.. class:: small

    **Geant4 Geometry Model (JUNO: 300k PV, deep hierarchy)**

    +----+---------------------------+---------------------------------------------+ 
    | PV | *G4VPhysicalVolume*       | placed, refs LV                             |
    +----+---------------------------+---------------------------------------------+ 
    | LV | *G4LogicalVolume*         | unplaced, refs SO                           |
    +----+---------------------------+---------------------------------------------+ 
    | SO | *G4VSolid,G4BooleanSolid* | binary tree of SO "nodes"                   |
    +----+---------------------------+---------------------------------------------+ 

    **Opticks CSGFoundry Geometry Model** (index references)

    +---------------+----------------------------------------------------------------------------+----------------------------+
    | struct        | Notes                                                                      |  Geant4 Equivalent         |
    +===============+============================================================================+============================+
    | *CSGFoundry*  | vectors of the below, easily serialized + uploaded + :r:`used on GPU`      | None                       |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *qat4*        | 4x4 transform refs *CSGSolid* using "spare" 4th column (:b:`becomes IAS`)  | Transforms ref from PV     |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGSolid*    | refs sequence of *CSGPrim*                                                 | Grouped Vols + Remainder   | 
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGPrim*     | bbox, refs sequence of *CSGNode*, root of CSG Tree of nodes                | root *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGNode*     | CSG node parameters (JUNO: ~23k *CSGNode*)                                 | node *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+

    **NVIDIA OptiX 7 Geometry Acceleration Structures (JUNO: 1 IAS + 10 GAS, 2-level hierarchy)**

    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | IAS | Instance Acceleration Structures | JUNO: 1 IAS created from vector of ~50k *qat4* (JUNO)                   |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | GAS | Geometry Acceleration Structures | JUNO: 10 GAS created from 10 *CSGSolid* (which refs *CSGPrim,CSGNode* ) |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 

.. class:: small

    :r:`JUNO : Geant4 ~300k volumes "factorized" into 1 OptiX IAS referencing ~10 GAS`


.. s5_talk::

   The tables illustrates three geometry models.

   The CSGFoundry geometry model in the middle was designed 
   to enable translation between the Geant4 and OptiX models. 

      





:small:`Opticks : GPU Geometry starts from ray-primitive intersection`
-------------------------------------------------------------------------------------------------

.. class:: small

   * 3D parametric ray : **ray(x,y,z;t) = rayOrigin  +  t * rayDirection** 
   * implicit equation of primitive : **f(x,y,z) = 0**  
   * -> polynomial in **t** , roots: **t > t_min**  -> intersection positions + surface normals

.. figure:: /env/presentation/tboolean_parade_sep2017.png
   :width: 900px
   :align: center

   :red:`CUDA/OptiX intersection for ~10 primitives` -> :blue:`Exact geometry translation`








:small:`Ray intersection with general CSG binary trees, on GPU`
---------------------------------------------------------------------------------

.. sidebar:: Outside/Inside Unions

    .. class:: small

       dot(normal,rayDir) -> Enter/Exit

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_outside.png
       :width: 300px
       :align: center

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_inside.png
       :width: 300px
       :align: center

    .. class:: small

        * **A + B** boundary not inside other 
        * **A * B** boundary inside other 


.. class:: small

   Pick between pairs of nearest intersects, eg:

   =======================  ===========  ===============  ============== 
   *UNION* tA < tB           Enter B      Exit B           Miss B
   =======================  ===========  ===============  ============== 
   **Enter A**               ReturnA      :blue:`LoopA`    ReturnA
   **Exit A**                ReturnA      ReturnB          ReturnA 
   **Miss A**                ReturnB      ReturnB          ReturnMiss
   =======================  ===========  ===============  ============== 

   * *Nearest hit intersect algorithm* [1] avoids state

     * sometimes :blue:`Loop` : advance **t_min** , re-intersect both 
     * classification shows if inside/outside

   * *Evaluative* [2] implementation emulates recursion: 

     * :red:`recursion not allowed` in OptiX intersect programs
     * bit twiddle traversal of complete binary tree 
     * stacks of postorder slices and intersects 

   * :red:`Identical geometry to Geant4` 

     * solving the same polynomials 
     * near perfect intersection match



.. class:: tiny

    [1] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
        with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
 
    [2] https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h
        Similar to binary expression tree evaluation using postorder traverse. 






.. comment

    :i:`[9]cxr_i0_t8,_-1 : EXCLUDE SLOWEST`
    -----------------------------------------


:i:`cxr_overview_emm_t0_elv_t_moi__ALL_with-debug-disable-xj.jpg`
------------------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:2cm;" />


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        * :redbold:`purely analytic CSG, no triangles` 
      
        +--------------------------------------------+
        |  raytrace 2M pixels 1920x1080              |
        +======================+=====================+
        | **NVIDIA TITAN RTX** | 0.0091s (~110 FPS)  |
        | (1st gen. RT Cores)  |                     |
        +----------------------+---------------------+


.. s5_talk::

   Here is a ray trace render of JUNO using OptiX 7 
   There are no triangles here, this is a purely analytic ray trace with 
   the exact same geometry that the simulation uses.

   [Notes: ~10s slide, just the comment] 




.. comment

    :i:`cxr_min__eye_-10,0,0__zoom_1__tmin_0.1__sChimneyAcrylic_altview.jpg`
    -------------------------------------------------------------------------

    ``Raytrace render view from inside JUNO Water Buffer``

    .. s5_talk::

       Here is a view from inside the JUNO Water Buffer showing the PMTs
       pointing down at the acrylic sphere that contains the scintillator. 



.. comment

    :i:`cxr_min__eye_-30,0,5__zoom_1__tmin_25__sChimneyAcrylic_tmin_cutaway.jpg`
    ------------------------------------------------------------------------------

    ``ray TMIN cuts away sphere`` 

    .. s5_talk::

       Unlike with rasterization clipping, setting a ray tracing TMIN cuts away a sphere. 


    :i:`cxr_min__eye_-30,0,5__zoom_1__tmin_25__sChimneyAcrylic_skip_target_acrylic.jpg`
    ------------------------------------------------------------------------------------

    ``ELV=t94,95 ./cxr_min.sh  ## skip sTarget sAcrylic``

    .. s5_talk::

       Skipping the acrylic sphere and scintillator target allows to see more of the PMTs
       

.. comment

    `Increase TMAX to avoid cutoff`


:i:`cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_increased_TMAX.jpg`
-----------------------------------------------------------------------------------

``Raytrace render view from inside JUNO Water Buffer``


.. s5_talk::

    Klop



.. comment

    :i:`cxr_min__eye_-10,0,-30__zoom_0.5__tmin_0.1__sChimneyAcrylic_photon_eye_view.jpg`
    --------------------------------------------------------------------------------------

    ``ELV=t94,95 ./cxr_min.sh ## skip sTarget sAcrylic : upwards view`` 

    .. s5_talk::

       Here is a photon eye view from inside the scintillator, looking upwards towards the Chimney. 


:i:`cxr_overview_emm_image_grid_overview`
-------------------------------------------

``Comparison of ray traced render times of different geometry`` 
  ``simple way to find issues, eg over complex CSG, overlarge BBox`` 


.. s5_talk::

   Comparisons of ray trace rendering times provides simple way to look 
   for performance issues


.. comment

    :i:`scan_emm_jpg_select.txt_coarse.jpg`
    -----------------------------------------

    :i:`cxr_view_emm_t0_elv_t142_eye_-1,-1,-1,1__zoom_1__tmin_0.4__sWaterTube_skip_sBottomRock.jpg`
    -------------------------------------------------------------------------------------------------

    ``Render inside JUNO water buffer : PMTs, chimney, support sticks`` 


    .. s5_talk::

       Acceleration structure creation is a black box, so have to adopt an experimental 
       approach to finding the best geometry modelling to use.   


:i:`image_grid_elv_scan.jpg`
------------------------------

``Spot the differences : from volume exclusions``

.. s5_talk::

   If you look closely at the renders you can see differences 
   from the exclusion of single volume types. Doing this for 
   all volume types allows to sort the volumes by their 
   impact on the performance. 


.. comment

    vi $HOME/j/issues/scan_elv_jpg_select.txt  ## manually prepare list of 9 jpg with visible diffs
    export JPGLIST=$HOME/j/issues/scan_elv_jpg_select.txt
    open -n $(cat $JPGLIST)
    cx
    JPGLIST=$JPGLIST ./image_grid.sh 




.. comment

    cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_explain_the_grey.jpg
    --------------------------------------------------------------------------------

    Maybe a TMAX issue again ?







:i:`scan-pf-check-GUI-TO-SC-BT5-SD`
--------------------------------------

.. s5_talk::

   This GUI allows interactive selection between tens of millions 
   of photons based on their histories.  

   Here its showing the photons that scattered before boundary transmitting straight 
   through to surface detect.

   Its implemented by indexing the photon histories using some very fast 
   GPU big integer sorting provided by CUDA Thrust, 
   and using OpenGL shaders to switch between selections.

   The 64-bit integers hold up to 16 4-bit flags for each step of the photon.

   All of this is done using interop capabilities of OpenGL/CUDA/Thrust and OptiX
   so GPU buffers can be written to and rendered inplace with no copying around.


:i:`scan-pf-check-GUI-TO-BT5-SD`
----------------------------------

.. s5_talk::

   The GUI also provides interactive time scrubbing of the propagation 
   of tens of millions of photons. 

   This is some nanoseconds later for a different history category. 
  
   I created this GUI to help with debugging the simulation. 


.. comment

     * DELL Precision 7920T Workstation
     * Intel Xeon Silver 4114, 2.2GHz, 40 cores, 65G 
     * NVIDIA Quadro RTX 8000, 48G 

     * DELL Precision 7920T Workstation
     * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 65G  
     * NVIDIA TITAN RTX, 24G
     * NVIDIA TITAN V, 12G







.. comment

    :small:`cxr_overview.sh ELV scan 1080x1920 2M (NVIDIA TITAN RTX)`
    ---------------------------------------------------------------------

    .. class:: small

        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |idx|        -e|       time(s)    |      relative    |    enabled geometry description                                              |
        +===+==========+==================+==================+==============================================================================+
        |  0|      t133|        0.0077    |        0.9347    |    EXCL: sReflectorInCD                                                      |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  1|       t37|        0.0079    |        0.9518    |    EXCL: GLw1.bt08_bt09_FlangeI_Web_FlangeII                                 |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  2|       t74|        0.0079    |        0.9616    |    EXCL: GZ1.B06_07_FlangeI_Web_FlangeII                                     |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  ...                                                                                                                              |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        | 35|         t|        0.0083    |        1.0000    |    ALL                                                                       |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  ...                                                                                                                              |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |141|       t50|        0.0097    |        1.1750    |    EXCL: GLb1.up01_FlangeI_Web_FlangeII                                      |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |142|       t39|        0.0097    |        1.1751    |    EXCL: GLw1.bt10_bt11_FlangeI_Web_FlangeII                                 |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |143|      t123|        0.0097    |        1.1753    |    EXCL: PMT_3inch_inner1_solid_ell_helper                                   |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |144|       t46|        0.0097    |        1.1758    |    EXCL: GLb1.up05_FlangeI_Web_FlangeII                                      |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |145|       t16|        0.0102    |        1.2320    |    EXCL: sExpRockBox                                                         |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+

    .. class:: small

        :r:`Dynamic geometry : excluding volumes of each of 146 solids (after excluding slowest: solidXJfixture)` 

        * time range : 0.0077->0.0102 s (~ +-20% )  
        * reproducibility ~+-10%

        :b:`Small time range suggests no major geometry performance issues remain, after excluding slowest`

        * :r:`solids with deep CSG trees (eg solidXJfixture) can cause >2x slow downs`  


    .. s5_talk::

        You might think that the geometry without any exclusions would be the slowest, but 
        that is not the case. Varying the geometry changes the details of the acceleration structure. 
        Here the time range from fastest to slowest is rather small, suggesting there are 
        no major geometry performance problems left. 

        This is only the case after I excluded some problematic geometry. 
     
     







:small:`n-ary CSG Compound "List-Nodes" => Much Smaller CSG trees`
-------------------------------------------------------------------

.. sidebar:: :small:`Complex CSG => Tree Overheads`

    .. image:: GeoChain_Darwin/XJfixtureConstruction/CSGOptiXRenderTest/cvd0/50001/ALL/top_i0_/cxr_geochain_XJfixtureConstruction_ALL_upper.jpg 
          :align: right
          :width: 500px



.. class:: small


   :r:`Communicate shape more precisely`
       :r:`=> better suited intersect alg => less resources => faster` 

   Generalized Opticks CSG into three levels : tree < node < leaf 

   * `csg_intersect_tree.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_tree.h>`_ 
   * `csg_intersect_node.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h>`_
   * `csg_intersect_leaf.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_leaf.h>`_

   :b:`Generalizes binary to n-ary CSG trees`

   * list-node references sub-nodes by **subNum** **subOffset**

   CSG_CONTIGUOUS Union
      user guarantees contiguous, like G4MultiUnion of prim

   CSG_DISCONTIGUOUS Union
      user guarantees no overlaps, eg "union of holes" to be CSG subtracted : :r:`=> simple, low resource intersect` 

   CSG_OVERLAP Intersection
      user guarantees overlap, eg general G4Sphere: inner radius, thetacut, phicut


   :r:`Promising approach to avoid slowdowns from complex CSG solids`


.. s5_talk::

   Complex solids like this one with deep CSG trees can cause 
   large slowdowns.  In an attempt to reduce the performance degradation 
   I have generalize Opticks CSG to support list nodes in order to 
   reduce tree size and avoid large tree overheads. 


.. comment

    :small:`CSG_CONTIGUOUS Union : n-ary (not bin-ary) CSG intersection`
    -----------------------------------------------------------------------

    .. class:: small

        * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_contiguous`

    .. sidebar:: :small:`Alg works : but many TODOs`

        .. class:: small

           * integer templating : suit resources to shape
           * try sort networks, bitonic sort, ... 
           * compare performance with unbalanced trees
           * iterate implementation whilst measuring perf.


    .. class:: small

        1. *zeroth pass* : find **nearest_enter** and count first exits
        2. if zero exits => outside compound => return **nearest_enter**
        3. *first pass* : collect enter distances, **farthest_exit**
        4. order enter indices making **enter** distances ascend

           * :r:`n-ary : store, sort enters` :b:`(cf bin-ary : compare two)`
           * :b:`no tree overheads, but must store+sort distances`

        5. *2nd pass* : loop over enters in distance order 

           * contiguous requirement : **enter < farthest_exit** so far  
           * find Exits for Enters that qualify as contiguous, update farthest_exit

        6. return **farthest_exit** that qualifies as contiguous


    .. raw:: html

        <pre class="mypre15">
                 +----------------+     +-------------------+                  DISJOINT MUST BE DISQUALIFIED
                 |B               |     |D                  |                   
            +----|----+      +----|-----|----+       +------|----------+             +-----------+
            |A   |    |      |C   |     |    |       |E     |          |             |           |
            |    |    |      |    |     |    |       |      |          |             |           |
            | 0 E1    X2     E3  X4    E5   X6      E7     X8        [X9]           E10         X11
            |    |    |      |    |     |    |       |      |          |             |           |
            |    |    |      |    |     |    |       |      |          |             |           |
            +----|----+      +----|-----|----+       +------|----------+             +-----------+
                 |                |     |                   |
                 +----------------+     +-------------------+

                 E           E          E            E                               E 
                      X           X          X              X          X                         X
         </pre>



    .. s5_talk::

       Communicating the geometry more precisely enables a better suited intersection 
       algorithm to be used. This reduces resources and increases performance. 

       [notes: dont need to explain the algorithm in detail, important point is just the above comment] 



.. comment

    :small:`CSG_DISCONTIGUOUS Union : CSG intersection`
    ---------------------------------------------------------------

    .. class:: small

        * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_discontiguous`

        :r:`User guarantees : absolutely no overlapping between constituents`

    .. raw:: html

        <pre class="mypre15">
         +-------+          +-------+          +-------+          +-------+         +-------+      
         |       |          |       |          |       |          |       |         |       |      
         |       |          |       |          |       |          |       |         |       |      
         +-------+          +-------+          +-------+          +-------+         +-------+       

         +-------+          +-------+          +-------+          +-------+         +-------+      
         |       |          |       |          |       |          |       |         |       |      
         |       |          |       |          |       |          |       |         |       |      
         +-------+          +-------+          +-------+          +-------+         +-------+       

         </pre>


    .. class:: small

        * => very simple low resource intersection : **closest Enter or Exit**

        * :b:`More closely suiting algorithm to geometry => better performance`
        * this can help with "holes" subtracted from another solid : the "holes" usually do not overlap 

    .. s5_talk::

       Again more precise communication of intent for geometry -> better performance
       as it enables a very low resource intersection appoach to be used and it can 
       avoid tree overheads.  












:small:`QUDARap : CUDA Optical Simulation Implementation`
------------------------------------------------------------

.. sidebar:: :small:`CPU Pre-Init of GPU Counterpart`

    .. class:: small

        hh
           instanciate device .h **on host**, upload constituents (eg texture buffers),  
           set constituent device pointers into .h instance, upload .h instance to GPU  
        h
           simple device header, testable on CPU 
            
        --> :r:`device side hits ground running` 


.. class:: small

    **CPU/GPU Counterpart Code Organization for Simulation**

    +-------------------------------+-----------------+-----------------------+
    |                               | CPU             | GPU                   |
    +===============================+=================+=======================+
    | context steering              | QSim.hh         |  qsim.h               |  
    +-------------------------------+-----------------+-----------------------+
    | curandState setup             | QRng.hh         |  qrng.h               |
    +-------------------------------+-----------------+-----------------------+
    | property interpolation        | QProp.hh        |  qprop.h              |
    +-------------------------------+-----------------+-----------------------+
    | event handling                | QEvent.hh       |  qevent.h             |
    +-------------------------------+-----------------+-----------------------+
    | Cerenkov generation           | QCerenkov.hh    |  qcerenkov.h          |
    +-------------------------------+-----------------+-----------------------+
    | Scintillation generation      | QScint.hh       |  qscint.h             |
    +-------------------------------+-----------------+-----------------------+
    | texture handling              | QTex.hh         |  cudaTextureObject_t  |
    +-------------------------------+-----------------+-----------------------+
    

    * :r:`facilitate fine-grained modular testing` 
    * bulk of GPU code in simple to test headers 

      * test most "GPU" code on CPU,  eg using mock curand

    * *QUDARap* does not depend on OptiX -> more flexible -> simpler testing    



.. s5_talk::

    Of course in addition to geometry intersections the simulation also 
    needs the optical physics. The QUDARap package is a pure CUDA port 
    of the Geant4 optical simulation, with no OptiX dependency. 

    [Notes: mainly of intersect for people writing CUDA code, a useful pattern] 


.. comment

       +---------------------------------------+
       | **A** (GPU) CSGOptiX/qsim.h           |
       +=======================================+
       |  qsim => sctx/sevent/SEvt             |
       +---------------------------------------+

       +---------------------------------------+
       | **B** (CPU) U4Recorder                |
       +=======================================+
       | G4StepPoint => sctx/sevent/SEvt       |
       +---------------------------------------+





:small:`Validation of Opticks Simulation(A) by Comparison with Geant4 Sim. (B)`
--------------------------------------------------------------------------------

.. sidebar:: :small:`A+B photon histories => SEvt`

   .. class:: small

      * **A** : CSGOptiX : qsim => SEvt
      * **B** : U4Recorder : G4StepPoint => SEvt 

      +---------------------------------------+
      | **Opticks Event** : sysrap/SEvt.hh    |
      +=======================================+ 
      | sevent.h sctx.h sphoton.h srec.h ...  |
      +---------------------------------------+
      | :r:`serialize to NumPy .npy arrays`   |
      +---------------------------------------+

      => A-B comparison, matplotlib/pyvista plotting

      +------------+------------+------------------+
      |  array     | shape      |  notes           |  
      +============+============+==================+
      | inphoton   | (n,4,4)    | input photons    |
      +------------+------------+------------------+
      | photon     | (n,4,4)    | final photons    |
      +------------+------------+------------------+
      | record     | (n,32,4,4) | photon histories |
      +------------+------------+------------------+
      | seq        |  (n,2,2)   | uint64 histories |   
      +------------+------------+------------------+
      | aux        | (n,32,4,4) | extra point info |       
      +------------+------------+------------------+
      | sframe     | (4,4,4)    | target M2W W2M   |
      +------------+------------+------------------+

      :b:`Record of every point of every photon`


.. class:: small 

   **A and B always same photon counts (due to gensteps)** 

   1. direct comparison when simulations are random aligned
   2. when not aligned : statistical Chi2 history comparison

      * compare history frequencies, Chi2 points to issues

   **Primary Issue : double vs float, also:**

   * geometry bugs : overlaps, coincident faces 
   * grazing incidence, edge skimmers

   After debugged : :b:`fraction of percent diffs` 

   **Optical Performance : Very dependent on geometry + modelling**

   After avoiding geometry problems : G4Torus, deep CSG trees

   * :r:`have achieved > 1500x Geant4 [1]` 
   * :b:`removes optical bottlenecks : memory + processing` 

.. class:: tiny 

   [1] Single threaded Geant4 10.4.2, NVIDIA Quadro RTX 8000 (48G), 1st gen RTX, ancient JUNO geom, OptiX 6.5, ancient Opticks 
    

.. s5_talk::

    The Opticks simulation is validated by comparison with the Geant4 simulation. 

    Full details of the optical photon propagations from both simulations 
    are collected into Opticks Events and persisted to NumPy arrays. 
    Allowing NumPy analysis to compare the photon propagations. 


:small:`Optical Simulation Comparison : Statistical OR Direct`
----------------------------------------------------------------

.. class:: small

    Statistical Chi-squared comparison of photon history occurence between two simulations

    * powerful metric to find discrepancies between simulations (eg from near-degenerate geometry)

.. raw:: html
 
    <pre class="mypretiny">
    c2sum/c2n:c2per(C2CUT)  280.88/188:1.494 (30)

    np.c_[siq,_quo,siq,sabo2,sc2,sabo1][0:25]  ## A-B history frequency chi2 comparison 
        0   TO BT BT BT BT SD                                             33322  33343    0.0066        1      2  
        1   TO BT BT BT BT SA                                             28160  28070    0.1441        8      0  
        2   TO BT BT BT BT BT SR SA                                        6270   6268    0.0003    10363  10565  
        3   TO BT BT BT BT BT SA                                           4552   4649    1.0226     8398   8433  
        4   TO BT BT BT BT BT SR BR SR SA                                  1154   1186    0.4376    21156  21014  
        5   TO BT BT BT BT BT SR BR SA                                      923    989    2.2782    20241  20201  
        6   TO BT BT BT BT BR BT BT BT BT BT BT AB                          946    958    0.0756    10389   8432  
        7   TO BT BT BT BT BT SR SR SA                                      901    942    0.9121    10399  10410  
        8   TO BT BT AB                                                     878    895    0.1630       26    102  
        9   TO BT BT BT BT BT SR BT BT BT BT BT BT BT AB                    615    635    0.3200    20974  22027  
       10   TO BT BT BT BT BR BT BT BT BT AB                                571    601    0.7679     8459   9208  
       11   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SA                    533    537    0.0150     7312   7299  
       <span class="r">12   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SD        503    396   12.7353    12018  11465</span>  
       13   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SD                    480    497    0.2958     7974   7967  
       14   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SA        412    411    0.0012    11467  11471  
       15   TO BT BT BT BT BT SR SR SR SA                                   383    396    0.2169    10362  10368  
     </pre>

.. class:: small

    When causes of discrepancy cannot be identified statistically

    * use common input photons + aligned random consumption between simulations 
    * enable direct photon-to-photon comparison of simulations : reveals precisely where simulations diverge

    :b:`Comparison of two independent optical simulation implementations : ideal way find issues`


.. s5_talk::

    Ideal 



:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_yy_frame_close.png`
----------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:130mm;" />

.. class:: small

    ``Green : start position (100k input photons)`` 

    ``Red : end position,  Cyan : other position``


.. s5_talk::

    3D pyvista view of photon points here from input photons shown in green. 
    The squares indicates the target frame.


:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_b.png`
-------------------------------------------

.. class:: small

   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   ``cd ~/j/ntds ; N=1 ./ntds.sh ana``  

.. raw:: html

    <p style="margin-bottom:150mm;" />

.. class:: small

   :b:`Geant4/U4Recorder 3D photon points transformed into target frame, viewed in 2D`
 

.. s5_talk::

   This is a 2D view of the target frame, showing intersection positions on the
   PMT mask and inside the PMT. 



:i:`B_V1J008_N1_OIPF_NNVT:0:1000_gridxy.png`
----------------------------------------------


::

     export OPTICKS_INPUT_PHOTON=GridXY_X1000_Z1000_40k_f8.npy
     export OPTICKS_INPUT_PHOTON_FRAME=NNVT:0:1000

     MODE=3 EDL=1 N=0 EYE=500,0,2300 CHECK=not_first ~/j/ntds/ntds.sh ana


.. raw:: html

    <p style="margin-bottom:110mm;" />
    

::

    Photon step points from grid of input photons target NNVT:0:1000 (POM:1)


.. s5_talk::

    This is a 3D pyvista view of photon points from a grid of input photons. 
    Looking closely you can distinguish the type of PMT 
    by the size of ring inside. 


:i:`cxr_min__eye_1,0,5__zoom_2__tmin_0.5__NNVT:0:1000_demo.jpg`
-----------------------------------------------------------------

``ray traced renders : exact same geometry "seen" by simulation``


.. s5_talk::

    This is a ray trace render targetting the same group of PMTs. 
    You can see the same pattern of PMTs from the ray trace and from the simulation. 




:small:`Multi-Layer Thin Film (A,R,T) Calc using TMM Calc (Custom4 Package)`
------------------------------------------------------------------------------

.. sidebar:: :small:`TMM : Transfer Matrix Method`
 
   .. image:: tmm/multi-layer-stack.png
       :align: center
       :width: 400px

   .. class:: small

       **multi-layer thin films, coherent calc:**

       * complex refractives indices, thicknesses
       * => (A,R,T)  (Absorb, Reflect, Transmit)
       * Used from **C4OpBoundaryProcess**  

       :r:`header-only GPU/CPU` : **C4MultiLayrStack.h**       
    
       https://github.com/simoncblyth/customgeant4/

.. class:: small


    C4OpBoundaryProcess.hh
       G4OpBoundaryProcess with C4CustomART.h 
    
    C4CustomART.h
       integrate custom boundary process and TMM calculation

    C4MultiLayrStack.h : :b:`CPU/GPU TMM calculation of (A,R,T)` 
       based on complex refractive indices and layer thicknesses 
 
       * GPU: **using thrust::complex** CPU:**using std::complex**

    :r:`Custom4: Simplifies JUNO PMT Optical Model + Geometry` 

.. image:: GEOM/FewPMT/U4SimtraceTest/1/figs/U4SimtraceTest/mpcap/FewPMT_demo.png
   :width: 580px
   :align: left


.. comment
 
    .. image:: Custom4/Custom4_README.png
       :width: 580px
       :align: left


.. s5_talk::

   Customizing the Geant4 boundary process allows a very natural 
   way to support calculation of thin film interference effects 
   using the transfer matrix method. That is implemented in a 
   single header that is used both on CPU and GPU.  

   This slide summarizes recent work that enables the JUNO PMT geometry 
   to be simplified and also enables the same PMT geometry to be used 
   for the Geant4 and Opticks simulations. 




:i:`LayrTest__R12860_Aspa.png`
---------------------------------

.. s5_talk::

    Aspa : This is just showing the absorption, the dotted lines are the average of the S and P polarizations





:small:`Summary and Links`
-------------------------------------------------------------------------------------

.. sidebar:: :small:`Hidden Benefits of Adopting Opticks`

   .. class:: small

      * detailed photon instrumentation, validation 
      * comparisons find issues with both simulations:
       
        * complex geometry, overlaps, bugs... 

      :r:`=> using Opticks improves CPU simulation too !!`

.. raw:: html

     <p style="margin-bottom:5mm;" />

..

  *Opticks* : state-of-the-art GPU ray traced optical simulation integrated with *Geant4*. 
  Full re-implementation of Opticks geometry and simulation for NVIDIA OptiX 7 completed.


.. raw:: html

     <p style="margin-bottom:15mm;" />

.. class:: normal

  * NVIDIA Ray Trace Performance continues rapid progress (2x each generation) 
  * **any simulation limited by optical photons can benefit from Opticks**
  * more photon limited -> more overall speedup (99% -> 100x)


.. table::
    :align: center

    +--------------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks        | code repository                         |                   
    +--------------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io                 | presentations and videos                |
    +--------------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                      | forum/mailing list archive              |
    +--------------------------------------------------+-----------------------------------------+
    | email: ``opticks+subscribe@groups.io``           | subscribe to mailing list               |
    +--------------------------------------------------+-----------------------------------------+ 
    | ``simon.c.blyth@gmail.com``                      | any questions                           |   
    +--------------------------------------------------+-----------------------------------------+ 

.. s5_talk::

    Opticks brings state-of-the-art GPU ray tracing performance to optical photon 
    simulations. 

    The detailed validations needed when adopting a new simulation has a 
    hidden benefit in that detailed comparisons reveal problems with both 
    simulations. Adopting Opticks means you will 
    improve your CPU simulation whilst also giving you a GPU simulation.  
 
    Links to get you started with using Opticks are listed here.


:small:`Opticks : CEPC Calorimeter Sim?`
---------------------------------------------------

.. class:: small

    **Dual Readout Calorimeter**

    Scintillation + Cerenkov Fibers + SiPM 

    * Sanghun Ko, SNU : Developed Geant4 FastSim 

    **Opticks could provide** : *Fast-Full-Simulation* on GPU

    :r:`optical limited simulations : can benefit from Opticks`


.. class:: tiny

    https://indico.bnl.gov/event/11918/contributions/50512/attachments/35032/56968/210608_shKo_EIC.pdf


.. s5_talk::

   Searching for optical photon simulation issues in future detectors 
   I found some work by Sanghun Ko from Korea who developed a Geant4 fast 
   sim parameterization to help with optical photon simulation of Cerenkov 
   and Scintillation fibers. FastSim approaches can be useful but they always 
   need to be validated against a full simulation so Opticks may well be able 
   to help. 

 




