
.. comment 

    00 : <inline classes="i">Opticks : GPU Optical Photon Simulation for Particle Physics with NVIDIA OptiX</inline> 
    01 : opticks benefits 
    02 : outline 

        Highlights teaser statement and outline

    03 : optical photon simulation problem... 
    04 : jpmt before contact 2 

        Statement of problem

    05 : ray traced realistic image synthesis --> optical photon simulation 

        Ray trace connection to simulation

    06 : nvidia optix 1 
    07 : nvidia optix 2 

        OptiX intro are refs 

    08 : opticks geometry workflow : geocache 
    09 : large geometry techniques : instancing mandatory 
    10 : opticks geometry workflow : gpu textures 



    11 : hybrid geant4/opticks event workflow 
    12 : opticks interoperation : optix/cuda/thrust/opengl 


    ABSTRACT

    Opticks is an open source project that integrates the NVIDIA OptiX 
    GPU ray tracing engine with Geant4 toolkit based simulations.
    Massive parallelism brings drastic performance improvements with
    optical photon simulation speedup expected to exceed 1000 times Geant4 
    when using workstation GPUs. Optical photon simulation time becomes 
    effectively zero compared to the rest of the simulation.

    Optical photons from scintillation and Cherenkov processes
    are allocated, generated and propagated entirely on the GPU, minimizing 
    transfer overheads and allowing CPU memory usage to be restricted to
    optical photons that hit photomultiplier tubes or other photon detectors.
    Collecting hits into standard Geant4 hit collections then allows the 
    rest of the simulation chain to proceed unmodified.

    Optical physics processes of scattering, absorption, reemission and 
    boundary processes are implemented as CUDA OptiX programs based on the Geant4
    implementations. Wavelength dependent material and surface properties as well as 
    inverse cumulative distribution functions for reemission are interleaved into 
    GPU textures providing fast interpolated property lookup or wavelength generation.

    Geometry is provided to OptiX in the form of CUDA programs that return bounding boxes 
    for each primitive and single ray geometry intersection results. Some critical parts 
    of the geometry such as photomultiplier tubes have been implemented analytically 
    with the remainder being tesselated. 
    OptiX handles the creation and application of a choice of acceleration structures
    such as boundary volume heirarchies and the transparent use of multiple GPUs.

    OptiX interoperation with OpenGL and CUDA Thrust has enabled 
    unprecedented visualisations of photon propagations to be developed 
    using OpenGL geometry shaders to provide interactive time scrubbing and 
    CUDA Thrust photon indexing to provide interactive history selection.

    Validation and performance results are shown for the photomultiplier based 
    Daya Bay and JUNO Neutrino detectors.



.. raw:: html

    <style type="text/css">
        span.alarm { color: red; } 
        span.warn { color: orange; } 
        span.ok { color: green; } 
        span.i { display: none; } 
        pre.sliteral { class:"literal-block small"; }   
        pre.mypre {
             display: block;
             font-family: monospace;
             font-size: 20px;
             white-space: pre;
             margin: 1em 0;
        }

        pre.mypretiny {
             display: block;
             font-family: monospace;
             font-size: 15px;
             white-space: pre;
             margin: 1em 0;
        }

        pre.myfoot {
             display: block;
             font-family: monospace;
             font-size: 18px;
             white-space: pre;
             color: white;
             position: absolute; top:86%; left:4%; width:50%; height:10% ;
        }

        a.mylink {
             display: block;
             font-family: monospace;
             font-size: 18px;
             white-space: pre;
             color: black;
             position: absolute; top:86%; left:4%; width:50%; height:10% ;
        }


        div.mytitle {
             font-size: 20px;
             color: black;
             position: absolute; top:0%; left:5%; width:90%; height:10% ;
        }

        div.mycredit {
             font-size: 20px;
             color: black;
             position: absolute; top:90%; left:5%; width:80%; height:10% ;
        }





    </style>

.. role:: i 
.. role:: alarm
.. role:: warn
.. role:: ok
.. role:: sliteral
.. role:: mypre 
.. role:: myfoot
.. role:: mytitle


.. include:: <s5defs.txt>

.. s5_background_image::

    #
    # slide titles and background image urls, 
    # including server relative urls like /env/geant4/geometry/collada/daeview/20140419-170713.png
    # and protocol relative urls like //localhost/env/test/LANS_AD3_CoverGas_Humidity.png
    #
    # NB1 slide titles here must match those in body precisely, 
    # NB2 also ensure all slide titles are unique
    #
    #slide0
    #/env/geant4/geometry/collada/g4daeview/20140419-170713.png auto_auto 0px_0px
    #/env/geant4/geometry/collada/g4daeview/20140419-170713-1024x768.png auto_auto 0px_0px
    #
    #   wide targetting 1280x720
    #   
    #
    slide0
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 1280px_720px

    Opticks Benefits
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 1280px_720px

    Visualizing An Optical Photon Simulation
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 640px_360px 600px_100px

    Overview
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 1280px_720px

    g4daeview.py : Fast OpenGL 3D viewer for G4DAE files
    /env/geant4/geometry/collada/g4daeview/20140419-170713.png

    Cerenkov Photons Simulation - Top View
    /env/geant4/geometry/collada/g4daeview/20141224-115923.png

    Cerenkov Photons Simulation - Side View
    /env/geant4/geometry/collada/g4daeview/20141224-115935.png

    Scintillation Photons Simulation - Top View
    /env/geant4/geometry/collada/g4daeview/20141224-121444.png

    Scintillation Photons Simulation - Side View
    /env/geant4/geometry/collada/g4daeview/20141224-121435.png

    Standard Geant4 Workflow
    /env/keynotefigs/G4DAEChroma/G4DAEChroma.001.png

    External Photon Simulation Workflow
    /env/keynotefigs/G4DAEChroma/G4DAEChroma.002.png

    GGeoView
    /env/graphics/ggeoview/ggeoview-cerenkov-001.png 1047px_795px

    GGeoView M1 Points
    /env/graphics/ggeoview/ggeoview-scintillation-points-mat1.png 1435px_848px

    GGeoView Flag Selection 
    /env/graphics/ggeoview/ggeoview-scintillation-flag-seq-select.png 1436px_842px

    GGeoView Cerenkov Geom M1
    /env/graphics/ggeoview/ggeoview-cerenkov-m1-geom.png 1416px_845px
  
    Detecting Neutrinos via Optical Photons 1
    /env/presentation/dayabay-principal_half.png 1417px_830px 

    Detecting Neutrinos via Optical Photons 2
    /env/presentation/dayabay-principal_half.png 1417px_830px 
 
    JPMT Inside Wide 
    /env/graphics/ggeoview/jpmt-inside-wide_half.png 1432px_844px

    JPMT Wide
    /env/graphics/ggeoview/jpmt-wide_half.png 1409px_836px
  
    JPMT Headview
    /env/graphics/ggeoview/jpmt-headview_half.png 1308px_783px
 
    JPMT Backview
    /env/graphics/ggeoview/jpmt-backview_half.png 1149px_794px 
 
    JPMT Approach 
    /env/graphics/ggeoview/jpmt-approach_half.png 1431px_839px

    JPMT Arrival 
    /env/graphics/ggeoview/jpmt-arrival_half.png 1427px_841px 
 
    Optical Photon Simulation Problem...
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JPMT Before Contact
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JPMT Before Contact 2
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JPMT Before Contact 3
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

 
    JPMT After Contact 
    /env/graphics/ggeoview/jpmt-after-contact_half.png 1425px_840px 
  
    JPMT Inside Outside 
    /env/graphics/ggeoview/jpmt-inside-outside_half.png 1401px_842px

    NVIDIA OptiX In Action
    /env/presentation/optix-in-action_half.png 966px_646px 100px_50px

    PmtInBox approach 1
    /env/graphics/ggeoview/PmtInBox-approach.png 1069px_769px 

    PmtInBox approach 2
    /env/graphics/ggeoview/PmtInBox-approach.png 1069px_769px 

    PmtInBox after 1
    /env/graphics/ggeoview/PmtInBox-after.png 1057px_760px 

    PmtInBox after 2
    /env/graphics/ggeoview/PmtInBox-after.png 1057px_760px 

    Daya Bay PMT Wall Photo 1
    /env/presentation/gtc2016/dyb-pmt-wall-photo.png 1329px_798px  

    Daya Bay PMT Wall Photo 2
    /env/presentation/gtc2016/dyb-pmt-wall-photo.png 1329px_798px  

    Super-Kamiokande PMTs Not 16:9 
    /env/presentation/gtc2016/sk-PH20-water-withboat-apr23-wm.png 1181px_771px

    Super-Kamiokande PMTs 1
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Super-Kamiokande PMTs 2
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Super-Kamiokande PMTs 3
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Super-Kamiokande PMTs 4
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Kamiokande II 1
    /env/presentation/1987a.png 1280px_720px

    Kamiokande II 2
    /env/presentation/1987a.png 1280px_720px

    Kamiokande II 3
    /env/presentation/1987a.png 1280px_720px


    Fast Optical Photon Simulation
    /env/presentation/newtons-opticks.png 374px_684px 800px_0px

    Photomultiplier Tubes (PMTs)
    /env/presentation/hamamatsu-pmt-16x9.png 1280px_720px

    Photomultiplier Tube Operation
    /env/presentation/hamamatsu-pmt-16x9.png 1280px_720px

    Old Hamamatsu Photomultiplier Tubes (PMTs)
    /env/presentation/hamamatsu-pmt.png 1099px_734px

    Old Photomultiplier Tube Operation
    /env/presentation/hamamatsu-pmt.png 1099px_734px




    Jiangmen Underground Neutrino Observatory (JUNO) 
    /env/presentation/juno-schematic-5.png 1391px_734px

    Jiangmen Underground Neutrino Observatory, Goals
    /env/presentation/juno-schematic-5.png 1391px_734px


    Dayabay Reactor Neutrino Expt, Far Site
    /env/presentation/DybFar_crop.png 1280px_720px

    Daya Bay Far Site 2
    /env/presentation/DybFar_crop.png 1280px_720px

    Daya Bay Far Site 3
    /env/presentation/DybFar_crop.png 1280px_720px

    Geant4 : Monte Carlo Simulation Toolkit 
    /env/presentation/g4-hep.png 1025px_621px 100px_100px 

    Geant4 : Monte Carlo Simulation Toolkit Generality
    /env/presentation/g4-hep.png 1025px_621px 100px_100px 

    "Seeing" neutrinos via scintillation + Cherenkov light
    /env/presentation/cherenkov.png 316px_203px 850px_400px

    Large Geometry Techniques : Instancing Mandatory
    /env/graphics/ggeoview/ggv-juno-instancing.png 852px_592px 450px_80px

    NVIDIA OptiX 1
    /env/presentation/NVIDIAOptiXWebsite_Oct2016.png 1280px

    NVIDIA OptiX 2
    /env/presentation/NVIDIAOptiXWebsite_Oct2016.png 1280px

    OpticksDocs
    /env/presentation/OpticksDocs.png 1280px_720px

    Daya Bay Antineutrino Detection via Inverse Beta Decay 1
    /env/presentation/AntineutrinoDetectionViaIBDJetterSept2014.png 809px_576px 100px_100px

    Daya Bay Antineutrino Detection via Inverse Beta Decay 2
    /env/presentation/AntineutrinoDetectionViaIBDJetterSept2014.png 809px_576px 100px_100px
    # a = np.array([1676.0, 1192.0])
    # .8*720.*a/1192.

    Daya Bay Energy Response Model (1)
    /env/presentation/ZheTaupDetectorResponseModel.png 968px_576px 100px_100px

    Daya Bay Energy Response Model (2)
    /env/presentation/ZheTaupDetectorResponseModel.png 968px_576px 100px_100px

    # a = np.array([2392., 1424.]) ; .8*720*a/a[1]



    Daya Bay Energy Response Model : Fit to Calibration Data 1
    /env/presentation/EnergyResponseModel.png 693px_504px 0px_100px 
    # a = np.array([1760., 1280.])
    # .8*720.*a/1280.   792px_576px
    # 693.,  504

    Daya Bay Energy Response Model : Fit to Calibration Data 2
    /env/presentation/ConstrainingNonLinearity.png 761px_553px 0px_80px
    # a = np.array([1698., 1166.])
    # .8*720.*a/1166. 
    
    Daya Bay nGd Analysis : Most Precise Theta13
    /env/presentation/DYBZheTaup2015Theta13OscillationAnalysis.png 1057px_625px 100px_60px
    # a = np.array([2140., 1266.])
    # .8*720.*a/1166.


    Opticks Analytic Daya Bay Near Site, GPU Raytrace (3)
    /env/presentation/op_full_raytrace_3.png 1280px_720px

    Opticks Analytic Daya Bay Near Site, GPU Raytrace (1)
    /env/presentation/op_full_raytrace_1.png 1280px_720px

    Opticks Analytic Daya Bay Near Site, GPU Raytrace (0)
    /env/presentation/op_full_raytrace_0.png 1280px_720px

    Opticks Analytic Daya Bay Near Site, GPU Raytrace (2)
    /env/presentation/op_full_raytrace_2.png 1280px_720px











.. comment 

    Large Geometry/Event Techniques
    /env/graphics/ggeoview/ggv-juno-instancing.png 2130px_1480px -> 1065px_740px 


    GGeoView image is 2094x1590 1047x795

    GGeoView M1 Points is 2870x1696  1435x848

    GGeoView Flag Selection 2872x1684 1436x842

    GGeoView Cerenkov Geom M1 2832x1690 1416x845


    Generated Scintillation Photons GPU cf Geant4
    /env/g4dae/generated_scintillation_time_wavelength.png

    G4/DetSim Generated Cerenkov Wavelength
    /env/g4dae/g4_cerenkov_wavelength.png



.. comment

    Placeholder

    jpmt-after-contact.png 2850px_1680px
    jpmt-approach.png 2862px_1678px
    jpmt-arrival.png 2854px_1682px
    jpmt-backview.png 2298px_1588px
    jpmt-before-contact.png 2860px_1688px
    jpmt-headview.png 2616px_1566px
    jpmt-inside-outside.png 2802px_1684px
    jpmt-wide.png 2818px_1672px



========================================================================================
:i:`Opticks : GPU Optical Photon Simulation for Particle Physics with NVIDIA OptiX` 
========================================================================================

.. comment

   I will introduce Opticks, 
   an optical photon simulation based on NVIDIA OptiX ray tracing 
   enabling particle physics detector simulations 
   to benefit from OptiX ray tracing.

   The image visualizes photons coming from a cosmic ray muon 
   crossing a neutrino detector.


.. raw:: html

    <div class="mytitle">
    <h1 style="background-color:lightgrey"> <i>Opticks</i> : GPU Optical Photon Simulation for Particle Physics with NVIDIA® OptiX™ </h1>
    </div>

    <div class="mycredit">
    <h2 style="background-color:lightgrey"> Simon C Blyth, National Taiwan University &mdash; https://bitbucket.org/simoncblyth/opticks &mdash; July 2017 IHEP</h2>
    </div>



:i:`Opticks Benefits`
---------------------------

.. sidebar:: Opticks > 1000x Geant4 (*)

   .. class:: small

       GPU massive parallelism **eliminates bottleneck**.

       * optical photon simulation time --> zero 
       * optical photon CPU memory --> zero
       * **NEW:** :red:`auto-translate GDML geometry for GPU` 

       [zero: effectively, compared to rest of simulation]

       **More Photons -> More Benefit** 

       * Neutrino detectors can benefit the most, eg
         JUNO and Dayabay 

       http://bitbucket.org/simoncblyth/opticks

       (*) core extrapolated from mobile GPU speed


.. comment

   Neutrino detectors can benefit the most as their operation
   depends on production and propagation of sometimes many millions
   of optical photons. 
   
   Neutrinos detectors need to be large, as neutrinos 
   interact only weakly.

   **Radical simulation speedup -> short development cycle -> improved understanding** 



:small:`Opticks Progress : Moving to Fully Analytic GPU Geometry`
----------------------------------------------------------------------


.. sidebar:: Status Nov 2016, LLR [1]

   .. class:: small

      * **Opticks 200x Geant4** with mobile GPU
      * Expect: **Opticks > 1000x Geant4** (with workstation GPUs) 
      * :blue:`photon propagation time --> zero`
      * :blue:`analytic geometry --> precise Geant4 match`

      **CAVEAT:** :red:`Analytic required` for chi2 match



.. class:: small 


    **Geometry Status (Nov 2016)**
 
    * mostly approximated, using G4 tesselation 
    * based on G4DAE geometry export 
    * manually analytic PMT geometry
    * partition CSG solids into single primitive parts 
    * splits at joins avoid general CSG boolean intersection

    **Geometry Status (July 2017)**

    * :red:`general CSG tree intersection implemented on GPU`
    * automated conversion, GDML -> glTF -> Opticks GPU 
    * currently debugging geometry (coincident faces)


.. class:: tiny

    [1] LLR Workshop, https://simoncblyth.bitbucket.io/env/presentation/opticks_gpu_optical_photon_simulation_nov2016_llr.html 



:small:`Constructive Solid Geometry (CSG)`
-------------------------------------------------------

.. sidebar:: CSG Binary Tree

    .. image:: /env/presentation/hanrahan_example_of_solid_object_formed_using_csg.png
       :width: 450px
       :align: right

    .. class:: small

       Primitives combined via binary operators 


.. class:: small

   Simple *by construction* definition, implicit geometry.

   * **A, B** implicit primitive **solids** 
   * **A + B** : union (OR)
   * **A * B** : intersection (AND) 
   * **A - B** : difference (AND NOT) 
   * **!B** : complement (NOT) (inside <-> outside)

   CSG expressions 

   * non-unique: **A - B == A * !B**
   * represented by binary tree, primitives at leaves

   3D Parametric Ray : **ray(t) = r0 + t rDir**  


   **Ray Geometry Intersection**

   * primitive : find *t* roots of implicit eqn
   * composite : :red:`pick` primitive intersect, depending on CSG tree


.. class:: large

   :red:`How to pick exactly ?`



:small:`CSG : Which primitive intersect to pick ?`
-------------------------------------------------------
    

.. sidebar:: In/On/Out transitions

    .. class:: small

    .. image:: /env/presentation/hanrahan_example_of_solid_object_formed_using_csg_roth_diagram.png
       :width: 450px
       :align: right


.. class:: small

   Classical Roth diagram approach

   * find all ray/prim intersects
   * recursively combine inside intervals using CSG operator
   * works from leaves upwards

   Computational requirements:

   * find all intersects, store them, order them
   * recursive traverse

   BUT : **High performance on GPU requires**:

   * massive parallelism -> more the merrier
   * low register usage -> keep it simple
   * small stack size -> **avoid recursion** 

.. class:: large

   :red:`Classical approach not appropriate on GPU`

   

:small:`Ray Tracing CSG Objects Using Single Hit Intersections (A. Kensler) [*]`
---------------------------------------------------------------------------------

.. sidebar:: Outside/Inside Unions

    .. class:: small

       dot(normal,rayDir) -> Enter/Exit

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_outside.png
       :width: 300px
       :align: center

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_inside.png
       :width: 300px
       :align: center

    .. class:: small

        * **A + B** boundary not inside other 
        * **A * B** boundary inside other 


.. class:: small

   * Classify A,B intersects, Enter/Exit/Miss
   * state(A,B) -> action
   * LoopA : tMinA->tA, re-intersectA, re-classifyA (ditto LoopB)
 
   ===============  ===========  ============  ============== 
   Union, tA < tB     Enter B     Exit B        Miss B
   ===============  ===========  ============  ==============
   **Enter A**        ReturnA      LoopA        ReturnA
   **Exit A**         ReturnA      ReturnB      ReturnA 
   **Miss A**         ReturnB      ReturnB      ReturnMiss
   ===============  ===========  ============  ==============

   ===============  ===========  ============  ============== 
   Union, tB < tA     Enter B     Exit B        Miss B
   ===============  ===========  ============  ==============
   **Enter A**        ReturnB      ReturnB      ReturnA
   **Exit A**         LoopB        ReturnA      ReturnA 
   **Miss A**         ReturnB      ReturnB      ReturnMiss
   ===============  ===========  ============  ==============


.. class:: small

   :blue:`Recursive CSG tree python prototype of Kensler pseudocode worked after state table corrections/extensions`

   * BUT GPU/OptiX demands: :red:`no recursion in intersect program`  

.. class:: tiny

    [*] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
        with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
  


:small:`CSG Complete Binary Tree Serialization -> simplifies GPU side`
---------------------------------------------------------------------------------

.. sidebar:: Bit Twiddling Navigation

    .. class:: small

        * parent(i) = i/2 = i >> 1 

        * leftchild(i) = 2*i = i << 1

        * rightchild(i) = 2*i + 1 = (i << 1) + 1

        * leftmost(height)  =  1 << height


.. class:: small

    CSG Tree, leaf node primitives, internal node operators, 4x4 transforms on any node, 
    serialized as :blue:`complete binary tree`:
 
    * bit twiddling navigation :red:`avoids recursion`
    * no need to deserialize
    * no child/parent pointers
    * BUT: very inefficient when unbalanced 

    **Height 3 complete binary tree with level order indices:**
.. raw:: html

    <pre class="mypre">
                                                       depth     elevation

                         1                               0           3   

              10                   11                    1           2   

         100       101        110        111             2           1   
                        
     1000 1001  1010 1011  1100 1101  1110  1111         3           0   
    </pre>
    <hr/>

.. class:: small

    **postorder_next(i,elevation) = i & 1 ? i >> 1 : (i << elevation) + (1 << elevation) ;**   // from pattern of bits
 
.. class:: tiny

   Postorder tree traverse visits all nodes, starting from leftmost, such that children 
   are visited prior to their parents.


:small:`Evaluative CSG intersection Pseudocode : recursion emulated`
-------------------------------------------------------------------------------------------------

.. raw:: html 

    <pre class="mypretiny">
    fullTree = PACK( 1 << height, 1 >> 1 )  // leftmost, parent_of_root(=0) 
    tranche.push(fullTree, ray.tmin) 

    while (!tranche.empty)        <b><span class="alarm"> // stack of begin/end indices </span></b>
    {
        begin, end, tmin <- tranche.pop  ; node <- begin ;
        while( node != end )                  <b><span class="alarm"> // over tranche of postorder traversal </span></b>
        {
            elevation = height - TREE_DEPTH(node) ;
            if(is_primitive(node)){ isect <- intersect_primitive(node, tmin) ;  csg.push(isect) }
            else{
                i_left, i_right = csg.pop, csg.pop          <b><span class="alarm">  // csg stack of intersect normals, t </span></b>
                l_state = CLASSIFY(i_left, ray.direction, tmin)
                r_state = CLASSIFY(i_right, ray.direction, tmin)
                action = LUT(operator(node), leftIsCloser)(l_state, r_state) 

                if(      action is ReturnLeft/Right)     csg.push(i_left or i_right)
                else if( action is LoopLeft/Right)
                {
                    left = 2*node ; right = 2*node + 1 ; 
                    endTranche = PACK( node,  end );
                    leftTranche = PACK(  left << (elevation-1), right << (elevation-1) )
                    rightTranche = PACK(  right << (elevation-1),  node  )
                    loopTranche = action ? leftTranche : rightTranche
                                                     
                    tranche.push(endTranche, tmin)     
                    tranche.push(loopTranche, tminAdvanced ) <b><span class="alarm"> // subtree re-traversal with changed tmin </span></b> 
                    break ; // to next tranche
                }
            }
            node <- postorder_next(node, elevation)        <b><span class="alarm"> // bit twiddling postorder </span></b>
        }
    } 
    isect = csg.pop();       <b><span class="alarm">  // winning intersect  </span></b>
    </pre>

.. class:: tiny

    https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h




:small:`Opticks CSG Primitives : Closed Solids, Consistent Normals`
-------------------------------------------------------------------------------------------------


.. class:: small 

   **Closed Solid** as: :blue:`implementation requires otherside intersect`, **Rigidly attached normals**


.. class:: small 

    ==========================  ===================   ==================
     Type code                   Python name           C++ nnode sub-struct
    ==========================  ===================   ==================
     CSG_BOX3,CSG_BOX            box3,box              nbox
     CSG_SPHERE,CSG_ZSPHERE      sphere,zsphere        nsphere,nzsphere
     CSG_CYLINDER,CSG_DISC       cylinder,disc         ncylinder,ndisc
     CSG_CONE                    cone                  ncone
     CSG_CONVEXPOLYHEDRON        convexpolyhedron      nconvexpolyhedron
     CSG_TRAPEZOID,CSG_SEGMENT   trapezoid,segment     nconvexpolyhedron
    ==========================  ===================   ==================

    
    * **zsphere, cone, cylinder, disc** : truncated shapes **closed** by endcaps :red:`<-- NOT OPTIONAL`

    * **disc** : avoids endcap degeneracy with very thin cylinders

    * **convexpolyhedron** : defined by a set of planes, used for trapezoid and segment

    * **segment** :   prism shape used for deltaphi intersection

    * **!complemented** (inside<->outside) solids handled by 
      special casing classification (cannot miss otherside).


    Non-primitives, :red:`high level CSG definition avoids loadsa code` 

    * **ellipsoid** : non-uniform scaling of sphere,  **polycone** : union of cylinders and cones

    * **inner-radii** : via subtraction, **deltaphi-segment** : via intersect with **segment**



:small:`Opticks CSG Primitives On Parade (GPU raytrace)`
-------------------------------------------------------------------------------------------------

.. image:: /env/presentation/tboolean_parade.png
   :width: 1000px
   :align: center

.. class:: small

   Three on right (Trapezoid, Segment, Icosahedron) all represented by planes with **nconvexpolyhedron** 


:small:`Opticks CSG Serialized into OpticksCSG format (numpy buffers, json)`
-------------------------------------------------------------------------------------------------

.. raw:: html 

    <pre class="mypretiny">
 
    // tboolean-parade

    from opticks.ana.base import opticks_main
    from opticks.analytic.csg import CSG  
            
    args = opticks_main(csgpath="$TMP/$FUNCNAME")

    container = CSG("box", param=[0,0,0,1200], boundary=args.container, poly="MC", nx="20" )

    a = CSG("sphere", param=[0,0,0,100]) 
    b = CSG("zsphere", param=[0,0,0,100], param1=[-50,60,0,0]) 
    c = CSG("box3",param=[100,50,70,0]) 
    d = CSG("box",param=[0,0,10,50])
    e = CSG("cylinder",param=[0,0,0,100], param1=[-100,100,0,0])
    f = CSG("disc",param=[0,0,0,100], param1=[-1,1,0,0])
    g = CSG("cone", param=[100,-100,50,100])
    h = CSG.MakeTrapezoid(z=100, x1=80, y1=100, x2=100, y2=80)
    i = CSG.MakeSegment(phi0=0,phi1=45,sz=100,sr=100)
    j = CSG.MakeIcosahedron(scale=100.)

    prims = [a,b,c,d,e,f,g,h,i,j]

    ...  // setting translations 

    CSG.Serialize([container] + prims, args.csgpath )   <b><span class="alarm">  <-- write trees to file </span></b>
    </pre>

    
.. class:: small

    * imported into C++ **nnode** tree by **NCSG**



:small:`Opticks CSG Primitives : What is included`
-------------------------------------------------------------------------------------------------


.. sidebar:: OptiX Geometry

    .. class:: small 

         OptiX provides acceleration of geometrical intersection, not the intersection itself. 
         
         * parametric ray : **p(t) = p0 + t rayDir**
         * implicit surface : **f(p) = 0** 

         Intersect finding next closest root:

         * smallest **t**, with **t > tmin** 
         * surface normal at **t** 


.. class:: small 
    
    OptiX/CUDA functions providing:

    * axis aligned bounding box (AABB)
    * intersect ray position (parametric t), surface normal 

    C++/nnode sub-struct methods

    * signed distance function (SDF)
    * parametric surface generation 

   

    **4x4 Transforms on any node (translation/rotation/scaling)**

    :blue:`Intersect inverse-transformed ray with un-transformed primitive`

    * parametric-t same in both frames
    * inverse transform transposed brings normal back to world frame


.. class:: tiny

    Supporting non-uniform scaling requires **rayDir** not be be normalized (or assumed to be normalized) by primitives.




:small:`Opticks CSG : Balancing Deep Trees Drastically Improves Performance`
-------------------------------------------------------------------------------------------------

.. sidebar:: Positive form CSG Trees

   .. class:: small

       Apply deMorgan pushing negations down tree 

       * **A - B -> A * !B**
       * **!(A*B) -> !A + !B**
       * **!(A+B) -> !A * !B**
       * **!(A - B) -> !(A*!B) -> !A + B**

       End with only UNION, INTERSECT operators, 
       and some complemented leaves.

       :red:`COMMUTATIVE -> easily rearranged`


.. class:: small

   Intended for solids, not scenes (tree height <8, <256 nodes[*])

   * unbalanced trees inefficiently handled as complete binary trees 
   * CSG trees non-unique, many expressions of same shape

.. raw:: html

    <pre class="mypretiny">
    Dayabay TopESRCutHols lvidx:57  (height:9 totnodes:1023)
    di(di(di(di(di(di(di(di(di(cy,cy),cy),cy),cy),cy),cy),cy),cy),cy)  

                                                                        di    
                                                                 di          cy
                                                         di          cy        
                                                 di          cy                
                                         di          cy                        
                                 di          cy                                
                         di          cy                                        
                 di          cy                                                
         di          cy                                                        
     cy      cy                                         


    Balanced Tree, height:4 totnodes:31  
    in(in(in(in(cy,!cy),in(!cy,!cy)),in(in(!cy,!cy),in(!cy,!cy))),!cy) 

                                                                 in    
                                 in                                 !cy
                 in                              in                    
         in              in              in              in            
     cy     !cy     !cy     !cy     !cy     !cy     !cy     !cy        
    </pre>


.. class:: tiny

   [*] Algorithm has no inherent height limit, but use of complete binary tree imposes practical performance limitation




:small:`Dayabay ESR reflector : Deep CSG tree : disc with 9 holes`
-------------------------------------------------------------------------------------------------

.. image:: /env/presentation/lvidx_57_esr_deep_tree_disc_with_holes.png
   :width: 1000px
   :align: center


:small:`Subtraction of thin CSG_CYLINDER -> speckle in the  hole`
-------------------------------------------------------------------------------------------------

.. class:: small

   CSG_DISC implemented to handle disc like cylinders : intersects at middle (z1+z2)/2 and offsets, :red:`avoids issue`

.. image:: /env/opticks_refs/speckle_lvTopESR.png
   :width: 600px
   :align: left

.. image:: /env/opticks_refs/tboolean_esr_speckle_centered_on_pole_delta_10-3.png
   :width: 500px
   :align: right


:small:`Coincident Faces are Primary Cause of Issues : Fake Intersects`
-------------------------------------------------------------------------------------------------

.. sidebar:: Cylinder - Cone 

    .. class:: small

       Coincident endcaps -> issue 

    .. image:: /env/opticks_refs/lvidx_83_tbool_coincidence_artifact_at_cylinder_base.png
       :width: 450px
       :align: center

    .. class:: small

       Grow subtracted cone downwards, avoids coincidence : **does not change composite solid**

.. class:: small

    Coincidences common (alignment too tempting?). To fix:

    * **A-B** : grow correct dimension of subtracted shape
    * **A+B** : grow smaller interface shape into bigger, making join

    * :red:`case-by-case fixes straightforward, not so easy to automate`
    * WIP: automated coincidence finder/fixer 

    .. image:: /env/opticks_refs/opticks_tscan_29_nzero_5_OcrGdsPrt.png
       :width: 500px
       :align: left





:small:`Signed Distance Functions (SDF) for Primitives and Composites`
--------------------------------------------------------------------------------------------


.. sidebar:: SDF definition

    .. class:: small

         SDF(q(x,y,z) distance to solid surface

         * negative : inside
         * zero : surface
         * positive : outside

         Defined for all primitives, eg:

         Sphere(center,radius) :  **length(q,center) - radius**
         Plane(normal, dist) : **dot(normal,q) - dist** 
     

.. class:: small


    :blue:`SDFs are composable` using R-functions, eg **min** and **max**

    * SDF(Union(A,B)) ~ min(SDF(A),SDB(B))
    * SDF(Intersection(A,B)) ~  max(SDF(A),SDF(B))
    * SDF(Difference(A,B)) ~ max(SDF(A),-SDF(B))
    * SDF(!A) ~ -SDF(A)

    Recursively applicable to CSG trees 

    -> **analytic representation of arbitrary solid**

    :red:`SDFs enable geometry querying/debugging:` 

    * classification of point wrt solid
    * select surface points from primitives
    * obtain bounding box from surface points
    * polygonization by isosurface extraction 
    * fast OpenGL rasterized visualization
 

.. class:: tiny 

     Rvachev-functions (R-functions) : sign uniquely determined by signs of arguments -> parallel CSG operations



:small:`SDF Isosurface Extracted Polgonization Mesh with offset GPU raytrace`
-----------------------------------------------------------------------------------------

.. image:: /env/presentation/tboolean_interlocked_gpuoffset.png
   :width: 1000px
   :align: center



:small:`Translated Solid Debugging : Using py/bash/c++ Code Generation`
-----------------------------------------------------------------------------------------

.. sidebar:: Fast (<10s) Iteration

    .. class:: small

        **gdml2gltf.py** generates for every solid:

        * py code defining **CSG** tree 
        * bash functions : serialize/visualize/raytrace
        * c++ code defining **nnode** tree 

        "Interactively" modify any solids (249 DYB.Near):  

        * primitive parameters
        * CSG operators
        * transforms


.. class:: small

    **NScanTest : Find Problem Solids by SDF Scanning**

    Count SDF zero crossings along scanlines (expect even)

    * odd crossings -> coincidence :red:`false zeros`

    :red:`~5/249 odd solids` : not yet handled by auto-uncoincidence


    **GScene::compareMeshes : Bounding Box comparisons**

    G4Poly(via G4DAE) vs Opticks parsurf (parametric surface)
 
    * :red:`25/249 solids with max bbox dimension discrepancy > 1mm`
    * causes of ~20 not explained by coincidence, presume:

      * G4Poly bugs(*) : some clear missing cylinders from unions
      * parsurf bbox imprecision (very different size sub-objects)

    :blue:`NEXT STEP: direct intersect comparison between Opticks/G4 CSG implementations for definitive answers`


.. class:: tiny

   (*) could also be G4DAE export of G4Poly 



:small:`Full Analytic GDML Geometry Translation Workflow`
-------------------------------------------------------------------------------------------------


.. sidebar:: 3D File Formats

    .. class:: small

        **G4DAE**
            approximate G4 triangulated geometry, includes all material/surface optical properties

        **GDML**
            analytic G4 geometry 

        **"OpticksCSG"**
            numpy buffers of nodes, transforms, planes, json metadata 

        **glTF**
            json node tree referring to OpticksCSG extras for each solid 


.. class:: small

    General CSG ray tracing on GPU allows operation from GDML files


    **gdml2gltf.py  (opticks.analytic.sc)**

    * wraps GDML in python
    * translates G4 solids into OpticksCSG 
    * collects structure into glTF scene tree
    * scene tree refers to OpticksCSG solids as extras
    * writes OpticksCSG for each solid together with glTF to file

    **NScene**

    * loads glTF structure into **nd** scene tree

    **NCSG**

    * loads OpticksCSG into **nnode** trees for each solid

    **GScene/OScene**

    * converts into OptiX GPU buffers  


.. class:: tiny

    glTF : (GL Transmission Format) "JPEG of 3D" : efficient transmission and loading of 3D scenes and models,
    https://www.khronos.org/gltf




:small:`Opticks Analytic Daya Bay Near Site, GPU Raytrace Screenshots`
-------------------------------------------------------------------------

.. class:: small

   GPU Raytrace on following pages are for Daya Near Site Geometry, auto translated from GDML 

   * Looks similar to raytraces shown previously,  BUT: :red:`there is a huge difference`

     * :blue:`No triangles` -> :blue:`No approximation` ->  :blue:`Fully Analytic`
     * :red:`Intersects should match Geant4` (if not its a bug to fix)

   * Opticks CSG code runs for every pixel, picking the intersects

     * significantly slower that the triangulated approach (GPUs love triangles) 
     * very new, no optimization yet  
     * speckle effect is caused by coincident surfaces

   **General Translation Machinery**

   * straightforward to apply to JUNO GDML
   * however : expect every new geometry will yield new issues 
   * lots of geometry debugging tools ready to be used


   **Scene Debugging : NSceneLoadTest** 

   * classify child volume surface points against parent volume SDF (or v.v), 
     look for impingments/coincidences  


    


:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace (3)`
---------------------------------------------------------------------

:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace (1)`
---------------------------------------------------------------------

:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace (0)`
---------------------------------------------------------------------

:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace (2)`
---------------------------------------------------------------------



:small:`July 2017 Summary`
----------------------------------------------

.. sidebar:: Overview

   .. class:: small

      * **Opticks 200x Geant4** with mobile GPU
      * Expect: **Opticks > 1000x Geant4** (with workstation GPUs) 
      * :red:`photon propagation time --> zero`
      * :blue:`automated full fidelity translation of GDML`


.. image:: /env/presentation/1px.png
   :width: 500px
   :height: 50px

..

  *Opticks* enables *Geant4* based simulations to benefit from optical photon simulation 
  **taking effectively zero time and zero CPU memory**, 
  due to massive parallelism made accessible by NVIDIA OptiX.
  :blue:`GDML detector geometry is auto translated into a GPU optimized analytic form, 
  fully equivalent to the source geometry`.

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 20px

  * The more photons the bigger the overall speedup (99% -> 100x) 
  * Drastic speedup -> better detector understanding -> greater precision
  * Large PMT based neutrino experiments, such as JUNO, can benefit the most

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 20px


  .. class:: huge

     https://bitbucket.org/simoncblyth/opticks




:small:`Context Pages`
-------------------------------------------------------

.. class:: large

   * Optical Photon Simulation Problem
   * Ray Traced Image Synthesis ≈ Optical Photon Simulation
   * Open Source Opticks
   * YouTube Video

   For more on Opticks see

  .. class:: huge

     https://bitbucket.org/simoncblyth/opticks




.. class:: tiny


    [1] LLR Workshop, https://simoncblyth.bitbucket.io/env/presentation/opticks_gpu_optical_photon_simulation_nov2016_llr.html 







:small:`Summary from LLR Workshop (Nov 2016)`
----------------------------------------------

.. sidebar:: Overview

   .. class:: small

      * **Opticks 200x Geant4** with mobile GPU
      * Expect: **Opticks > 1000x Geant4** (with workstation GPUs) 
      * :red:`photon propagation time --> zero`
      * :blue:`analytic geometry --> precise Geant4 match`
      
      * **NOTE THE "ANALYTIC" CAVEAT**


.. image:: /env/presentation/1px.png
   :width: 500px
   :height: 50px

..

  *Opticks* enables *Geant4* based simulations to benefit from optical photon simulation 
  **taking effectively zero time and zero CPU memory**, 
  thanks to massive parallelism made accessible by NVIDIA OptiX.

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 20px

  * The more photons the bigger the overall speedup (99% -> 100x) 
  * Drastic speedup -> better detector understanding -> greater precision
  * Large PMT based neutrino experiments, such as JUNO, can benefit the most

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 20px


  .. class:: huge

     https://bitbucket.org/simoncblyth/opticks







:i:`JPMT Before Contact 2`
--------------------------


.. sidebar:: Optical Photon Problem

    .. class:: small
       

         **Cosmic muon backgrounds**
              many millions of optical photons in Daya Bay (more in JUNO)

         * optical propagation dominates *Geant4* CPU time, ~95% for Daya Bay, more for JUNO

         * severe CPU memory constraint

         Optical photons:

         * produced by Cerenkov+Scintillation processes
         * yield only Photomultiplier PMT hits

         Isolated nature -> **easily separated propagation**
         
         **Hybrid Solution Possible : Geant4 + Opticks** 



:small:`Ray Traced Image Synthesis ≈ Optical Photon Simulation`
-------------------------------------------------------------------------------

.. sidebar:: OptiX Pixel Calculation 

    .. image:: /env/optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf

    .. comment

       Not a photo


.. class:: small

    Geometry, light sources, optical physics ->  
      * pixel values at image plane
      * photon parameters at detectors (eg PMTs)

    **Ray tracing has many applications** :
      * advertising, design, entertainment, games,...
      * BUT : most ray tracers just render images


    **NVIDIA OptiX** had foresight to be less specific:
      * general geometry intersection API
      * :red:`OptiX is to ray tracing what OpenGL is to rasterization` 


.. raw:: html

    <pre class="mypre">


    </pre>
 
.. class:: small

    **rasterization**
      project 3D primitives onto 2D image plane, combine fragments into pixel values 

    **ray tracing**
      cast rays thru image pixels into scene, recursively reflect/refract with  
      geometry intersected, combine returns into pixel values  
          




:i:`OpticksDocs`
-------------------------------------------------------------------------------

.. sidebar:: Open Source Opticks

    .. class:: small

        * http://simoncblyth.bitbucket.io/opticks/
        * http://bitbucket.org/simoncblyth/opticks/

        Documentation, install instructions. Repository.

        * Mac, Linux, Windows (*)
        * 18 C++ projects, ordered by dependency
        * ~250 "Unit" Tests (CMake/CTest) 
        * 20 integration tests: tpmt, trainbow, tprism, treflect, tlens, tnewton, tg4gun, ...
        * NumPy/Python analysis/debugging scripts        

        Geometry/event data use NumPy serialization::

             import numpy as np
             a = np.load("photons.npy")

    .. class:: tiny

        (*) Windows VS2015, non-CUDA only so far  



:small:`Debugging Coincident Subtractions`
-------------------------------------------------------------------------------------------------

.. class:: small

   Switching subtraction into union with complemented -> can see whats subtracted.

.. image:: /env/opticks_refs/lvidx_69_ring_box_cuts_artifact.png
   :width: 900px
   :align: center


:i:`YouTube Video`
----------------------

.. raw:: html

   <iframe width="1024" height="576" src="https://www.youtube.com/embed/CBpOha4RzIs?rel=0" frameborder="0" allowfullscreen></iframe>

.. class:: tiny

   https://www.youtube.com/watch?v=CBpOha4RzIs






:small:`Slides Booted to Backup`
-------------------------------------------------------

.. class:: large

   * Various Polygonization Approaches




:small:`Various Polygonization Approaches`
-----------------------------------------------------------------------------------------


.. sidebar:: Polygonization that just works ?

    .. class:: small

        Not a solved problem, problems with some geometry

        * very thin (eg PMT cathode) 
        * combinations of shapes of different scales
          

.. class:: small


    **Several Integrations of Open Source Polygonizations**

    Marching Cubes
         fill bbox with cubes, generate triangles for cubes with sign changes, 
         fixed resolution (**miss features or too many tris**)

    Dual Contouring 
         multiresolution using octree (**slow, finnicky**) 

    Implicit Mesher
         finds and follows surface, fast, fixed resolution, (**needs help in finding**)

    **My own attempt (WIP)**

    Hybrid Mesher
         combining SDF classification with parametric generation, (**complicated mesh joining**)

 




