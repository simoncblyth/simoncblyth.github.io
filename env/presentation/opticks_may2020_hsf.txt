.. comment

   Navigate the HTML slides by entering a page number and pressing return 

.. meta::
   :title: Opticks GPU Optical Simulation with NVIDIA OptiX - Development Experience : Problems and Successes
   :description: HSF

.. include:: my_s5defs.txt


:i:`Opticks Experience of GPU Optical Photon Simulation with NVIDIA OptiX` 
========================================================================================

.. raw:: html


    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey"> 
          <i>Opticks</i> GPU Optical Simulation with NVIDIA® OptiX™ - Development Experience : Problems and Successes
        <h2 style="background-color:lightgrey;text-align:center"> Open source, https://bitbucket.org/simoncblyth/opticks </h2>
    </h1>
    </header>
    </div>

    <div class="mycredit">
    <h2 style="background-color:lightgrey"> Simon C Blyth, IHEP, CAS &mdash; HSF Simulation Working Group Meeting, 27 May 2020</h2>
    </div>


.. s5_talk:: 

    Opticks is an open source project that applies state-of-the-art GPU ray tracing 
    accessed via NVIDIA OptiX to optical photon simulation and integrates this with Geant4. 
    This results in drastic speedups of more than 1000x.

    Any simulation limited by optical photons can remove those limits with Opticks.

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.


.. comment

    .. raw:: html

       <span>&nbsp;</span>


Outline
----------------------------------------------------

.. image:: /env/presentation/newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right


.. class:: small

    * JUNO Optical Photon Simulation Problem...
    * GPU architecture and Ray tracing  

      * CPU vs GPU architectures, Latency vs Throughput
      * Understanding GPU Graphical Origins -> Effective GPU Computation
      * Optical Photon Simulation ≈ Ray Traced Image Rendering
      * Rasterization and Ray tracing
      * Turing Built for RTX, BVH : Bounding Volume Hierarchy 
      * NVIDIA OptiX Ray Tracing Engine

    * Opticks : Translate Geant4 Context to GPU 

      * Geant4 + Opticks Hybrid Workflow : External Optical Photon Simulation
      * Opticks : Translates G4 Optical Physics to CUDA/OptiX
      * G4Solid -> CUDA Intersect Functions for ~10 Primitives
      * G4Boolean -> CUDA/OptiX Intersection Program Implementing CSG
      * Opticks : Translates G4 Geometry to GPU, Without Approximation

    * Validation and Performance

      * Validation of Opticks Simulation by Comparison with Geant4
      * Perfomance Scanning from 1M to 400M Photons

    * Opticks Experience : Problems and Successes

      * Main Operational Problem : Manpower 
      * Main Technical Problem : Geometry Translation
      * Further Problems with using NVIDIA OptiX
      * Benefits from using NVIDIA OptiX

    * Overview + Links 

    .. raw:: html
 
       <hr/>


.. s5_talk::

   After quickly describing the background and what Opticks does, 
   I will review the main problems and the successes from its development.



`JUNO Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <pre>







     </pre>

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


.. s5_talk::

   Muons travelling across the liquid scintillator will yield
   many tens of millions of optical photons. 
   This is a huge memory and time challenge for JUNO simulation.

   Most of the time is taken finding intersections between photons and geometry.
   Fortunately simulation is not alone in this bottleneck.

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation 
   and we are only interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 

.. comment

   OpenGL/CUDA interoperation, using VBOs



:small:`CPU vs GPU architectures, Latency vs Throughput`
------------------------------------------------------------

.. class:: small

    .. image:: /env/presentation/nvidia/cpu_vs_gpu_architecture.png
       :width: 800px
       :align: center

.. class:: small

   Waiting for memory read/write, is major source of latency...

   **CPU : latency-oriented : Minimize time to complete single task** : :red:`avoid latency with caching` 
       * complex : caching system, branch prediction, speculative execution, ...

   **GPU : throughput-oriented : Maximize total work per unit time** : :red:`hide latency with parallelism` 
       * many simple processing cores, hardware multithreading, SIMD (single instruction multiple data)
       * simpler : :green:`lots of compute (ALU)`, at expense of cache+control
       * design assumes :red:`abundant parallelism`

   Effective use of **Totally different processor architecture** -> :red:`Total reorganization of data and computation`  
       

.. class:: tiny

    Understanding Throughput-oriented Architectures
    https://cacm.acm.org/magazines/2010/11/100622-understanding-throughput-oriented-architectures/fulltext

.. s5_talk::

   SMALL

   * everyone is familiar with this latency vs throughput difference.  
   * the crucial thing is that the parallelism of the task is the founding "assumption" of the design of GPUs 

   **Many dont realize quite how extremely parallel you can and should go**

   * i am not just talking a few thousand threads here, millions is better
   * the largest launch I have done is 400M threads limited by VRAM 
   * best way to really experience this is to develop graphics applications 
   * they really do run billions of small shader programs per second

   I recall my first experience of the visualization 
   performance of triangulated DayaBay geometry  
   drawn with a single OpenGL draw call, using a single VBO (vertex buffer object).
   It was shockingly smooth.
   
   What is perhaps not so commonly experienced is how extremely parallel  
   tasks need to be to make best use of the GPU. 

.. comment

   Latency hiding works using hardware multi-threading, so when one group of threads is blocked
   waiting to read from global memory for example : other groups of thread and be resumed. This 
   is only effective at hiding latency when there are enough other threads in flight at the same time.

   Porting CPU code to run on the GPU : is not a straightforward thing to do, because the archirecture is totally 
   different.  To make effective use of GPUs requires a total reorganization of data and compute. 


:small:`Understanding GPU Graphical Origins -> Effective GPU Computation` 
---------------------------------------------------------------------------------

.. sidebar:: :small:`OpenGL Rasterization Pipeline`

    .. image:: /env/presentation/opengl/rasterization_pipeline_rhs.png
       :width: 450px
       :align: right


.. class:: small

    **GPUs evolved to rasterize 3D graphics at 30/60 fps** 

    * 30/60 "launches" per second, each handling millions of items 
    * :red:`literally billions of small "shader" programs run per second`   
   
    **Simple Array Data Structures (N-million,4)**

    * millions of vertices, millions of triangles 
    * vertex: **(x y z w)**  
    * colors: **(r g b a)** 
    
    **Constant "Uniform" 4x4 matrices : scaling+rotation+translation**

    * 4-component homogeneous coordinates -> easy projection

    **Graphical Experience Informs Fast Computation on GPUs**

    * array shapes similar to graphics ones are faster

      * "float4" 4*float(32bit) = 128 bit memory reads are favored 
      * Opticks photons use "float4x4" just like 4x4 matrices

    * GPU Launch frequency < ~30/60 per second   

      * avoid copy+launch overheads becoming significant
      * ideally : handle millions of items in each launch 


.. s5_talk::

    Rasterization is the process of going from input 3D vertices 
    which are collections of 4 floats to pixel values. 

    **GPUs evolved to rasterize**

    When using GPUs you should keep these origins in mind. 

    * for example, copying or operating on float4s 4*32bits is faster that *float3* 
      128bits are better for alignment reasons 

    * graphics pipeline is based around 4x4 matrices 
      and 4 component homogeneous coordinates
 
    * graphics updates at something like 30/60 frames per second : so do not expect 
      to do thousands of launches per second, each launch has an overhead

    * performance is gained by doing more in each launch  




:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: Not a Photo, a Calculation

    .. image:: /env/optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :blue:`simulation` : photon parameters at PMT detectors 
    * :blue:`rendering` : pixel values at image plane
    * :red:`both limited by ray geometry intersection, aka ray tracing`


.. raw:: html

    <pre>

    </pre>

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


.. s5_talk::

    There is much in common between optical simulation and rendering images.

    With simulation you need photon parameters at PMTs, with rendering 
    you need pixel values at the image plane.

    Both are limited by ray geometry intersection or ray tracing.

    As the best way to create realistic images, ray tracing is used across many industries, 
    which means there have been huge efforts
    across many decades to improve ray tracing perfromance.
    



:i:`Ray-tracing vs Rasterization`
-----------------------------------

.. image:: /env/presentation/nvidia/nv_rasterization.png
   :width: 550px
   :align: left

.. image:: /env/presentation/nvidia/nv_raytrace.png
   :width: 550px
   :align: right


.. s5_talk::

   It is good to clarify the difference between 
   the two primary graphics rendering techniques 

   Rasterization, which is the most common rendering technique
   
   * starts from the objects in a scene, and projects them onto pixels in image plane
   * this uses approximated triangulated geometry   
   
   Ray tracing 

   * starts from the pixels, casts rays out into the 3D scene and finds intersects
   * this can use analytic geometry, without approximation (just like Geant4)   
   * its easier to create realistic images with ray tracing because its closer to the physics

.. comment

   https://www.youtube.com/watch?v=Mrixi27G9yM
   RTX Launch







:i:`TURING BUILT FOR RTX 2`
---------------------------------------------------------


.. raw:: html

    <pre>






    </pre>

.. sidebar:: :small:`Offload Ray Trace to Dedicated HW`

    .. class:: small

        * RT core : BVH traversal + ray tri. intersection
        * frees up general purpose SM 

    .. class:: tiny

        SM : Streaming Multiprocessor

        BVH : Bounding Volume Hierarchy


.. s5_talk::

    Some recent NVIDIA GPUs have hardware RT cores that are dedicated to ray tracing.   

    * up to 10x speedup is claimed
    * what you get in practice depends on the geometry and the BVH acceleration structure
    * with Opticks and JUNO analytic geometry I see speedup factors of about 5x 

    The performance is gained by offloading ray tracing from the general purpose SM 
    (streaming multiprocessor) to the fixed function RT core, freeing up the SM.
 



``Spatial Index Acceleration Structure``
---------------------------------------------------


.. raw:: html

    <pre>











    </pre>

.. sidebar:: :small:`Tree of Bounding Boxes (bbox)`

    .. class:: small

        * aims to minimize bbox+primitive intersects 
        * accelerates ray-geometry intersection


.. s5_talk::

   The principal technique to accelerate ray geometry intersection 
   is an acceleration structure called a bounding volume hierarchy, or BVH.
   
   This divides space into a spatial index of progressively smaller boxes

   Traversing the tree of bounds allows to minimize the intersection tests
   needed to find the intersect.

   Traversal of the acceleration structure and ray box intersection tests
   that determine the traversal can both be done in the dedicated hardware. 

   The details of the BVH are NVIDIA proprietry information : so 
   optimization is by blind experimentation.  



:small:`NVIDIA® OptiX™ Ray Tracing Engine -- http://developer.nvidia.com/optix`
--------------------------------------------------------------------------------

.. sidebar:: OptiX Raytracing Pipeline

    .. class:: small

       Analogous to OpenGL rasterization pipeline:

    .. image:: /env/optix/docs/optix-model.png
       :width: 450px
       :align: right

.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * **accelerates** ray-geometry intersections
   * simple : single-ray programming model
   * "...free to use within any application..."
   * :red:`access RT Cores[1] with OptiX 6.0.0+ via RTX™ mode`

   **NVIDIA expertise:**

   * compiler optimized for GPU ray tracing
   * :red:`~linear scaling up to 4 GPUs`
   * acceleration structure creation + traversal (Blue)
   * instanced sharing of geometry + acceleration structures


.. class:: small

   **Opticks provides (Yellow):**

   * ray generation program
   * :red:`ray geometry intersection+bbox programs` 


.. class:: tiny

   [1] Turing RTX GPUs


.. s5_talk::

   * NVIDIA OptiX is a ray tracing specific compiler, it combines
     user programs for ray generation and geometry with NVIDIA programs 
     for acceleration structure traversal into a GPU pipeline which is 
     launched onto the GPU 

   * OptiX just accelerates ray-geometry interection... it doesnt provide the intersection 

   * the bulk of Opticks on the GPU is in the ray generation and intersection programs 


.. skip

   * no need for fancy shading, so closest hit is simple, just collecting the normal 
     and ray trace distance 

  * creating renderers is the most common use of OptiX, but it is a general 
     intersection API so works fine to do simulation   
  


:i:`Geant4OpticksWorkflow`
----------------------------

.. s5_talk::

    SMALL
    So : how can an external optical photon simulation be integrated with Geant4 ?

    In the standard workflow the Geant4 Scintillation and 
    Cerenkov processes calculate a number of photons 
    and then loop generating these and collecting them 
    as secondaries.
     
    In the hybrid workflow, this generation is split 
    between the CPU and GPU with "Gensteps" acting as the bridge. 
    These Genstep parameters include the number of photons, positions and everything 
    else needed in the generation loop.

    The gensteps allow a very simple direct port of the generation loop to the GPU. 

    Its doubly helpful to generate photons on GPU, as then they take no CPU memory. 
  
    So can entirely offload photon memory to the GPU with only hits needing CPU memory. 

    Also this keeps the overheads low as gensteps are typically a factor of 100 smaller
    than the photons they generate.   
 
    **The geometry is also needed on the GPU, with all material and surface properties.**

    :red:`Geometry translation is most of the work and problems of Opticks.`

     


:small:`Opticks : Translates G4 Optical Physics to CUDA/OptiX`
----------------------------------------------------------------


.. sidebar:: GPU Resident Photons

    .. class:: small

       **Seeded on GPU** 
          associate photons -> *gensteps* (via seed buffer)
 
       **Generated on GPU, using genstep param:**
         * number of photons to generate
         * start/end position of step

       **Propagated on GPU**
          :red:`Only photons hitting PMTs copied to CPU`


       Thrust: **high level C++ access to CUDA**

       .. figure:: /env/numerics/thrust/thrust.png
          :width: 300px
          :align: right

       * https://developer.nvidia.com/Thrust
       
          

         
.. class:: small

    :blue:`OptiX : single-ray programming model` -> line-by-line translation

    **CUDA Ports of Geant4 classes**
      * G4Cerenkov (only generation loop) 
      * G4Scintillation (only generation loop) 
      * G4OpAbsorption
      * G4OpRayleigh 
      * G4OpBoundaryProcess (only a few surface types)

    **Modify Cherenkov + Scintillation Processes**
      * collect *genstep*, copy to GPU for generation
      * :red:`avoids copying millions of photons to GPU`

    **Scintillator Reemission**
      * fraction of bulk absorbed "reborn" within same thread
      * wavelength generated by reemission texture lookup

    **Opticks (OptiX/Thrust GPU interoperation)** 
      * **OptiX** : upload gensteps 
      * **Thrust** : seeding, distribute genstep indices to photons
      * **OptiX** : launch photon generation and propagation
      * **Thrust** : pullback photons that hit PMTs 
      * **Thrust** : index photon step sequences (optional)



.. s5_talk:: 

    This repeats what I just explained on the diagram

    * essentially the necessary Geant4 optical physics is ported to CUDA

.. skip

    Some further detail is on the reemissio and also 
    use of CUDA Thrust : which provides a higher level way 
    of using CUDA 





:small:`G4Solid -> CUDA Intersect Functions for ~10 Primitives`
-------------------------------------------------------------------------------------------------

.. class:: small

   * 3D parametric ray : **ray(x,y,z;t) = rayOrigin  +  t * rayDirection** 
   * implicit equation of primitive : **f(x,y,z) = 0**  
   * -> polynomial in **t** , roots: **t > t_min**  -> intersection positions + surface normals

.. figure:: /env/presentation/tboolean_parade_sep2017.png
   :width: 900px
   :align: center

   Sphere, Cylinder, Disc, Cone, Convex Polyhedron, Hyperboloid, :red:`Torus`, ...


.. s5_talk::

   NVIDIA OptiX doesnt provide primitives 

   * start by implementing primitive shape functions

   Opticks provides ray geometry intersection for these shapes.








:small:`G4Boolean -> CUDA/OptiX Intersection Program Implementing CSG`
-------------------------------------------------------------------------------------

.. sidebar:: Outside/Inside Unions

    .. class:: small

       dot(normal,rayDir) -> Enter/Exit

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_outside.png
       :width: 300px
       :align: center

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_inside.png
       :width: 300px
       :align: center

    .. class:: small

        * **A + B** boundary not inside other 
        * **A * B** boundary inside other 


.. class:: small

   Complete Binary Tree, pick between pairs of nearest intersects:

   =======================  ===========  ===============  ============== 
   *UNION* tA < tB           Enter B      Exit B           Miss B
   =======================  ===========  ===============  ============== 
   **Enter A**               ReturnA      :blue:`LoopA`    ReturnA
   **Exit A**                ReturnA      ReturnB          ReturnA 
   **Miss A**                ReturnB      ReturnB          ReturnMiss
   =======================  ===========  ===============  ============== 

   * *Nearest hit intersect algorithm* [1] avoids state

     * sometimes :blue:`Loop` : advance **t_min** , re-intersect both 
     * classification shows if inside/outside

   * *Evaluative* [2] implementation emulates recursion: 

     * :red:`recursion not allowed` in OptiX intersect programs
     * bit twiddle traversal of complete binary tree 
     * stacks of postorder slices and intersects 

   * :red:`Identical geometry to Geant4` 

     * solving the same polynomials 
     * near perfect intersection match



.. class:: tiny

    [1] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
        with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
 
    [2] https://bitbucket.org/simoncblyth/opticks/src/master/optixrap/cu/csg_intersect_boolean.h
        Similar to binary expression tree evaluation using postorder traverse. 


.. s5_talk::

    The primitives can be combined using constructive solid geometry 
    modelling into arbitrarily complex shapes. 

    CSG implementation uses a recursive algorithm that picks between 
    intersects at each level of the tree with look up tables.
    It is implemented without using recursion, as thats not allowed
    in OptiX intersects.

    This CSG implementation is what allows general G4Boolean solids 
    to be translated into Opticks solids without any approximation.
 



:small:`CSG Complete Binary Tree Serialization -> simplifies GPU side`
---------------------------------------------------------------------------------

.. sidebar:: Bit Twiddling Navigation

    .. class:: small

        * parent(i) = i/2 = i >> 1 

        * leftchild(i) = 2*i = i << 1

        * rightchild(i) = 2*i + 1 = (i << 1) + 1

        * leftmost(height)  =  1 << height


.. class:: small

    Geant4 solid -> CSG binary tree (leaf primitives, non-leaf operators, 4x4 transforms on any node)

    Serialize to **complete binary tree** buffer:
 
    * no need to deserialize, no child/parent pointers
    * bit twiddling navigation :red:`avoids recursion`
    * simple approach profits from small size of binary trees 
    * BUT: very inefficient when unbalanced 

    **Height 3 complete binary tree with level order indices:**
.. raw:: html

    <pre class="mypre">
                                                       depth     elevation

                         1                               0           3   

              10                   11                    1           2   

         100       101        110        111             2           1   
                        
     1000 1001  1010 1011  1100 1101  1110  1111         3           0   
    </pre>
    <hr/>

.. class:: small

    **postorder_next(i,elevation) = i & 1 ? i >> 1 : (i << elevation) + (1 << elevation) ;**   // from pattern of bits
 
.. class:: tiny

   Postorder tree traverse visits all nodes, starting from leftmost, such that children 
   are visited prior to their parents.


.. s5_talk::

    CSG implementation is greatly simplified by 
    use of complete binary tree serialization.  

    Boolean solids with large numbers of constituents cause a 
    problem, because complete binary tree serialization is
    very inefficient for unbalanced trees.

    Tree balancing helps, but still there is a complexity limit.
    G4Boolean abuse solids with hundreds of constituents would be 
    better implemented with custom primitives.





:small:`Opticks : Translates G4 Geometry to GPU, Without Approximation`
------------------------------------------------------------------------------------

.. sidebar:: :small:`Materials/Surfaces -> GPU Texture` 

    .. class:: small

      **Material/Surface/Scintillator properties**

      * interpolated to standard wavelength domain
      * interleaved into "boundary" texture  
      * "reemission" texture for wavelength generation 

      **Material/surface boundary : 4 indices**

      * outer material (parent)
      * outer surface (inward photons, parent -> self)
      * inner surface (outward photons, self -> parent)
      * inner material (self)

      Primitives labelled with unique boundary index

      * ray primitive intersection -> boundary index
      * texture lookup -> material/surface properties

      :red:`simple/fast properties + reemission wavelength`


.. class:: small

    **G4 Structure Tree -> Instance+Global Arrays -> OptiX**

    Group structure into repeated instances + global remainder:

    * auto-identify repeated geometry with "progeny digests"  

      * JUNO : 5 distinct instances + 1 global  

    * instance transforms used in OptiX/OpenGL geometry 

    :red:`instancing -> huge memory savings for JUNO PMTs`




.. raw:: html

    <pre>
    </pre>


.. comment

    **Automated : Geant4 "World" -> Opticks CSG -> CUDA/OptiX**

    **Solids : analytic CSG + triangulated**

    * intersection functions for ~10 primitives
    * intersection program for arbitrarily complex CSG shapes 
     
      * :red:`automated : G4 -> Opticks -> OptiX`  


.. s5_talk::


   Translation of geometry structure starts by 
   identifying repeated geometry and its transforms using 
   geometry tree digests for every node.

   Use of instancing is a huge memory saving for JUNO geometry 
   with many thousands of PMTs.

   And everything needs to be serialized to be copied to the GPU.
     


:i:`j1808_top_rtx`
--------------------

.. s5_talk::

   The upshot is that full Geant4 detector geometries
   can be automatically translated into NVIDIA OptiX geometries.

   This is an OptiX ray trace image from the chimney region at the 
   top of the JUNO scintillator sphere.
    

:i:`j1808_top_ogl`
--------------------

.. s5_talk::

   This is an OpenGL rasterized image, using the approximate triangulated 
   geometry. Opticks manages analytic and triangulated geometry together.  




:small:`Validation of Opticks Simulation by Comparison with Geant4`  
--------------------------------------------------------------------


.. sidebar:: :small:`Random Aligned Bi-Simulation`

    .. class:: small

        Same inputs to *Opticks* and *Geant4*:

        * CPU generated photons 
        * GPU generated randoms, fed to *Geant4*

        Common recording into *OpticksEvents*:

        * compressed photon step record, up to 16 steps
        * persisted as *NumPy* arrays for python analysis   

        Aligned random consumption, direct comparison:

        * ~every **scatter, absorb, reflect, transmit** 
          at matched positions, times, polarization, wavlen



.. class:: small


   **Bi-simulations of all JUNO solids, with millions of photons**

   mis-aligned histories
       mostly < 0.25%, < 0.50% for largest solids    
       
   deviant photons within matched history
       < 0.05% (500/1M) 
 
   **Primary sources of problems**

   * grazing incidence, edge skimmers
   * incidence at constituent solid boundaries 


   **Primary cause : float vs double** 
      
   *Geant4* uses *double* everywhere, *Opticks* only sparingly (observed *double* costing 10x slowdown with RTX) 

   **Conclude** 

   * :blue:`neatly oriented photons more prone to issues than realistic ones`
   * perfect "technical" matching not feasible
   * instead shift validation to more realistic full detector "calibration" situation    


.. s5_talk::

   Aligned bi-simulation very efficiently finds discrepancies. Because it 
   is a direct comparison unclouded by statistical variation : so issues show up 
   very clearly.   

   Comparing individual solids shows discrepancies at the fraction of a percent level.

   Main cause is float vs double. 


:i:`scan-pf-check-GUI-TO-SC-BT5-SD`
--------------------------------------

.. s5_talk::

   This GUI allows interactive selection between tens of millions 
   of photons based on their histories.  

   This render selects only photons that scattered once and then 
   boundary transmits straight through to surface detect.

   It is implemented by indexing the photon histories using 
   very fast GPU big integer sorting provided by CUDA Thrust, 
   and OpenGL shaders to switch between selections.

   The 64-bit integers hold up to 16 4-bit flags for each step of the photon.

   The GUI uses interoperation capabilities of OpenGL/CUDA/Thrust/OptiX
   so GPU buffers can be written to and rendered inplace with no copying.



:i:`scan-pf-check-GUI-TO-BT5-SD`
----------------------------------

.. s5_talk::

   The GUI also provides interactive time scrubbing of the propagation 
   of tens of millions of photons. 

   This is some nanoseconds later for a different history category. 
  
   I created this GUI to help with debugging the simulation. 




.. comment

     * DELL Precision 7920T Workstation
     * Intel Xeon Silver 4114, 2.2GHz, 40 cores, 65G 
     * NVIDIA Quadro RTX 8000, 48G 

     * DELL Precision 7920T Workstation
     * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 65G  
     * NVIDIA TITAN RTX, 24G
     * NVIDIA TITAN V, 12G


:small:`Performance : Scanning from 1M to 400M Photons`  
---------------------------------------------------------------

.. sidebar:: :small:`Test Hardware + Software`

     .. class:: small

         **Workstation**

         * DELL Precision 7920T Workstation
         * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 62G  
         * NVIDIA Quadro RTX 8000 (48G) 
    
         **Software**

         * Opticks 0.0.0 Alpha 
         * Geant4 10.4p2 
         * NVIDIA OptiX 6.5.0
         * NVIDIA Driver 435.21
         * CUDA 10.1

         **IHEP GPU Cluster**

         * 10 nodes of 8x NVIDIA Tesla GV100 (32G) 




.. class:: small

     **Full JUNO Analytic Geometry j1808v5**

     * "calibration source" genstep at center of scintillator

     **Production Mode : does the minimum**

     * only saves hits  
     * skips : genstep, photon, source, record, sequence, index, ..
     * no *Geant4* propagation (other than at 1M for extrapolation)

     **Multi-Event Running, Measure:**

     :red:`interval` 
       avg time between successive launches, including overheads:
       (upload gensteps + :blue:`launch` + download hits)

     :blue:`launch` 
       avg of 10 OptiX launches


     * overheads < 10% beyond 20M photons



.. s5_talk::

   Emitting millions of photons from the center of the scintillator 
   and timing the interval and launch times of the propagation 
   provides a measure of the performance of a geometry.
   
   By interval, I mean the time between suceessive launches : so this 
   covers all the overheads of copying the gensteps to the GPU and 
   pulling back the hits to the CPU.

   Overheads are less than 10%    



.. comment

    .. sidebar:: :small:`Genstep/Hit Copying Overheads`

         .. class:: small

             **launch**
               time of each OptiX launch (avg of 10)

             **interval, including overhead**
               time between subsequent launches (avg of 9)

             :red:`Mostly < 10% Overhead beyond 20M photons`






``NVIDIA Quadro RTX 8000 (48G)``
----------------------------------

.. raw:: html

   <div class="mysidebar" style="position: absolute; top:15%; left:65%; width:22%; height:10% ;" >
      <strong> 谢谢 NVIDIA China <br> for loaning the card </strong>
   </div>


.. s5_talk::

   The GPU used for these tests is the Quadro RTX 8000 with 48GB VRAM.

   Xie-xie to NVIDIA China for loaning the card.  



.. comment

   update these profilesmry.py plots with::

       scan-plot     ## on workstation    
       scan-pub      ## on laptop with simoncblyth.bitbucket.org clone
       scan-pubrst   ## prepare RST for inclusion at tail 


:i:`scan-pf-1_NHit`
---------------------

.. raw:: html

     <pre>








     </pre>


.. sidebar:: :small:`Photon Launch Size : VRAM Limited`

     .. class:: small


         **NVIDIA Quadro RTX 8000 (48 GB)**

         * photon 4*4 floats : 64 bytes
         * curandState       : 48 bytes 

         **400M photons** x :blue:`112 bytes` ~ 45G  



.. s5_talk::

    The first check is that you get the expected number of hits 
    as a function of the number of photons.

    The photon parameters takes 64 bytes and curandState takes 48 bytes
     
    So thats 112 bytes per photon, so the limit on the number 
    of photons that can be simulated in a single launch with this 48G 
    GPU is a bit more than 400M.


 






:i:`scan-pf-1_Opticks_vs_Geant4 2`
------------------------------------

.. raw:: html

    <pre>
   


 
    </pre>


.. class:: small

    .. table:: 
        :align: center

        +--------------------+----------------------------+------------------+
        | JUNO analytic, 400M photons from center         |  Speedup         |
        +====================+============================+==================+
        | Geant4 Extrap.     | 95,600 s (26 hrs)          |                  | 
        +--------------------+----------------------------+------------------+
        | Opticks RTX ON (i) | 58 s                       |   1650x          |
        +--------------------+----------------------------+------------------+


.. s5_talk::

   This compares the extrapolated Geant4 propagation time with the Opticks launch
   interval with RTX on.   The speedup is more than a factor of 1000.   Need to 
   use a log scale to make them both visible. 

   For 400M photons, Geant4 takes more than a day, Opticks takes less than a minute.   

   This is with analytic geometry. Speedup is a lot more with triangles.



:i:`scan-pf-1_Opticks_Speedup 2`
---------------------------------

.. raw:: html
  
     <pre>









     </pre>

.. class:: small

     .. table:: 
        :align: center

        +-------------------------+------------------+------------------+
        | JUNO analytic, 400M photons from center    |   Speedup        |
        +=========================+==================+==================+
        | Opticks RTX ON (i)      | 58s              |   1650x          |
        +-------------------------+------------------+------------------+
        | Opticks RTX OFF (i)     | 275s             |   350x           |
        +-------------------------+------------------+------------------+
        | Geant4 Extrap.          | 95,600s (26 hrs) |                  |
        +-------------------------+------------------+------------------+


.. s5_talk::

    This is the same information shown as a ratio.



:i:`scan-pf-1_RTX_Speedup`
---------------------------------


.. raw:: html
  
     <pre>











     </pre>

    
.. table:: 
   :align: center

   +-----------------------------------------------------+
   | **5x Speedup from RTX with JUNO analytic geometry** |
   +-----------------------------------------------------+


.. s5_talk::

    Comparing RTX mode OFF to ON shows that the
    hardware ray tracing is giving a factor of 5.






:small:`Opticks Experience : Main Operational Problem : Manpower`
----------------------------------------------------------------------

.. sidebar:: :small:`Atypical Experience Needed`

    .. class:: small

        * :red:`difficult for students/postdocs to help` 
        * :blue:`Opticks is a one person project` 

        **Typical NVIDIA OptiX Users:**

        * **software company teams** building commercial renderers for design/architecture/visual-effects 
        * experienced graphics developers 
        * Windows workstations 

        **Typical Opticks Users (Candidate Devs):**

        * neutrino and dark matter search experiments  
          with 0-0.25 FTE trying to improve Geant4 simulation performance
        * no graphics experience, little GPU experience
        * Linux servers

.. class:: small

   :red:`Lots of interest, very little contribution, why ?`

   **Tool Innovation is Disincentivized ?**

   * students/postdocs interested in Opticks
   * advisors steer them to analysis : less risky, better for career 

   **Why GPU simulation development difficult ?**

   * totally different geometry model 

     * :strike:`tree of C++ objects` -> arrays, textures 
     * :strike:`solid primitives` -> intersection by solving polynomials

   * totally different development model 

     * :strike:`complex libraries` -> simple headers
     * simpler -> smaller stack -> more threads in flight  
     * low level CUDA development, eg CSG from first principals 
     * very few libs 
     * restricted CUDA environment 

       * no recursion in intersect
       * no shared memory/synchronizations/barriers
       * double precision problematic, performance hit


.. s5_talk::

    **The biggest problem with Opticks development is that there is only me doing it.**  

    * survival of Opticks depends on solving this problem 

    **Why is that ?**

    * systemic issue 

      * software innovation is dis-incentivised 
      * expts want software, without expending resources    

    * There is lots of interest, but very little contribution

    * Restricted CUDA environment gives the OptiX runtime flexibility to move tasks around 
      (to different lane/thread, warp or streaming multiprocessor)
      
    * Even allowing some aspects of the workflow to be moved into hardware, depending on the GPU in use.



:small:`Opticks Experience : Main Technical Problem : Geometry Translation`
-------------------------------------------------------------------------------
         
.. skip

  * meshes can leak when shoot millions of rays at cracks


.. sidebar:: :small:`Approximate Triangulated geometry`

   .. class:: small

       **GPUs love triangles, BUT polygonization not easy**

       * G4Polyhedron issue (black box code)

         * polycones yield cleaved meshes 
         * just visualization issue for Geant4 
         * but breaks the geometry 

       * Opticks(OpenMesh) fixes meshes, BUT fragile 

       * Failed to find/develop better polygonization 
       * Triangulation too approximate for PMTs 
       * Approx. tris : limits Opticks-Geant4 matching  


.. class:: small

   **Intersection Performance -> Simulation Performance, Drivers:**

   * acceleration structure (AS) eg BVH 
   * geometry model input to AS

   **Analytic Geometry : translate volume -> surface based model**

   Coincident faces (even in CSG boolean constituents)

   * very common problem, causes spurious intersects 

     * manual modelling changes : avoiding coincidence 

   * CSG serialized using complete binary tree

     * simple+convenient, :red:`very inefficient for unbalanced trees`
     * balancing enables support for more complex trees
     * v.complicated solids (G4Boolean abuse) still problematic

   **Analytic Torus Intersection**

   * double precision quartic root solving
   * very large coefficient range, robust solution difficult 

     * many techniques tried (numerical/computer science papers) 

   * very heavy kernel : 10x performance impact even when unused
   * pragmatic solution : avoid torus, or use triangulated    




.. comment geometry cons

    Large geometry problems : instancing required for limited VRAM

    Geometry Changes needed to avoid problems in translation to GPU

    double heavy quartic root code (for torus intersection) too difficult 

    bounding boxes that touch geometry cause leaks, slightly enlarging the boxes avoids leak (<1 in 3M)

    surface vs volume representation of geometry : coincident faces, model translation 

    Coincident boundaries do not work in surface representation 

    speckle in the hole problems : fake intersects from CSG constituent coincident faces

    thin cylinder endcap degeneracy (eg mirrors DYB ESR) : solved via dedicated disc primitive 



.. s5_talk::

    Most of the effort and code of Opticks handles geometry 
    translation. Optical physics directly translated into 
    CUDA code. 



:small:`Opticks Experience : Problems with using NVIDIA OptiX`
------------------------------------------------------------------------

.. sidebar:: :small:`NVIDIA OptiX 7 : Entirely new API`

    .. class:: small

        * introduced August 2019
        * low-level CUDA-centric thin API (Vulkan-ized)
        * :strike:`near perfect scaling to 4 GPUs, for free` 
        * Major effort needed to support in Opticks

.. class:: small

   * NVIDIA GPUs only 
   * No influence on direction of NVIDIA OptiX (eg OptiX 7)
   * immature OptiX support for Linux debug/profiling

     * most OptiX users develop on Windows ?
     * cuda-gdb not to level of Nsight VSE

   **Optimization Issues**

   * difficult to approach 10 GigaRays/s 
   * closed source : black box BVH 

     * blind experimentation 

   **Linux GPU Cluster (eg Tesla V100) Deployment Issues**

   * OptiX releases demand lastest **short lived branch** driver
   * GPU clusters typically use **long lived branch** drivers

     * drivers appropriate for OptiX slow to appear 
     * must use older OptiX release for many months

   * RTX performance, RT cores ~not available in server GPUs[1,2] 

     * 4 non-RTX GPUs ~ single RTX GPU performance

   * https://www.nvidia.com/en-us/design-visualization/quadro-data-center/


.. class:: tiny

   [1] NVIDIA RTX Server with 8x NVIDIA Quadro RTX 8000 : probably restricted to car, design, film companies ...
   [2] NVIDIA Quadro RTX 8000 PCIe Server Card (Passive)


.. s5_talk::


   Being a very atypical NVIDIA OptiX user brings problems, 
   but the benefits are so huge for optical photon simulation that 
   its worthwhile to cope with them.

   OTT : NVIDIA RTX Server : 8x Quadro RTX 8000 






.. comment

    :small:`cuRAND : CUDA random number generation library`
    -------------------------------------------------------------------------------

    .. class:: small

        * stack size needed to initialize cuRAND kills performance (> 10x)
        * split initialization into separate CUDA launch and persist cuRAND state to file 
        * loading+uploading this state to GPU at setup of OptiX context allows
          cuRAND to be used without the performance killing stack size      






:small:`Opticks Experience : Benefits from using NVIDIA OptiX`
------------------------------------------------------------------------

.. sidebar:: :small:`State-of-the-art GPU ray tracing`

   .. class:: small

       **OptiX makes this performance accessible**

       * drastic performance factors > 1000x Geant4 
       * GPU offloading 

         * eliminates memory, time bottlenecks

       * substantial improvements with each release 
       * benefit from new GPU features  


.. class:: small

   **NVIDIA OptiX 3,4,5,6** 

   * excellent easy to use API 
   * useful shared host/device context 
   * flexible geometry : implement intersection code 
   * :red:`automated acceleration structure (AS) building/traversal` 
   * instancing of geometry + AS, essential for JUNO PMTs 
   * transparent ~linear scaling up to 4 GPUs  
   * graphics interop buffer sharing CUDA/Thrust/OptiX/OpenGL 

     * in-situ visualization with no data movement 

   * straightforward port of Geant4 optical physics

   **NVIDIA OptiX 6** 

   * accelerated with ray trace dedicated hardware (RT Cores) 

     * 5x performance from RTX 

   **1 or 2 Releases per Year**

   * until OptiX 7, fairly compatible API changes 
   * tuning for new GPUs 




.. s5_talk::

    State-of-the-art GPU ray tracing, with a fairly stable API (until 7)
    and not need to tune for each new GPU family 



.. comment 

    key features https://developer.nvidia.com/designworks/optix/download
 
    Programmable GPU-accelerated Ray-Tracing Pipeline

    Single-ray shader programming model using C++

    Optimized for current and future generations of NVIDIA GPU architectures


    **pros**

    OptiX : Higher level API than pure CUDA : shared host/device context system

    Opticks integrates Geant4 simulations with state-of-the-art NVIDIA OptiX GPU ray tracing

    Opticks aims to replace Geant4 optical photon propagation with an equivalent and drastically faster GPU implementation.

    graphics compute interop : CUDA/Thrust/OptiX/OpenGL all sharing buffers 

    Shockingly Fast/Smooth graphics : single VBO : from model shift : smooth handling of millions of tris 

    Binary Geocache (NPY format) persisted GPU buffers : initialize in seconds rather than minutes 

    Visualization geometry shader : time as an input 

    Composited raytrace and rasterized images using Z-depth calculated for each raytrace pixel.

    eliminates optical photon bottleneck

    Geometry Set Free

    GPU textures : convenient for material/surface properties : providing hardware interpolation 

    GPUs contain hardware dedicated to fast texture lookup and interpolation. Using texture lookup for all properties and reemission wavelengths keeps OptiX programs simple.

    GPU resident photons : huge memory saving 

    thrust::copy_if stream compaction 
 
    photon indexing with Thrust fast CUDA integer sorting 
 
    NVIDIA expertise on efficient GPU/multi-GPU usage : load balancing 

    new GPU tuning 

    RTX : 10 GiGaRays/s -> ~1 billion photons/s
  
    analytic CSG -> auto translation of Geant4 geometry 

    modern CMake target export (Opticks is a tree of ~20 pkgs : very fast rebuilds of sub-components) 

    Opticks.NPY 




.. comment general cons

    Separate address space : serialization : array oriented not object 

    inevitable duplication on GPU : brings matching validation costs : double/float makes that difficult 




:small:`Summary`
----------------------------------------------------------------

.. sidebar:: :small:`Innovation = Problems...`

   .. class:: small

      * Problems Inevitable
      * Ample benefits reward efforts


.. image:: /env/presentation/1px.png
   :width: 500px
   :height: 50px

..


  *Opticks* : state-of-the-art GPU ray tracing applied to optical photon simulation and
  integrated with *Geant4*, giving a leap in performance that eliminates memory and time bottlenecks.
 

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 1px




  * Drastic speedup -> better detector understanding -> greater precision
  
    * **any simulation limited by optical photons can benefit** 
    * more photon limited -> more overall speedup (99% -> 100x) 

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 10px



.. table::
    :align: center

    +----------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks    | code repository                         |                   
    +----------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io             | presentations and videos                |
    +----------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                  | forum/mailing list archive              |
    +----------------------------------------------+-----------------------------------------+
    | email:opticks+subscribe@groups.io            | subscribe to mailing list               |
    +----------------------------------------------+-----------------------------------------+ 


.. comment

  *Opticks* uses hardware accelerated GPU ray tracing
  via NVIDIA OptiX to give **effectively zero time and zero CPU memory** 
  optical photon simulation to *Geant4* applications.



.. s5_talk::

   So in summary : Opticks applies the best available GPU ray tracing to optical 
   photon simulation resulting in speedups exceeding three orders of magnitude.

   Opticks is still very young and it really needs users to turn it into 
   a robust tool that anyone with an optical photon simulation problem 
   can use to elimate.

   These speedups are just for the optical photons, how much that 
   helps with the overall speedup depends on how limited you are by 
   optical photons.


   



.. s5_background_image::

    ##
    ## slide titles and background image urls, 
    ## including server relative urls like /env/geant4/geometry/collada/daeview/20140419-170713.png
    ## and protocol relative urls like //localhost/env/test/LANS_AD3_CoverGas_Humidity.png
    ##
    ## NB1 slide titles here must match those in body precisely, 
    ## NB2 also ensure all slide titles are unique
    ##
    ##slide0
    ##/env/geant4/geometry/collada/g4daeview/20140419-170713.png auto_auto 0px_0px
    ##/env/geant4/geometry/collada/g4daeview/20140419-170713-1024x768.png auto_auto 0px_0px
    ##
    ##   wide targetting 1280x720
    ##   
    ##
    slide0
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 1280px_720px

    Opticks Benefits
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 1280px_720px

    Visualizing An Optical Photon Simulation
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 640px_360px 600px_100px

    Overview
    /env/graphics/ggeoview/jpmt-inside-wide_crop.png 1280px_720px

    g4daeview.py : Fast OpenGL 3D viewer for G4DAE files
    /env/geant4/geometry/collada/g4daeview/20140419-170713.png

    Cerenkov Photons Simulation - Top View
    /env/geant4/geometry/collada/g4daeview/20141224-115923.png

    Cerenkov Photons Simulation - Side View
    /env/geant4/geometry/collada/g4daeview/20141224-115935.png

    Scintillation Photons Simulation - Top View
    /env/geant4/geometry/collada/g4daeview/20141224-121444.png

    Scintillation Photons Simulation - Side View
    /env/geant4/geometry/collada/g4daeview/20141224-121435.png

    Standard Geant4 Workflow
    /env/keynotefigs/G4DAEChroma/G4DAEChroma.001.png

    External Photon Simulation Workflow
    /env/keynotefigs/G4DAEChroma/G4DAEChroma.002.png


    ## keynote wide default is 1920x1080  aspect 1.77777777 16:9
    ## but my slides use       1280x720
    ## used document panel at top right to change to custom size of 1280x720
    ## then exported from Keynote as Images selecting PNG creates
    ## a PNG of size 1280x720
    ##   cp ~/Documents/Geant4OpticksWorkflow/Geant4OpticksWorkflow.001.png ~/simoncblyth.bitbucket.io/env/Documents/Geant4OpticksWorkflow/
    ##
    Geant4OpticksWorkflow
    /env/Documents/Geant4OpticksWorkflow/Geant4OpticksWorkflow.001.png 1280px_720px

    GGeoView
    /env/graphics/ggeoview/ggeoview-cerenkov-001.png 1047px_795px

    GGeoView M1 Points
    /env/graphics/ggeoview/ggeoview-scintillation-points-mat1.png 1435px_848px

    GGeoView Flag Selection 
    /env/graphics/ggeoview/ggeoview-scintillation-flag-seq-select.png 1436px_842px

    GGeoView Cerenkov Geom M1
    /env/graphics/ggeoview/ggeoview-cerenkov-m1-geom.png 1416px_845px
  
    Detecting Neutrinos via Optical Photons 1
    /env/presentation/dayabay-principal_half.png 1417px_830px 

    Detecting Neutrinos via Optical Photons 2
    /env/presentation/dayabay-principal_half.png 1417px_830px 
 
    JPMT Inside Wide 
    /env/graphics/ggeoview/jpmt-inside-wide_half.png 1432px_844px

    JPMT Wide
    /env/graphics/ggeoview/jpmt-wide_half.png 1409px_836px
  
    JPMT Headview
    /env/graphics/ggeoview/jpmt-headview_half.png 1308px_783px
 
    JPMT Backview
    /env/graphics/ggeoview/jpmt-backview_half.png 1149px_794px 
 
    JPMT Approach 
    /env/graphics/ggeoview/jpmt-approach_half.png 1431px_839px

    JPMT Arrival 
    /env/graphics/ggeoview/jpmt-arrival_half.png 1427px_841px 
 
    Optical Photon Simulation Problem...
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JUNO Optical Photon Simulation Problem...
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JPMT Before Contact
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JPMT Before Contact 2
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

    JPMT Before Contact 3
    /env/graphics/ggeoview/jpmt-before-contact_half.png 1430px_844px 

 
    JPMT After Contact 
    /env/graphics/ggeoview/jpmt-after-contact_half.png 1425px_840px 
  
    JPMT Inside Outside 
    /env/graphics/ggeoview/jpmt-inside-outside_half.png 1401px_842px

    NVIDIA OptiX In Action
    /env/presentation/optix-in-action_half.png 966px_646px 100px_50px

    PmtInBox approach 1
    /env/graphics/ggeoview/PmtInBox-approach.png 1069px_769px 

    PmtInBox approach 2
    /env/graphics/ggeoview/PmtInBox-approach.png 1069px_769px 

    PmtInBox after 1
    /env/graphics/ggeoview/PmtInBox-after.png 1057px_760px 

    PmtInBox after 2
    /env/graphics/ggeoview/PmtInBox-after.png 1057px_760px 

    Daya Bay PMT Wall Photo 1
    /env/presentation/gtc2016/dyb-pmt-wall-photo.png 1329px_798px  

    Daya Bay PMT Wall Photo 2
    /env/presentation/gtc2016/dyb-pmt-wall-photo.png 1329px_798px  

    Super-Kamiokande PMTs Not 16:9 
    /env/presentation/gtc2016/sk-PH20-water-withboat-apr23-wm.png 1181px_771px

    Super-Kamiokande PMTs 1
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Super-Kamiokande PMTs 2
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Super-Kamiokande PMTs 3
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Super-Kamiokande PMTs 4
    /env/presentation/PH20-water-withboat-apr23-wm_crop.png 1280px_720px

    Kamiokande II 1
    /env/presentation/1987a.png 1280px_720px

    Kamiokande II 2
    /env/presentation/1987a.png 1280px_720px

    Kamiokande II 3
    /env/presentation/1987a.png 1280px_720px


    Fast Optical Photon Simulation
    /env/presentation/newtons-opticks.png 374px_684px 800px_0px

    Photomultiplier Tubes (PMTs)
    /env/presentation/hamamatsu-pmt-16x9.png 1280px_720px

    Photomultiplier Tube Operation
    /env/presentation/hamamatsu-pmt-16x9.png 1280px_720px

    Old Hamamatsu Photomultiplier Tubes (PMTs)
    /env/presentation/hamamatsu-pmt.png 1099px_734px

    Old Photomultiplier Tube Operation
    /env/presentation/hamamatsu-pmt.png 1099px_734px




    Jiangmen Underground Neutrino Observatory (JUNO) 
    /env/presentation/juno-schematic-5.png 1391px_734px

    Jiangmen Underground Neutrino Observatory, Goals
    /env/presentation/juno-schematic-5.png 1391px_734px


    Dayabay Reactor Neutrino Expt, Far Site
    /env/presentation/DybFar_crop.png 1280px_720px

    Daya Bay Far Site 2
    /env/presentation/DybFar_crop.png 1280px_720px

    Daya Bay Far Site 3
    /env/presentation/DybFar_crop.png 1280px_720px

    Geant4 : Monte Carlo Simulation Toolkit 
    /env/presentation/g4-hep.png 1025px_621px 100px_100px 

    Geant4 : Monte Carlo Simulation Toolkit Generality
    /env/presentation/g4-hep.png 1025px_621px 100px_100px 

    "Seeing" neutrinos via scintillation + Cherenkov light
    /env/presentation/cherenkov.png 316px_203px 850px_400px

    Opticks : Auto-Instancing
    /env/graphics/ggeoview/ggv-juno-instancing.png 852px_592px 450px_80px

    NVIDIA OptiX 1
    /env/presentation/NVIDIAOptiXWebsite_Oct2016.png 1280px

    NVIDIA OptiX 2
    /env/presentation/NVIDIAOptiXWebsite_Oct2016.png 1280px

    OpticksDocs
    /env/presentation/OpticksDocs.png 1280px_720px

    Daya Bay Antineutrino Detection via Inverse Beta Decay 1
    /env/presentation/AntineutrinoDetectionViaIBDJetterSept2014.png 809px_576px 100px_100px

    Daya Bay Antineutrino Detection via Inverse Beta Decay 2
    /env/presentation/AntineutrinoDetectionViaIBDJetterSept2014.png 809px_576px 100px_100px
    ## a = np.array([1676.0, 1192.0])
    ## .8*720.*a/1192.

    Daya Bay Energy Response Model (1)
    /env/presentation/ZheTaupDetectorResponseModel.png 968px_576px 100px_100px

    Daya Bay Energy Response Model (2)
    /env/presentation/ZheTaupDetectorResponseModel.png 968px_576px 100px_100px

    ## a = np.array([2392., 1424.]) ; .8*720*a/a[1]



    Daya Bay Energy Response Model : Fit to Calibration Data 1
    /env/presentation/EnergyResponseModel.png 693px_504px 0px_100px 
    ## a = np.array([1760., 1280.])
    ## .8*720.*a/1280.   792px_576px
    ## 693.,  504

    Daya Bay Energy Response Model : Fit to Calibration Data 2
    /env/presentation/ConstrainingNonLinearity.png 761px_553px 0px_80px
    ## a = np.array([1698., 1166.])
    ## .8*720.*a/1166. 
    
    Daya Bay nGd Analysis : Most Precise Theta13
    /env/presentation/DYBZheTaup2015Theta13OscillationAnalysis.png 1057px_625px 100px_60px
    ## a = np.array([2140., 1266.])
    ## .8*720.*a/1166.


    Opticks Analytic Daya Bay Near Site, GPU Raytrace (3)
    /env/presentation/op_full_raytrace_3.png 1280px_720px

    Opticks Analytic Daya Bay Near Site, GPU Raytrace (1)
    /env/presentation/op_full_raytrace_1.png 1280px_720px

    Opticks Analytic Daya Bay Near Site, GPU Raytrace (0)
    /env/presentation/op_full_raytrace_0.png 1280px_720px

    Opticks Analytic Daya Bay Near Site, GPU Raytrace (2)
    /env/presentation/op_full_raytrace_2.png 1280px_720px

    Opticks Analytic JUNO Chimney, GPU Raytrace (0)
    /env/presentation/j1707_chimney_analytic_raytrace.png 1280px_720px

    Opticks Analytic JUNO PMT Snap, GPU Raytrace (1)
    /env/presentation/j1707-okop-snap.png 1280px_720px

    GPU Instance Culling with Level Of Detail
    /env/presentation/j1707_lod_oglrap_instcull.png 1280px_720px

    Opticks Export of G4 geometry to glTF 2.0
    /env/yoctoglrap/dyb_near_venice_half.png 1020px_737px

    What are NumPy Arrays
    /env/presentation/what_are_numpy_arrays.png 1280px_720px

    What are NumPy Arrays 2
    /env/presentation/what_are_numpy_arrays.png 1280px_720px

    BVH
    /env/presentation/nvidia/NV_Turing_Editors_Day_029.png 1280px_720px

    Spatial Index Acceleration Structure
    /env/presentation/nvidia/NV_Turing_Editors_Day_029.png 1280px_720px



    BVH Pascal 
    /env/presentation/nvidia/NV_Turing_Editors_Day_030.png 1280px_720px
 
    BVH Turing
    /env/presentation/nvidia/NV_Turing_Editors_Day_031.png 1280px_720px
 
    Hardware Traversal of BVH Spatial Index
    /env/presentation/nvidia/NV_Turing_Editors_Day_031.png 1280px_720px

    SIGGRAPH_2018_Announcing_Worlds_First_Ray_Tracing_GPU
    /env/presentation/nvidia/SIGGRAPH_2018_Announcing_Worlds_First_Ray_Tracing_GPU_half.png 1280px_720px

    SIGGRAPH_2019_Eric_Enderton_RT_Cores
    /env/presentation/nvidia/SIGGRAPH_2019_Eric_Enderton_RT_Cores.png 1280px_720px


    ##
    ##  original 2880px_1620px
    ##  half     1440px_810px

    NVIDIA Turing GPU : 72 SM, 4608 CUDA cores
    /env/presentation/nvidia/NV_Turing_Editors_Day_009.png 1280px_720px

    NVIDIA Turing GPU : 72 SM, 4608 CUDA cores (spec)
    /env/presentation/nvidia/NV_Turing_Editors_Day_009.png 1280px_720px
 
    Raytrace vs Raster
    /env/presentation/nvidia/NV_Turing_Editors_Day_132.png 1280px_720px

    Ray-tracing vs Rasterization
    /env/presentation/nvidia/black.png 1280px_720px

    Raytrace Diagram
    /env/presentation/graphics/1024px-ray_trace_diagram.svg.png 1280px_720px

    ## https://images.anandtech.com/doci/13282/NV_Turing_Editors_Day_132.png
    ##
    ##   1280 720
    ##   1920 1080  *1.5
    ##  https://www.anandtech.com/Gallery/Album/6660##6
    ## 

    j1808_top_ogl
    /env/presentation/j1808/j1808_top_ogl.png 1280px_720px

    j1808_top_rtx
    /env/presentation/j1808/j1808_top_rtx.png 1280px_720px
    ##   1920 1080

    j1808_escapes
    /env/presentation/j1808/j1808_escapes.png

    geocache_360
    /env/presentation/geocache_360.png 1280px_720px 0px_0px 

    JUNO-360 benchmark with OptiX 6.0.0, RTX mode 
    /env/presentation/geocache_360.png 1280px_720px

    absmry_1M 
    /env/presentation/ana/absmry_1M.png 1280px_720px

    absmry_1M 2
    /env/presentation/ana/absmry_1M.png 1280px_720px

    ta34_1M
    /env/presentation/ana/ta34_1M.png 1280px_720px

    ta34_1M 2
    /env/presentation/ana/ta34_1M.png 1280px_720px

    tv34_1M_a
    /env/presentation/ana/tv34_1M_a.png 1280px_720px

    tv34_1M_b
    /env/presentation/ana/tv34_1M_b.png 1280px_720px

    tv21_1M_a
    /env/presentation/ana/tv21_1M_a.png 1280px_720px

    tv21_1M_a 2
    /env/presentation/ana/tv21_1M_a.png 1280px_720px

    tv21_1M_c
    /env/presentation/ana/tv21_1M_c.png 1280px_720px

    RTX_Speedup
    /env/presentation/ana/RTX_Speedup.png 1280px_720px
    
    Overheads
    /env/presentation/ana/Overheads.png 1280px_720px
 
    Opticks_Speedup
    /env/presentation/ana/Opticks_Speedup.png 1280px_720px
 
    Opticks_vs_Geant4
    /env/presentation/ana/Opticks_vs_Geant4.png 1280px_720px

    Opticks_vs_Geant4 2
    /env/presentation/ana/Opticks_vs_Geant4.png 1280px_720px
    
    NHit
    /env/presentation/ana/NHit.png 1280px_720px

    Interval_over_Launch
    /env/presentation/ana/Interval_over_Launch.png 1280px_720px
 
    TITAN RTX : 72 Raytrace Dedicated RT Cores, 4608 CUDA Cores, 24GB VRAM, 2500 USD
    /env/presentation/nvidia/TITAN_RTX.png 1280px_720px
 
    bench_20190526_143808
    /env/presentation/ana/bench_20190526_143808.png  

    bench_20190526_143808 2
    /env/presentation/ana/bench_20190526_143808.png  

    bench_20190526_202537
    /env/presentation/ana/bench_20190526_202537.png  

    bench_20190526_202537 2
    /env/presentation/ana/bench_20190526_202537.png  



    tv16_Fastener
    /env/presentation/tv/tv16_Fastener.png

    tv20_polycone_neck
    /env/presentation/tv/tv20_polycone_neck.png

    20inch PMT neck : "cylinder-torus" -> polycone
    /env/presentation/tv/tv20_polycone_neck.png

    genstep_interface
    /env/presentation/simulation/genstep_interface.png 1280px_720px

    Introducing OptiX 7  
    /env/presentation/nvidia/Introducing_OptiX_7.png 1280px_720px

    Where Next for Opticks ?
    /env/presentation/nvidia/Introducing_OptiX_7.png 640px_360px 670px_300px
    ##/env/presentation/nvidia/Introducing_OptiX_7.png 640px_360px 640px_300px

    Opticks Experience : Problems with using NVIDIA OptiX
    /env/presentation/nvidia/Introducing_OptiX_7.png 640px_360px 670px_300px


    TURING BUILT FOR RTX  
    /env/presentation/nvidia/TURING_Built_for_RTX_half.png 1280px_720px

    TURING BUILT FOR RTX 2 
    /env/presentation/nvidia/TURING_Built_for_RTX_half.png 1280px_720px



    NVIDIA RTX Metro Exodus
    /env/presentation/nvidia/NVIDIA_RTX_Metro_Exodus_half.png 1280px_720px

    Modern_GPU_RAY_Tracing
    /env/presentation/nvidia/Modern_GPU_RAY_Tracing.png 1280px_720px

    NVIDIA OptiX : programming model analogous to rasterization APIs : OpenGL shaders
    /env/presentation/nvidia/Modern_GPU_RAY_Tracing.png 1280px_720px

    NVIDIA_Quadro_RTX 8000 (48G)
    /env/presentation/nvidia/NVIDIA_Quadro_RTX.png 1280px_720px


    SIGGRAPH_2010_OptiX_A_General_Purpose_Ray_Tracing_Engine
    /env/presentation/nvidia/SIGGRAPH_2010_OptiX_A_General_Purpose_Ray_Tracing_Engine.png 1280px_720px

    Useful Speedup > 1000x : But Why Not Giga Rays/s ? (1 photon ~10 rays)
    /env/presentation/nvidia/dhart/dhart_siggraph_2019_RTX_traversal_custom_primitives.png 720px_405px 10px_210px

    ## /env/presentation/nvidia/dhart/dhart_siggraph_2019_RTX_traversal_custom_primitives.png 640px_360px 20px_260px
    ## 
    ##
    ##
    ##
    ## https://juno.ihep.ac.cn/cgi-bin/Dev_DocDB/ShowDocument?docid=5079
    ##
    ## cp ~/Documents/JUNOIntro/JUNOIntro.00[1,2,3,4].png ~/simoncblyth.bitbucket.io/env/Documents/JUNOIntro/
    ##

    JUNO_Intro_1
    /env/Documents/JUNOIntro/JUNOIntro.001.png 1280px_720px

    JUNO_Intro_2
    /env/Documents/JUNOIntro/JUNOIntro.002.png 1280px_720px

    JUNO_Intro_3
    /env/Documents/JUNOIntro/JUNOIntro.003.png 1280px_720px

    JUNO_Intro_4
    /env/Documents/JUNOIntro/JUNOIntro.004.png 1280px_720px


    JUNO_Multipurpose_Pedro_NuFact_2019 
    /env/presentation/juno/JUNO_Multipurpose_Pedro_NuFact_2019.png 960px_720px 0px_0px


    dhart_siggraph_2019_OptiX_5_traversal
    /env/presentation/nvidia/dhart_siggraph_2019_OptiX_5_traversal.png 1280px_720px 

    dhart_siggraph_2019_OptiX_5_traversal
    /env/presentation/nvidia/dhart_siggraph_2019_OptiX_5_traversal.png 1280px_720px 

    scan-pf-check-GUI-TO-BT5-SD
    /env/presentation/ana/scan-pf-1/scan-pf-check-GUI-TO-BT5-SD.png 1280px_720px

    scan-pf-check-GUI-TO-SC-BT5-SD
    /env/presentation/ana/scan-pf-1/scan-pf-check-GUI-TO-SC-BT5-SD.png 1280px_720px

    scan-pf-0_Interval_over_Launch
    /env/presentation/ana/scan-pf-0/Interval_over_Launch.png 1280px_720px

    scan-pf-0_NHit
    /env/presentation/ana/scan-pf-0/NHit.png 1280px_720px

    scan-pf-0_Opticks_Speedup
    /env/presentation/ana/scan-pf-0/Opticks_Speedup.png 1280px_720px

    scan-pf-0_Opticks_vs_Geant4
    /env/presentation/ana/scan-pf-0/Opticks_vs_Geant4.png 1280px_720px

    scan-pf-0_Overheads
    /env/presentation/ana/scan-pf-0/Overheads.png 1280px_720px

    scan-pf-0_RTX_Speedup
    /env/presentation/ana/scan-pf-0/RTX_Speedup.png 1280px_720px

    scan-pf-0_RTX_Speedup 2
    /env/presentation/ana/scan-pf-0/RTX_Speedup.png 1280px_720px


    scan-pf-1_Interval_over_Launch
    /env/presentation/ana/scan-pf-1/Interval_over_Launch.png 1280px_720px

    scan-pf-1_NHit
    /env/presentation/ana/scan-pf-1/NHit.png 1280px_720px

    scan-pf-1_Opticks_Speedup
    /env/presentation/ana/scan-pf-1/Opticks_Speedup.png 1280px_720px

    scan-pf-1_Opticks_Speedup 2
    /env/presentation/ana/scan-pf-1/Opticks_Speedup.png 1280px_720px

    scan-pf-1_Opticks_vs_Geant4
    /env/presentation/ana/scan-pf-1/Opticks_vs_Geant4.png 1280px_720pxS

    scan-pf-1_Opticks_vs_Geant4 2
    /env/presentation/ana/scan-pf-1/Opticks_vs_Geant4.png 1280px_720pxS


    scan-pf-1_Overheads
    /env/presentation/ana/scan-pf-1/Overheads.png 1280px_720px

    scan-pf-1_RTX_Speedup
    /env/presentation/ana/scan-pf-1/RTX_Speedup.png 1280px_720px

    Opticks : Translates G4 Geometry to GPU, Without Approximation
    /env/presentation/face_view_PMTs.png 640px_360px 20px_340px



.. comment
    
    NVIDIA 
                        Memory    Bandwidth     CUDA(RT) Cores
    TITAN V             12 GB       651 GB/s    5120(0)
    Tesla V100          32 GB       900 GB/s    5120(0)  
    TITAN RTX           24 GB       672 GB/s    4608(72)
    Quadro RTX 8000     48 GB       672 GB/s    4608(72)

    SM*64 gives cores 

    https://www.techpowerup.com/gpu-specs/titan-v.c3051
    https://www.techpowerup.com/gpu-specs/titan-rtx.c3311 
    https://www.techpowerup.com/gpu-specs/quadro-rtx-8000.c3306



