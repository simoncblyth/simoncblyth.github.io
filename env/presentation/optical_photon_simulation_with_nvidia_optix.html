<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>Optical Photon Simulation with NVIDIA OptiX</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="visible" />
<!-- style sheet links -->
<script src="ui/my-small-white/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/my-small-white/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/my-small-white/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/my-small-white/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/my-small-white/opera.css"
      type="text/css" media="projection" id="operaFix" />
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1>Optical Photon Simulation with NVIDIA OptiX</h1>

</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title">Optical Photon Simulation with NVIDIA OptiX</h1>

<!-- comment -->
<style type="text/css">
    span.alarm { color: red; }
    span.warn { color: orange; }
    span.ok { color: green; }
    span.i { display: none; }
    pre.sliteral { class:"literal-block small"; }
    pre.mypre {
         display: block;
         font-family: monospace;
         font-size: 20px;
         white-space: pre;
         margin: 1em 0;
    }

</style><!-- Definitions of interpreted text roles (classes) for S5/HTML data. -->
<!-- This data file has been placed in the public domain. -->
<!-- Colours
======= -->
<!-- Text Sizes
========== -->
<!-- Display in Slides (Presentation Mode) Only
========================================== -->
<!-- Display in Outline Mode Only
============================ -->
<!-- Display in Print Only
===================== -->
<!-- Display in Handout Mode Only
============================ -->
<!-- Incremental Display
=================== -->

       <style type="text/css">

          div.slide { 
             background-clip: border-box;
             background-repeat: no-repeat;
             height: 100%;
          }
          div.slide#slide0{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20140419-170713.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#g4daeview-py-fast-opengl-3d-viewer-for-g4dae-files{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20140419-170713.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#cerenkov-photons-simulation-top-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-115923.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#cerenkov-photons-simulation-side-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-115935.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#scintillation-photons-simulation-top-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-121444.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#scintillation-photons-simulation-side-view{
             background-image: url(/env/geant4/geometry/collada/g4daeview/20141224-121435.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#standard-geant4-workflow{
             background-image: url(/env/keynotefigs/G4DAEChroma/G4DAEChroma.001.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#external-photon-simulation-workflow{
             background-image: url(/env/keynotefigs/G4DAEChroma/G4DAEChroma.002.png);
             background-size: auto auto;
             background-position: 0px 0px;
          }
          div.slide#ggeoview{
             background-image: url(/env/graphics/ggeoview/ggeoview-cerenkov-001.png);
             background-size: 1047px 795px;
             background-position: 0px 0px;
          }
          div.slide#ggeoview-m1-points{
             background-image: url(/env/graphics/ggeoview/ggeoview-scintillation-points-mat1.png);
             background-size: 1435px 848px;
             background-position: 0px 0px;
          }
          div.slide#ggeoview-flag-selection{
             background-image: url(/env/graphics/ggeoview/ggeoview-scintillation-flag-seq-select.png);
             background-size: 1436px 842px;
             background-position: 0px 0px;
          }
          div.slide#ggeoview-cerenkov-geom-m1{
             background-image: url(/env/graphics/ggeoview/ggeoview-cerenkov-m1-geom.png);
             background-size: 1416px 845px;
             background-position: 0px 0px;
          } 

       </style>
    <!-- comment

GGeoView image is 2094x1590 1047x795

GGeoView M1 Points is 2870x1696  1435x848

GGeoView Flag Selection 2872x1684 1436x842

GGeoView Cerenkov Geom M1 2832x1690 1416x845


Generated Scintillation Photons GPU cf Geant4
/env/g4dae/generated_scintillation_time_wavelength.png

G4/DetSim Generated Cerenkov Wavelength
/env/g4dae/g4_cerenkov_wavelength.png -->
<!-- comment

Last 6 weeks

implemented optical physics in OptiX infrastructure
squeeze photon record into 128 bit
record viz
photon history/material indexing -->
<p class="small"><a class="reference external" href="http://simoncblyth.bitbucket.org/env/presentation/optical_photon_simulation_with_nvidia_optix.html">http://simoncblyth.bitbucket.org/env/presentation/optical_photon_simulation_with_nvidia_optix.html</a> (July 2015)
<a class="reference external" href="http://simoncblyth.bitbucket.org/env/presentation/gpu_accelerated_geant4_simulation.html">http://simoncblyth.bitbucket.org/env/presentation/gpu_accelerated_geant4_simulation.html</a> (Jan 2015)</p>
<div class="sidebar">
<p class="first sidebar-title">OptiX Ray Tracing</p>
<p class="last">Extreme speed ~200M ray intersections/second/GPU, regular releases,
performance scales with CUDA cores across multiple GPUs.</p>
</div>
<ul class="small simple">
<li>Why not Chroma ?</li>
<li>Introducing NVIDIA OptiX</li>
<li>OptiX testing</li>
<li>New Packages Replacing Chroma</li>
<li>Mobile GPU Timings</li>
<li>Operation with JUNO Geometry ?</li>
<li>Next Steps</li>
</ul>
<div class="small line-block">
<div class="line">Simon C Blyth, National Taiwan University</div>
<div class="line"><strong>July 2015</strong></div>
</div>
<!-- comment

00 : Optical Photon Simulation with NVIDIA OptiX

01 : why not chroma ?

02 : introducing nvidia optix ray tracing engine [c++/c/cuda]
03 : parallels between realistic image synthesis and optical simulation
04 : chroma raycast with entire geometry in view
05 : optix raycast performance
06 : optix performance scaling with gpu cores
07 : optix programming model
08 : optix adoption costs, application to juno geometry

09 : new c++ packages replacing chroma
10 : selection of gpu development details
11 : porting optical physics from geant4/chroma to optix
12 : optical physics implementation
13 : random number generation in optix programs
14 : fast material/surface property lookup from boundary texture
15 : inverted cdf allows reemission wavelength gpu texture lookup
16 : recording the steps of ~3 million photons
17 : indexing photon flag/material sequences
18 : introducing cuda thrust

19 : mobile gpu timings for cerenkov and scintillation photons
20 : ggeoview m1 points
21 : next steps

22 : "backup" : details for reference
23 : ggeo/optix generated scintillation photons cf geant4
24 : ggeo/optix generated cerenkov photons cf geant4
25 : c++ infrastructure : foundation packages
26 : c++ infrastructure : domain packages
27 : propagate_to_boundary : absorb(reemit) / scatter / survive
28 : comparison of ggeo/optix generated scintillation photon distributions
29 : comparison of ggeo/optix generated cerenkov photon distributions
30 : ggeoview -->

</div>
<div class="slide" id="why-not-chroma">
<h1><span class="small">Why not Chroma ?</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Lack of multi-GPU support</p>
<p class="small last">Production running demands efficient use
of multiple GPUs.  Lack of this difficult
to implement feature is a <span class="red">show stopper for Chroma use in production</span>.</p>
</div>
<p class="small"><span class="green">Chroma Features</span></p>
<ul class="small simple">
<li>Python/PyCUDA/NumPy based infrastructure for geometry/photon loading, kernel launch</li>
<li>accelerated geometry intersection using BVH structure</li>
<li>optical photon simulation CUDA kernels</li>
</ul>
<p class="small"><span class="blue">My additions to Chroma</span></p>
<ul class="small simple">
<li>G4DAE Geometry import</li>
<li>G4Step transport and Cerenkov/Scintillation photon generation on GPU</li>
<li>OpenGL/CUDA interop visualisations</li>
</ul>
<p class="small"><span class="red">Missing Features</span></p>
<ul class="small simple">
<li>GPU workload scheduling</li>
<li>Multi-GPU support</li>
</ul>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/chroma/chroma">https://bitbucket.org/chroma/chroma</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/chroma">https://bitbucket.org/simoncblyth/chroma</a>  (my fork)</p>
</div>
<div class="slide" id="introducing-nvidia-optix-ray-tracing-engine-c-c-cuda">
<h1><span class="small">Introducing NVIDIA OptiX Ray Tracing Engine [C++/C/CUDA]</span></h1>
<div class="sidebar">
<p class="first sidebar-title">OptiX <em>Tutorial</em> App</p>
<p class="small">Image pixels calculated by recursively bouncing rays
around geometry doing shadow, reflection, refraction calculations.
Runs at interactive speeds with GeForce GT 750M.</p>
<img alt="/env/optix/samples/optix-tutorial-10.png" class="last align-right" src="/env/optix/samples/optix-tutorial-10.png" style="width: 450px;" />
</div>
<p class="small">OptiX provides: <span class="blue">CUDA compiler optimized for Ray Tracing</span></p>
<ul class="small simple">
<li>ray tracing framework, <strong>no rendering assumptions</strong></li>
<li>~200M ray/s/GPU geometry intersections</li>
<li>regular releases, improvements, tuning for new GPUs</li>
<li>shared C++/CUDA context eases development</li>
</ul>
<p class="small"><span class="red">NVIDIA expertise on efficient GPU/multi-GPU usage</span></p>
<ul class="small simple">
<li>persistent warps sized to fill machine</li>
<li>load balancing between warps, GPUs</li>
</ul>
<p class="tiny"><a class="reference external" href="https://developer.nvidia.com/optix">https://developer.nvidia.com/optix</a></p>
<p class="tiny"><a class="reference external" href="https://research.nvidia.com/publication/optix-general-purpose-ray-tracing-engine">https://research.nvidia.com/publication/optix-general-purpose-ray-tracing-engine</a></p>
</div>
<div class="slide" id="parallels-between-realistic-image-synthesis-and-optical-simulation">
<h1><span class="small">Parallels between Realistic Image Synthesis and Optical Simulation</span></h1>
<div class="sidebar">
<p class="first sidebar-title">OptiX <em>Glass</em> Sample App</p>
<img alt="/env/optix/samples/optix-ray-tracing-glasses.png" class="align-right" src="/env/optix/samples/optix-ray-tracing-glasses.png" style="width: 450px;" />
<p class="tiny last"><a class="reference external" href="http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf">http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf</a></p>
</div>
<p class="small">Realistic image creation uses physically
based techniques and material definitions. Obvious parallels:</p>
<ul class="small simple">
<li>ray traced rendering : image pixel calculation</li>
<li>optical photon (OP) simulation : PMT hit calculation</li>
</ul>
<p class="small">Same rate determining step: <span class="red">geometry intersection</span></p>
<p class="small">Applying techniques/hardware developed for fast ray tracing
can be hugely beneficial to optical photon simulation.</p>
<ul class="small simple">
<li><span class="red">expect OP simulation performance &gt;100x Geant4</span></li>
<li>OP processing time becomes effectively zero</li>
</ul>
</div>
<div class="slide" id="chroma-raycast-with-entire-geometry-in-view">
<h1><span class="small">Chroma Raycast with entire geometry in view</span></h1>
<p class="small">Render Split into 3x3 CUDA kernel launches, 1 thread per pixel, <span class="red">~1.8s for 1.23M pixels</span>, 2.4M tris (with <a class="footnote-reference" href="#hw" id="id1">[1]</a>)</p>
<img alt="/env/chroma/chroma_camera/20140423-162109.png" class="align-center" src="/env/chroma/chroma_camera/20140423-162109.png" style="width: 800px;" />
<table class="tiny docutils footnote" frame="void" id="hw" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>MacBook Pro (2013), NVIDIA GeForce GT 750M 2048 MB (384 cores);
Workstation GPU performance expected to scale by core count</td></tr>
</tbody>
</table>
</div>
<div class="slide" id="optix-raycast-performance">
<h1><span class="small">OptiX raycast performance</span></h1>
<div class="sidebar">
<p class="first sidebar-title">GGeoview OptiX raycast</p>
<img alt="/env/optix/raycast/optix-raycast-gui-001.png" class="align-right" src="/env/optix/raycast/optix-raycast-gui-001.png" style="width: 550px;" />
<p class="tiny last"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/">https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/</a></p>
</div>
<p class="small">DBNS geometry raycast comparison using mobile GPU</p>
<ul class="small simple">
<li>OptiX : <span class="red">interactive ~30 fps</span> raycasting</li>
<li>Chroma : 1.8s per frame</li>
</ul>
<p class="small">Performance improvement ~50x</p>
</div>
<div class="slide" id="optix-performance-scaling-with-gpu-cores">
<h1><span class="small">OptiX Performance Scaling with GPU cores</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Performance Linearity with CUDA cores</p>
<img alt="/env/g4dae/core_linearity.png" class="last align-right" src="/env/g4dae/core_linearity.png" style="width: 500px;" />
</div>
<p class="small">OptiX sample rendering with 2 GPU IHEP workstation,</p>
<ul class="small simple">
<li>2 Tesla K20m (4992 cores) 28.0 ms/f</li>
<li>1 Tesla K20m (2496 cores) 49.1 ms/f</li>
<li>1 GeForce GT 750m (384 cores) 345.1 ms/f</li>
</ul>
<p class="small"><span class="red">Performance linear with GPU cores</span>, compared to laptop:</p>
<ul class="small simple">
<li>13x cores, 12x performance</li>
</ul>
<p class="small"><strong>Future scaling possibilities, with VCA</strong></p>
<p class="small">OptiX apps can connect to remote Visual Computing Appliances</p>
<ul class="small simple">
<li>1 VCA : <strong>24,576</strong> cores (64x laptop GPU)</li>
</ul>
<p class="small">Clusters of ~10 VCAs are in use by design/advertising companies
for interactive product rendering.</p>
<p class="tiny"><a class="reference external" href="http://www.nvidia.com/object/visual-computing-appliance.html">http://www.nvidia.com/object/visual-computing-appliance.html</a> (8 Maxwell GPUs)</p>
<p class="tiny"><a class="reference external" href="http://on-demand-gtc.gputechconf.com/gtc-quicklink/6bIayc">http://on-demand-gtc.gputechconf.com/gtc-quicklink/6bIayc</a></p>
</div>
<div class="slide" id="optix-programming-model">
<h1><span class="small">OptiX Programming Model</span></h1>
<div class="sidebar">
<p class="first sidebar-title">OptiX Control Flow</p>
<img alt="/env/optix/docs/optix-model.png" class="last align-right" src="/env/optix/docs/optix-model.png" style="width: 450px;" />
</div>
<p class="small">OptiX provides a <span class="red">ray tracing pipeline</span> analogous to OpenGL
rasterization pipeline.</p>
<ul class="small simple">
<li>Blue: OptiX internals</li>
<li>Yellow: User supplied CUDA <em>Programs</em></li>
</ul>
<p class="small">Higher level API than pure CUDA, eg:</p>
<ul class="small simple">
<li><span class="red">shared host/device context system</span></li>
</ul>
<p class="small"><strong>Optical Photon Simulation port currently using:</strong></p>
<dl class="small docutils">
<dt><em>Ray Generation</em></dt>
<dd>entry/exit, Cerenkov/Scintillation generation</dd>
<dt><em>Intersection</em></dt>
<dd>Triangle mesh intersection, boundary index lookup</dd>
<dt><em>Closest Hit</em></dt>
<dd>determine ray to boundary orientation</dd>
</dl>
<p class="tiny"><a class="reference external" href="https://research.nvidia.com/sites/default/files/publications/Parker10Optix_1.pdf">https://research.nvidia.com/sites/default/files/publications/Parker10Optix_1.pdf</a></p>
</div>
<div class="slide" id="optix-adoption-costs">
<h1><span class="small">OptiX Adoption Costs</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Defer to NVIDIA</p>
<ul class="small last simple">
<li>acceleration structure creation and fast traversal</li>
<li><span class="red">efficient GPU/multi-GPU utilization</span></li>
</ul>
</div>
<p class="small"><strong>Adoption of OptiX is compelling</strong></p>
<ul class="small simple">
<li>extremely fast intersection performance</li>
<li>scales with CUDA cores across multiple GPUs</li>
<li>improves with each release</li>
<li>releases tune for new GPU architectures</li>
</ul>
<p class="small"><strong>Costs of adoption</strong></p>
<ul class="small simple">
<li><span class="green">learn new tools: OptiX, Thrust</span></li>
<li><span class="green">develop C++ replacement for Chroma/G4DAE python</span></li>
<li><span class="blue">port Chroma/G4 optical physics into new framework</span></li>
<li><span class="red">validate against Geant4</span></li>
<li><span class="red">develop memory efficient geometry representation</span></li>
</ul>
</div>
<div class="slide" id="new-c-packages-replacing-chroma">
<h1><span class="small">New C++ Packages Replacing Chroma</span></h1>
<div class="sidebar">
<p class="first sidebar-title">~10 Packages Developed</p>
<p class="small">Organized by dependencies</p>
<ul class="small simple">
<li><span class="red">Recreates Geant4 context on GPU</span></li>
<li><span class="blue">Optical simulation by OptiX programs</span></li>
<li><span class="blue">Visualization by OpenGL GLSL Shaders</span></li>
</ul>
<p class="small">Interop between OpenGL/OptiX/Thrust/CUDA</p>
<ul class="small simple">
<li><span class="blue">shared GPU buffers, efficient visualization</span></li>
</ul>
<p class="small">Externals:</p>
<ul class="small simple">
<li>Boost libraries</li>
<li>Boost-Asio, Asio-ZMQ, ZMQ</li>
<li>CUDA 7.0, Thrust 1.8</li>
<li>OptiX 3.8</li>
<li>OpenGL 4.1 (GLEW, GLFW, GLM)</li>
<li>ImGUI</li>
</ul>
<p class="small last">See <em>backup</em> for details, source links</p>
</div>
<p class="small"><strong>Basis packages</strong></p>
<ul class="small simple">
<li><em>NPY</em> : host array handling, persistency</li>
<li><em>NumpyServer</em> : network IO of <em>NPY</em> arrays</li>
<li><em>BCfg</em> <em>BRegex</em> : configuration</li>
</ul>
<p class="small"><strong>Geometry packages</strong></p>
<ul class="small simple">
<li><em>GGeo</em> : preparing geometry for GPU</li>
<li><em>AssimpWrap</em> : G4DAE geometry loading using forked Assimp</li>
</ul>
<p class="small"><strong>GPU library interface packages</strong></p>
<ul class="small simple">
<li><em>CUDAWrap</em> : pseudo random numbers with cuRAND</li>
<li><em>OptiXRap</em> : geometry loading, OptiX launch control</li>
<li><em>OGLWrap</em> : OpenGL visualization</li>
<li><em>ThrustRap</em> : photon indexing, using CUDA Thrust</li>
</ul>
<p class="small"><strong>Main package</strong></p>
<ul class="small simple">
<li><em>GGeoView</em> : optical physics OptiX programs, OpenGL shaders</li>
</ul>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/">https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/</a></p>
</div>
<div class="slide" id="selection-of-gpu-development-details">
<h1><span class="small">Selection of GPU development details</span></h1>
<p class="small">Some details of GPU developments described over the next pages</p>
<p class="small"><strong>Optical Physics</strong></p>
<ul class="small simple">
<li>Porting Optical Physics from Geant4/Chroma into OptiX</li>
<li>Optical Physics Implementation</li>
</ul>
<p class="small"><strong>Supplying the OptiX Programs</strong></p>
<ul class="small simple">
<li>Random Number Generation in OptiX programs</li>
<li>Fast material/surface property lookup from boundary texture</li>
<li>Reemission wavelength lookup from Inverted CDF texture</li>
</ul>
<p class="small"><strong>Handling Outputs</strong></p>
<ul class="small simple">
<li>Recording the steps of millions photons</li>
<li>Indexing photon flag/material sequences</li>
<li>Introducing CUDA Thrust</li>
</ul>
</div>
<div class="slide" id="porting-optical-physics-from-geant4-chroma-into-optix">
<h1><span class="small">Porting Optical Physics from Geant4/Chroma into OptiX</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Synthesis of sources</p>
<ul class="small simple">
<li>Chroma: overall <span class="red">propagation loop</span> structure</li>
<li>Geant4: simulation details</li>
<li>Graphics: fast computation techniques</li>
</ul>
<p class="small"><strong>rtTrace</strong> OptiX fast geometry intersection</p>
<dl class="small last docutils">
<dt><strong>propagate_to_boundary</strong></dt>
<dd>~G4OpAbsorption, ~G4OpRayleigh</dd>
<dt><strong>propagate_at_surface/propagate_at_boundary</strong></dt>
<dd>~G4OpBoundaryProcess</dd>
</dl>
</div>
<pre class="mypre">
Photon p ; State s ; PerRayData prd ;
while(bounce < bounce_max)  // PSEUDO-CODE
{
  bounce++

  ray = optix::make_Ray(p.pos, p.dir,...)
  rtTrace(geom, ray, prd)
  if(!prd.boundary) break  // MISS

  cmd = propagate_to_boundary(p, s)
  if(cmd == BREAK)    break     // ABSORB
  if(cmd == CONTINUE) continue  // REEMIT, SCATTER
  // survivors pass to boundary

  if(s.surface_index)
  {
     cmd = propagate_at_surface(p, s, g)
     if(cmd == BREAK) break         // SURFACE_ABSORB, SURFACE_DETECT
     if(cmd == CONTINUE) continue   // REFLECT_DIFFUSE, REFLECT_SPECULAR
  }
  else
  {
     propagate_at_boundary(p, s)    // BOUNDARY_REFLECT BOUNDARY_TRANSMIT
  }
}
</pre><p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/cu/generate.cu">https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/cu/generate.cu</a></p>
</div>
<div class="slide" id="optical-physics-implementation">
<h1><span class="small">Optical Physics Implementation</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Approach</p>
<ul class="small simple">
<li>Overall Structure from Chroma</li>
<li>Aiming for equivalence with Geant4</li>
<li><span class="red">Optical Surface treatment in progress</span></li>
</ul>
<p class="small last"><span class="blue">Texture lookups of material/surface properties and reemission wavelengths keeps kernels simple</span></p>
</div>
<dl class="small docutils">
<dt><strong>Rayleigh Scattering</strong></dt>
<dd>Direct port of <em>G4OpRayleigh</em> (Xin Qian patch)</dd>
<dt><strong>Reemission</strong></dt>
<dd><ul class="first last simple">
<li>Treated as subset of absorption, conferring rebirth</li>
<li>wavelength from reemission texture lookup</li>
</ul>
</dd>
<dt><strong>Boundary Reflect/Transmit</strong></dt>
<dd><ul class="first last simple">
<li>Snell's law rearranged to avoid transcendentals</li>
<li>Russian Roulette treatment of S or P polarization (simpler than G4)</li>
</ul>
</dd>
<dt><strong>propagate_at_surface: Absorb, Detect, Reflect Diffuse/Specular</strong></dt>
<dd><ul class="first last simple">
<li><span class="red">surface properties still being debugged</span></li>
<li><span class="red">G4 Unified model (SPECULARLOBE/SPIKE etc..) not yet ported</span></li>
</ul>
</dd>
</dl>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/cu/rayleigh.h">https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/cu/rayleigh.h</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/cu/propagate.h">https://bitbucket.org/simoncblyth/env/src/tip/graphics/ggeoview/cu/propagate.h</a></p>
</div>
<div class="slide" id="random-number-generation-in-optix-programs">
<h1><span class="small">Random Number Generation in OptiX programs</span></h1>
<p class="small"><strong>cuRAND library from CUDA toolkit features:</strong></p>
<ul class="small simple">
<li>concurrent generation of reproducible pseudorandom number sequences</li>
<li>sub-sequences are assigned to each CUDA thread, which maintains position in sub-sequence</li>
<li>per-thread state is initialized within CUDA kernel</li>
</ul>
<p class="small"><strong>cuRAND Initialization demands large stack size</strong></p>
<p class="small">Stack sizes 10x typical for OptiX programs were needed,
resulting in slow OptiX running.</p>
<p class="small"><strong>Workaround:</strong></p>
<ul class="small simple">
<li>use separate pure CUDA launches to initialize cuRAND</li>
<li>copy curandState back to host and persist to file</li>
<li>prior to OptiX launch, copy persisted curandState to GPU</li>
<li><span class="red">OptiX can then use cuRAND without having to initialize it</span></li>
</ul>
<p class="small">Packaged solution into <strong>CUDAWrap</strong></p>
<ul class="small simple">
<li><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/cuda/cudawrap/">https://bitbucket.org/simoncblyth/env/src/tip/cuda/cudawrap/</a></li>
</ul>
</div>
<div class="slide" id="fast-material-surface-property-lookup-from-boundary-texture">
<h1><span class="small">Fast material/surface property lookup from boundary texture</span></h1>
<!-- comment

Forked Assimp parses G4DAE **extra** XML elements, *AssimpWrap* creates *GGeo* geometry
with standard properties interpolated onto :red:`common wavelength domain` -->
<div class="sidebar">
<p class="first sidebar-title">Fast GPU texture lookup</p>
<p class="small last">GPUs contain hardware dedicated to fast texture lookup
and interpolation.  Using texture lookup for all properties
and reemission wavelengths keeps OptiX programs simple.</p>
</div>
<p class="small"><em>AssimpWrap</em> creates <em>GGeo</em> <span class="red">boundary instances</span> and labels
triangles with <strong>boundary</strong> indices, boundaries contain:</p>
<ul class="small simple">
<li><strong>inner material</strong> : self</li>
<li><strong>outer material</strong> : parent</li>
<li><strong>inner surface</strong> : outwards going photons (self to parent)</li>
<li><strong>outer surface</strong> : inwards going photons (parent to self)</li>
</ul>
<p class="small">Properties are interpolated onto a <span class="red">common wavelength domain</span></p>
<ul class="small simple">
<li><strong>material</strong> : refractive_index, absorption_length, scattering_length, reemission_prob (<em>float4</em>)</li>
<li><strong>surface</strong> : detect, absorb, reflect_specular, reflect_diffuse (<em>float4</em>)</li>
</ul>
<p class="small">Interleaved properties used to create single <strong>boundary texture</strong> 2d (wavelength, qty line)
containing ~50 boundaries, 4 <em>float4</em> each.  CUDA <strong>tex2d</strong> property lookup:</p>
<pre class="small literal-block">
float nmi = (nm - wavelength_domain.x)/wavelength_domain.z + 0.5f ;
float4 material1 = tex2D(wavelength_texture, nmi, line + 0.5f );

float refractive_index = material1.x ;
float absorption_length = material1.y ;
float scattering_length = material1.z ;
</pre>
<p class="tiny"><a class="reference external" href="https://github.com/simoncblyth/assimp">https://github.com/simoncblyth/assimp</a> (my fork of Assimp)</p>
</div>
<div class="slide" id="reemission-wavelength-lookup-from-inverted-cdf-texture">
<h1><span class="small">Reemission wavelength lookup from Inverted CDF texture</span></h1>
<p class="small">Inverting Reemission CDF allows using texture lookup to obtain
reemission wavelength from uniform random throws.
Using 4096 probability bins.</p>
<img alt="/env/g4dae/reemission_src_cdf_icdf_smpl.png" class="align-center" src="/env/g4dae/reemission_src_cdf_icdf_smpl.png" style="width: 800px;" />
</div>
<div class="slide" id="recording-the-steps-of-3-million-photons">
<h1><span class="small">Recording the steps of ~3 million photons</span></h1>
<div class="sidebar">
<p class="first sidebar-title">128 bit compressed record</p>
<p class="small">Compression necessary to work with ~30M records
(30M * 128bit = ~500 MB)</p>
<p class="small last">GPU memory 2 GB</p>
</div>
<p class="small">Up to 10 steps of the photon propagation are recorded.</p>
<p class="small"><strong>Photon buffer</strong> : 4 * <em>float4</em> = 512 bits/photon</p>
<ul class="small simple">
<li><em>float4</em>: position, time  [32 * 4 = 128 bits]</li>
<li><em>float4</em>: direction, weight</li>
<li><em>float4</em>: polarization, wavelength</li>
<li><em>float4</em>: flags: material, boundary, history</li>
</ul>
<p class="small"><strong>Record buffer</strong> : 2 * <em>short4</em> = 2*16*4 = 128 bits/record</p>
<ul class="small simple">
<li><em>short4</em>: position, time (snorm compressed)  [4*16 = 64 bits]</li>
<li><em>uchar4</em>: polarization, wavelength (uchar compressed) [4*8 = 32 bits]</li>
<li><em>uchar4</em>: material, history flags [4*8 = 32 bits]</li>
</ul>
<p class="small">Compression uses known domains of position (geometry center, extent),
time (0:200ns), wavelength, polarization.</p>
<p class="tiny">Union trickery allows recording ints into floats</p>
</div>
<div class="slide" id="ggeoview-m1-points">
<h1><span class="i">GGeoView M1 Points</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Scintillation Photons colored by material</p>
<p class="tiny last">Visualization of 30M scintillation photon records from an 100 GeV muon crossing Dayabay AD.
Primaries are simulated by Geant4, Scintillation &quot;steps&quot; of the primaries are transferred to the GPU,
where photons are generated, propagated using NVIDIA OptiX and visualized using OpenGL.
The dots represent propagation step positions with colors
corresponding to materials.</p>
</div>
</div>
<div class="slide" id="indexing-photon-flag-material-sequences">
<h1><span class="small">Indexing photon flag/material sequences</span></h1>
<div class="figure align-right">
<img alt="/env/graphics/ggeoview/flagsequence.png" src="/env/graphics/ggeoview/flagsequence.png" style="width: 200px;" />
</div>
<p class="small">Selecting photons by flag/material sequences, requires indexing integer sequences.</p>
<ul class="small simple">
<li>CK : Cerenkov</li>
<li>BT : Boundary Transmit</li>
<li>BR : Boundary Reflect</li>
<li>RE : Reemission</li>
<li>AB : Absorb</li>
<li>BS : Bulk Scatter</li>
</ul>
<p class="small">Indexing history/material sequences for 3M photons:</p>
<ul class="small simple">
<li>CPU STL map, sstream  ~40s</li>
<li>CUDA Thrust sorted sparse histogram  &lt;0.4s</li>
</ul>
<p class="small">Packaged indexing into <strong>ThrustRap</strong> <em>ThrustIdx</em></p>
<ul class="small simple">
<li><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/numerics/thrustrap/">https://bitbucket.org/simoncblyth/env/src/tip/numerics/thrustrap/</a></li>
</ul>
</div>
<div class="slide" id="ggeoview-flag-selection">
<h1><span class="i">GGeoView Flag Selection</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Selection by flag sequence</p>
<p class="tiny last">Selection of scintillation photons by flag sequence (all boundary transmit) from a 100 GeV muon crossing Dayabay AD.
Primaries are simulated by Geant4, Scintillation &quot;steps&quot; of the primaries are transferred to the GPU.
The dots represent OptiX calculated photon steps with colors
corresponding to materials.</p>
</div>
</div>
<div class="slide" id="introducing-cuda-thrust">
<h1><span class="small">Introducing CUDA Thrust</span></h1>
<img alt="/env/numerics/thrust/thrust.png" class="align-right" src="/env/numerics/thrust/thrust.png" style="width: 400px;" />
<p class="small">Distributed with CUDA</p>
<ul class="small simple">
<li>C++ template library for CUDA based on STL</li>
<li>higher level way to use CUDA</li>
<li><a class="reference external" href="https://developer.nvidia.com/Thrust">https://developer.nvidia.com/Thrust</a></li>
</ul>
<p class="small"><span class="red">GPU performance without developing CUDA kernels</span></p>
</div>
<div class="slide" id="mobile-gpu-timings-for-cerenkov-and-scintillation-photons">
<h1><span class="small">Mobile GPU Timings for Cerenkov and Scintillation photons</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Avoid CPU for performance</p>
<ul class="small simple">
<li>allocation of ~700MB host memory dominates</li>
<li>workstation GPU core counts =&gt; <em>generatePropagate</em> will
become effectively zero</li>
</ul>
<p class="small">Once debugged can skip:</p>
<ul class="small simple">
<li>recording photon steps, indexing, OpenGL visualization</li>
<li>most host allocations</li>
</ul>
<p class="small">Possible approach:</p>
<ul class="small last simple">
<li>allocate GPU only photon buffers using Thrust</li>
<li>Thrust interop with OptiX to populate buffers</li>
<li>copy back just the hits using thrust::copy_if</li>
</ul>
</div>
 <pre class="mypre">
 max_record:10
 max_bounce:9
                    Cerenkov   Ck*4.59 Scintillation
           photons     0.61M      2.8M      2.8M
 --(bytes)--------------------------------------
      genstep size      736K                1.3M
      photons size       37M                172M
      records size       97M                430M
 --(seconds)------------------------------------
   createOpenGLCtx     0.692         -     0.599
      loadGeometry     1.570         -     1.302
    interpGeometry     0.211         -     0.190
         initOptiX     4.216         -     6.521

       loadGenstep     0.011         -     0.014
 hostEvtAllocation **  3.540    16.275    16.179
         uploadEvt     0.232     1.066     0.552

 generatePropagate ++  1.404     6.453     7.907

       evtDownload **  0.348     1.602     1.780
           evtSave **  0.437     2.008     2.006

     sequenceIndex     0.134     0.614     0.359
 -----------------------------------------------
                   ** scales by photon count


</pre></div>
<div class="slide" id="operation-with-juno-geometry">
<h1><span class="small">Operation with JUNO Geometry ?</span></h1>
<div class="sidebar">
<p class="first sidebar-title">OptiX Julia Set Sample</p>
<p class="small">Ray tracing with purely analytic geometry,
ie <span class="red">no triangles</span>. Application to PMTs may
allow drastic reduction in memory usage
and access costs.</p>
<img alt="/env/optix/raycast/julia.png" class="last align-right" src="/env/optix/raycast/julia.png" style="width: 463px;" />
</div>
<p class="small">The large number of PMTs may require a more memory
efficient geometry representation using OptiX features:</p>
<ul class="small simple">
<li>parameterized geometry avoids tesselation, like <em>Geant4</em></li>
<li>geometry instancing avoids duplication</li>
</ul>
<p class="small">Memory access (not calculation) typically limits GPU performance,
improving memory efficiency expected to improve performance.</p>
</div>
<div class="slide" id="next-steps">
<h1>Next Steps</h1>
<p class="small"><strong>Test New Framework with IHEP 4-GPU workstation (together with Tao Lin)</strong></p>
<ul class="small simple">
<li>check performance scaling across 4-GPU cores</li>
<li>attempt loading JUNO geometry</li>
<li>investigate more memory efficient geometry techniques</li>
</ul>
<p class="small"><strong>Optical Photon Simulation</strong></p>
<ul class="small simple">
<li>Complete porting Optical Physics</li>
<li>Instrument Geant4 optical photon propagation,
by recording photon steps into NPY array to <span class="red">enable step-by-step comparison</span></li>
<li>Debugging to <span class="red">achieve match between Geant4 and GPU</span> optical photon simulation,<ul>
<li>QE details to port</li>
</ul>
</li>
</ul>
<p class="small"><strong>G4DAE Geometry Exporter</strong></p>
<ul class="small simple">
<li>investigate issue inherited from GDML of a skipped
edge case (when a volume is shared between multiple volume pairs)
resulting in missing <em>G4LogicalBorderSurface</em></li>
<li>incorporate into Geant4 codebase</li>
</ul>
</div>
<div class="slide" id="backup-details-for-reference">
<h1><span class="small">&quot;Backup&quot; : Details for Reference</span></h1>
<p class="small">On the following pages:</p>
<ul class="small simple">
<li>GGeo/OptiX Generated Scintillation Photons cf Geant4</li>
<li>GGeo/OptiX Generated Cerenkov Photons cf Geant4</li>
<li>Cerenkov Photon Steps</li>
<li>C++ Infrastructure : foundation packages</li>
<li>C++ Infrastructure : domain packages</li>
<li>propagate_to_boundary : ABSORB(REEMIT) / SCATTER / survive</li>
<li>Comparison of GGeo/OptiX Generated Scintillation Photon Distributions</li>
<li>Comparison of GGeo/OptiX Generated Cerenkov Photon Distributions</li>
</ul>
</div>
<div class="slide" id="ggeo-optix-generated-scintillation-photons-cf-geant4">
<h1><span class="small">GGeo/OptiX Generated Scintillation Photons cf Geant4</span></h1>
<p class="small">GGeo/OptiX using inverted CDF reemission wavelength lookups (4096 bins)</p>
<img alt="/env/g4dae/generated_oxscintillation_time_wavelength.png" class="align-center" src="/env/g4dae/generated_oxscintillation_time_wavelength.png" style="width: 800px;" />
</div>
<div class="slide" id="ggeo-optix-generated-cerenkov-photons-cf-geant4">
<h1><span class="small">GGeo/OptiX Generated Cerenkov Photons cf Geant4</span></h1>
<p class="small">Geant4/DetSim wavelength distribution has a blip at 200nm, corresponding to edge of water
refractive index properties.</p>
<img alt="/env/g4dae/generated_oxcerenkov_time_wavelength.png" class="align-center" src="/env/g4dae/generated_oxcerenkov_time_wavelength.png" style="width: 800px;" />
</div>
<div class="slide" id="ggeoview-cerenkov-geom-m1">
<h1><span class="i">GGeoView Cerenkov Geom M1</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Cerenkov Photon Steps</p>
<p class="tiny last">Cerenkov photons steps from a 100 GeV muon crossing Dayabay AD.
Primaries are simulated by Geant4, Cerenkov  &quot;steps&quot; of the primaries are transferred to the GPU.
The dots represent OptiX calculated photon steps with colors
corresponding to materials.</p>
</div>
</div>
<div class="slide" id="c-infrastructure-foundation-packages">
<h1><span class="small">C++ Infrastructure : foundation packages</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Replacing Python, NumPy, PyZMQ</p>
<p class="small">Boost Libraries (filesystem, thread, program_options, logging, regex, ptree, Asio)
and Asio-ZMQ, ZMQ used to replace python packages.</p>
<p class="small">NPY format convenient for C++/Python interop:</p>
<pre class="tiny last literal-block">
a = np.load(&quot;photons.npy&quot;)
</pre>
</div>
<dl class="small docutils">
<dt><em>NPY</em></dt>
<dd><p class="first">Array persistency/manipulations inspired by NumPy,
using NPY serialization format</p>
<ul class="last simple">
<li>11 classes: G4StepNPY, PhotonsNPY, NPY, ...</li>
</ul>
</dd>
<dt><em>NumpyServer</em></dt>
<dd><p class="first">Asynchronous IO of Geant4 Steps, Photons, Hits.
Communicates with remote <em>G4DAEOpticks</em> process, receiving
steps and replying with hits.</p>
<ul class="last simple">
<li>7 classes : numpydelegate, udp_server, ...</li>
</ul>
</dd>
<dt><em>CUDAWrap</em></dt>
<dd><p class="first">cuRAND init and persist curandState (pure CUDA)</p>
<ul class="last simple">
<li>avoids large stack size requirement of cuRAND init within OptiX</li>
<li>5 classes : cuRANDWrapper, LaunchSequence, LaunchCommon, ..</li>
</ul>
</dd>
</dl>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/numerics/npy/">https://bitbucket.org/simoncblyth/env/src/tip/numerics/npy/</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/boost/basio/numpyserver/">https://bitbucket.org/simoncblyth/env/src/tip/boost/basio/numpyserver/</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/cuda/cudawrap/">https://bitbucket.org/simoncblyth/env/src/tip/cuda/cudawrap/</a></p>
</div>
<div class="slide" id="c-infrastructure-domain-packages">
<h1><span class="small">C++ Infrastructure : domain packages</span></h1>
<div class="sidebar">
<p class="first sidebar-title">Replacing Python packages</p>
<p class="small">Many C++ classes required to replace:</p>
<ul class="small simple">
<li>PyCOLLADA</li>
<li>PyOpenGL + glumpy + GLUT</li>
<li>daenode.py</li>
<li>g4daeview.py</li>
</ul>
<p class="small">Migration allows use of modern OpenGL 4.1:</p>
<ul class="small last simple">
<li>better visualization performance</li>
<li>retina resolution support</li>
<li>many GUI packages to choose from, picked <a class="reference external" href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a></li>
</ul>
</div>
<dl class="small docutils">
<dt><em>GGeo</em></dt>
<dd><p class="first">GPU Geometry representation, NPY persistency</p>
<ul class="last simple">
<li>22 classes: GNode, GMaterial, GProperty, ...</li>
</ul>
</dd>
<dt><em>AssimpWrap</em></dt>
<dd><p class="first">G4DAE -&gt; GGeo geometry</p>
<ul class="last simple">
<li>7 classes : AssimpGGeo, AssimpTree, ...</li>
</ul>
</dd>
<dt><em>OptiXRap</em></dt>
<dd><p class="first">GGeo -&gt; OptiX geometry, OptiX launch control</p>
<ul class="last simple">
<li>7 classes : OptiXEngine, OptixGeometry, ...</li>
</ul>
</dd>
<dt><em>OGLRap</em></dt>
<dd><p class="first">OpenGL shader based 3D visualization</p>
<ul class="last simple">
<li>29 classes : Scene, View, Camera, Rdr, Shdr, ...</li>
</ul>
</dd>
</dl>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/optix/ggeo/">https://bitbucket.org/simoncblyth/env/src/tip/optix/ggeo/</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/assimpwrap/">https://bitbucket.org/simoncblyth/env/src/tip/graphics/assimpwrap/</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/oglrap/">https://bitbucket.org/simoncblyth/env/src/tip/graphics/oglrap/</a></p>
<p class="tiny"><a class="reference external" href="https://bitbucket.org/simoncblyth/env/src/tip/graphics/optixrap/">https://bitbucket.org/simoncblyth/env/src/tip/graphics/optixrap/</a></p>
</div>
<div class="slide" id="propagate-to-boundary-absorb-reemit-scatter-survive">
<h1><span class="small">propagate_to_boundary : ABSORB(REEMIT) / SCATTER / survive</span></h1>
<pre class="mypre">
 __device__ int propagate_to_boundary( Photon& p, State& s, curandState &rng)
 {
      float absorption_distance = -s.material1.y*logf(curand_uniform(&rng));   // .y:absorption_length
      float scattering_distance = -s.material1.z*logf(curand_uniform(&rng));   // .z:scattering_length

      if (absorption_distance <= scattering_distance)
      {
          if (absorption_distance <= s.distance_to_boundary)
          {
              p.time += absorption_distance/(SPEED_OF_LIGHT/s.material1.x);    // .x:refractive_index
              p.position += absorption_distance*p.direction;

              if (curand_uniform(&rng) < s.material1.w) // .w:reemission_prob
              {
                   // non-scintillators have zero reemission_prob
                  p.wavelength = reemission_lookup(curand_uniform(&rng));
                  p.direction = uniform_sphere(&rng);
                  p.polarization = normalize(cross(uniform_sphere(&rng), p.direction));

                  s.flag = BULK_REEMIT ;
                  return CONTINUE;
              }
              else
              {
                  s.flag = BULK_ABSORB ;
                  return BREAK;
              }
          }
          //  otherwise sail to boundary
     }
     else
     // scattering ..
</pre></div>
<div class="slide" id="comparison-of-ggeo-optix-generated-scintillation-photon-distributions">
<h1><span class="small">Comparison of GGeo/OptiX Generated Scintillation Photon Distributions</span></h1>
<p class="small">Position, direction, polarization XYZ  + time, wavelength, weight</p>
<img alt="/env/g4dae/generated_oxscintillation_3xyzw.png" class="align-center" src="/env/g4dae/generated_oxscintillation_3xyzw.png" style="width: 700px;" />
</div>
<div class="slide" id="comparison-of-ggeo-optix-generated-cerenkov-photon-distributions">
<h1><span class="small">Comparison of GGeo/OptiX Generated Cerenkov Photon Distributions</span></h1>
<p class="small">Position, direction, polarization XYZ  + time, wavelength, weight</p>
<img alt="/env/g4dae/generated_oxcerenkov_3xyzw.png" class="align-center" src="/env/g4dae/generated_oxcerenkov_3xyzw.png" style="width: 700px;" />
</div>
<div class="slide" id="ggeoview">
<h1><span class="i">GGeoView</span></h1>
<div class="sidebar">
<p class="first sidebar-title">GGeoView</p>
<p class="tiny last">Cerenkov photons from an 100 GeV muon travelling from right to left across Dayabay AD.
Primaries are simulated by Geant4, Cerenkov &quot;steps&quot; of the primaries are transferred to the GPU.
The dots represent OptiX calculated first intersections of GPU generated photons with colors
corresponding to material boundaries: <span class="red">(red) GdDopedLS:Acrylic</span>,
<span class="green">(green) LiquidScintillator:Acrylic</span>, <span class="blue">(blue) Acrylic:LiquidScintillator</span>,
(white) IwsWater:UnstStainlessSteel, (grey) others.
The red lines represent the positions and directions of the &quot;steps&quot; with an
arbitrary scaling for visibility.</p>
</div>
</div>
</div>
</body>
</html>
