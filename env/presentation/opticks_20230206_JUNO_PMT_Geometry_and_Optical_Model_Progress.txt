.. meta::

   :title: Opticks + JUNO : PMT Geometry + Optical Model Progress
   :name: opticks_202302XX_JUNO_PMT_Geometry_and_Optical_Model_Progress.txt
   :description: (6 Feb 2023)
   :notes: Sim AFG Session 
   :url: https://juno.ihep.ac.cn/cgi-bin/Dev_DocDB/DisplayMeeting?conferenceid=1021
   :date: Sim AFS Session starts : Feb 6 19:30(11:30) Beijing(London) 

.. include:: my_s5defs.txt

.. include:: s5_background_image.txt


.. comment

    Hi Ziyan, 

    I can give a summary of progress over the past 6 months, 
    that will mostly cover already presented work at JOC + AFG meetings, 
    with title:

        Opticks + JUNO : PMT Geometry + Optical Model Progress

    That could easily fill 30 min. But as it will be a remote presentation 
    and hopefully many of the talks will be local I could try squeezing 
    to 20 min if the schedule needs compression. 

    Simon

    Simon Blyth, Opticks + JUNO : PMT Geometry + Optical Model Progress, 15 min

    and the sim afg session will start at 19:30 on Feb. 6




:i:`Opticks + JUNO : PMT Geometry + Optical Model Progress` 
===========================================================================================

.. raw:: html

    <div class="mytitle">
        <header>
            <h1 style="background-color:lightgrey"> 
                Opticks + JUNO : PMT Geometry + Optical Model Progress
                <h2 style="background-color:lightgrey;text-align:center"> Open source, https://bitbucket.org/simoncblyth/opticks </h2>
            </h1>
        </header>
    </div>
    <p style="margin-bottom:52mm;" />

.. class:: large

  *junoPMTOpticalModel* CPU tests reveal issues, all from FastSim use:

  * :r:`over complex PMT geometry and Geant4 step histories`
  * inconsistent polarization and propagation time within PMT 

  Replacing FastSim use with a *CustomG4OpBoundaryProcess*: 

  * fixes all issues using a more standard approach
  * :b:`simpler geometry, simpler simulation history, less code` 
  * would facilitate bringing PMT Optical Model to GPU within Opticks

    * as more standard : mostly done already

.. raw:: html

    <div class="mycredit">
       <h2 style="background-color:lightgrey"> Simon C Blyth, IHEP, CAS  &mdash; 6 Feb 2023 </h2>
    </div>


.. s5_talk:: 

    Focus of last months on simulation reinmplementation, now returning to geometry



.. comment

    2019_CHEP_Adelaide_0.jpg
    -------------------------

    2019_CHEP_Adelaide_1.jpg
    -------------------------



junoPMTOpticalModel Issues : All from using FastSim 
----------------------------------------------------

.. sidebar:: :small:`CustomG4OpBoundaryProcess ?`

    .. class:: small

         * simple 2 volume (Pyrex+Vacuum) geometry 
         * standard G4OpBoundaryProcess reflect/refract/absorb/TIR 
         * much less code : reuse of standard Geant4
         * easier Opticks on GPU : simpler, more standard
 
           * no near-degenerate 1e-3 mm boundaries
           * allows same geometry on CPU and GPU 
           * avoid history rewriting for comparisons 
          
         **BUT : need to change very nasty Geant4 impl:**

         ``G4OpBoundaryProcess::PostStepDoIt``
             ugly monolith, rats nest of nested ifs 

         * Unpleasant to get familiar with 
         * Change palatable, using : ``CustomART.h``
         * Keep change separated, detailed validation vital 
                

.. raw:: html

   <p style="margin-bottom:1cm;" />


.. class:: small

   1. :r:`Four volume PMT due to FastSim limitation`

      * Two volumes (Pyrex + Vacuum) would be natural 

.. raw:: html

   <p style="margin-bottom:1cm;" />

.. class:: small

   2. Fake volumes yield many fake intersects

      * Pyrex/Pyrex + Vacuum/Vacuum same material fakes
      * :b:`complicates Geant4 step point history` 
      * :b:`complicates comparison with Opticks`

.. raw:: html

   <p style="margin-bottom:1cm;" />

.. class:: small

   3. Non-FastSim in PMT propagates at Pyrex (not Vacuum) speed

      * FastSim->SlowSim transition misses speed fixup 

.. raw:: html

   <p style="margin-bottom:1cm;" />

.. class:: small

   4. :r:`reflected + refracted polarization doesnt follow Geant4`

      * should follow G4OpBoundaryProcess, depending on S/P 

.. raw:: html

   <p style="margin-bottom:0.1cm;" />

.. class:: small

   * :b:`All issues stem from using FastSim (designed for regions)`
 
     * :b:`not good fit for 1 boundary (Pyrex/ARC/PHC/Vacuum)`


.. comment

    .. class:: small

       6. TODO: look into _qe definition 

          * justification for ``efficiency=_qe/An`` ? 



:small:`Polarization on FresnelReflection/FresnelRefraction/TotalInternalReflection`
---------------------------------------------------------------------------------------

.. sidebar:: :small:`inline sboundary::sboundary():`

    .. raw:: html

        <pre class="mypretiny">
        _E2_t(make_float2( 2.f*n1c1/(n1c1+n2c2) , 
                           2.f*n1c1/(n2c1+n1c2) )),// (ts,tp) 
        _E2_r(make_float2( _E2_t.x - 1.f       , 
                           n2*_E2_t.y/n1 - 1.f  )),// (rs,rp)
        A_transverse(cross(p.mom, orient*normal)),
        E1_perp(dot(p.pol, A_transverse)),
        E1(make_float2(E1_perp,sqrtf(1.f-E1_perp*E1_perp)))),
        E2_t(_E2_t*E1),RR(normalize(E2_r)), 
        E2_r(_E2_r*E1),TT(normalize(E2_t)), 
        {
        p.mom = reflect
              ?
                 p.mom + 2.0f*c1*orient*normal
              :
                 eta*(p.mom) + (eta*c1 - c2)*orient*normal
              ;
        A_parallel = normalize(cross(p.mom, A_transverse));   

        <span class="b">p.pol = 
                ( reflect ?
                     ( tir ? 
                           -p.pol + 2.f*EdotN*orient*normal 
                     : 
                           RR.x*A_transverse + RR.y*A_parallel 
                     )
                  :
                     TT.x*A_transverse + TT.y*A_parallel
                )
              ;</span>
        }
        </pre>


.. class:: small

   **Reflect/Refract Polarization** 

.. raw:: html

    <pre class="mypretiny">
     void junoPMTOpticalModel::Reflect()
     {
         dir -= 2.*(dir*norm)*norm;
         <span class="r">pol -= 2.*(pol*norm)*norm;</span> <span class="b">// similar to G4 TIR pol, NOT Fresnel </span> 
     }
     void junoPMTOpticalModel::Refract()
     {
         dir = (real(_cos_theta4) - 
                _cos_theta1*_n1/_n4)*norm + (_n1/_n4)*dir;
         <span class="r">pol = (pol-(pol*dir)*dir).unit();</span>
     }
    </pre>


.. class:: small

   ``G4OpBoundaryProcess`` polarization from:

   1. S/P Fresnel Coeff 
   2. S/P Directions : out/in plane of incidence

   **Opticks : sysrap/sboundary.h qudarap/qsim.h follows G4, ===>**

   * `opticks/src/master/sysrap/sboundary.h <https://bitbucket.org/simoncblyth/opticks/src/master/sysrap/sboundary.h>`_

    
   **Derive Fresnel from Maxwell Boundary Conditions**

   *Fresnel Equations, Alexander I. Lvovsky*
     *Encylopedia of Optical Engineering* (**fresnel-eoe.pdf**)



:small:`Compare Reflected Polarization Impls for Brewster Angle Incidence`
---------------------------------------------------------------------------

.. class:: small 

   * `opticks/src/master/sysrap/tests/sboundary_test.sh <https://bitbucket.org/simoncblyth/opticks/src/master/sysrap/tests/sboundary_test.sh>`_ : build, run, plot


.. image:: sboundary_test/figs/sboundary_test/pvcap/AOI_BREWSTER_linear_polarization_by_reflection.png
    :width: 550px

.. image:: sboundary_test/figs/sboundary_test/pvcap/AOI_BREWSTER_reflect_alt_pol.png
    :width: 550px

.. class:: small

    +---------------------------------------------------------------------+------------------------------------------------+
    | G4OpBoundaryProcess/qsim.h/sboundary.h : Only S-polarized survives  | junoPMTOpticalModel::Reflect : very different  |
    +---------------------------------------------------------------------+------------------------------------------------+

    * incident from left (-X), surface normal vertically upwards (+Z), intersection point in middle, 
    * Colored lines represent polarization directions of 128 photons before and after Reflection 
    * Reflected using ``sboundary.h`` (validated against ``G4OpBoundaryProcess``)
    * Compared with ``sboundary.h:alt_pol`` that duplicates ``junoPMTOpticalModel::Reflect``  

    Brewster (or polarizing) incident angle th1 : ``tan(th1) = n2/n1  ;  th1 + th2 = pi/2``



AOI_BREWSTER_linear_polarization_by_reflection.png
----------------------------------------------------

AOI_BREWSTER_reflect_alt_pol.png
----------------------------------


.. comment

    AOI_CRITICAL_tir_pol.png
    ---------------------------



:small:`Compare Refracted Polarization Impls for Brewster Angle Incidence`
--------------------------------------------------------------------------- 

.. class:: small 

   * `opticks/src/master/sysrap/tests/sboundary_test.sh <https://bitbucket.org/simoncblyth/opticks/src/master/sysrap/tests/sboundary_test.sh>`_ : build, run, plot


.. image:: sboundary_test/figs/sboundary_test/pvcap/AOI_BREWSTER_brewster_refract.png
    :width: 550px 

.. image:: sboundary_test/figs/sboundary_test/pvcap/AOI_BREWSTER_brewster_refract_alt_pol.png
    :width: 550px 


.. class:: small

    +-----------------------------------------------------------------+------------------------------------------------------+
    |  G4OpBoundaryProcess/qsim.h/sboundary.h : partial pol           | junoPMTOpticalModel::Refract : not partially pol     |
    +-----------------------------------------------------------------+------------------------------------------------------+

    * incident from left (-X), surface normal vertically upwards (+Z), intersection point in middle, 
    * Colored lines represent polarization directions of 128 photons before and after Refraction
    * Refracted using ``sboundary.h`` (compared with **alt_pol** that duplicates junoPMTOpticalModel::Refract )



AOI_BREWSTER_brewster_refract.png
-------------------------------------

AOI_BREWSTER_brewster_refract_alt_pol.png
-------------------------------------------


.. comment

    :i:`LayrTest_R12860_ARTQspx.png`
    ---------------------------------

    :i:`LayrTest_R12860_Aspx.png` 
    ------------------------------

    :i:`LayrTest_R12860_Rspx.png` 
    ------------------------------

    :i:`LayrTest_R12860_Tspx.png` 
    ------------------------------



:i:`LayrTest_4_ARTQspx_R12860_4layer.png`
-------------------------------------------

:i:`LayrTest_4_AQspx_R12860_4layer.png`
-----------------------------------------

:i:`LayrTest_4_Rspx_R12860_4layer.png`
-----------------------------------------

:i:`LayrTest_4_Tspx_R12860_4layer.png`
-----------------------------------------




:i:`LayrTest_2_ARTQspx_R12860_2layer.png`
--------------------------------------------

:i:`LayrTest_2_AQspx_R12860_2layer.png`
-----------------------------------------

:i:`LayrTest_2_Rspx_R12860_2layer.png`
-----------------------------------------

:i:`LayrTest_2_Tspx_R12860_2layer.png`
-----------------------------------------







:small:`Standalone few PMT test : N=0/1 junoPMTOpticalModel/CustomART.h` 
---------------------------------------------------------------------------

.. class:: small

    **Minor changes for standalone use** ``#ifdef PMTFASTSIM_STANDALONE``

    * ``JPMT.h`` parameter access (not PMTSimParamSvc, PMTParamSvc)
    * https://github.com/simoncblyth/j/blob/main/PMTFastSim/junoPMTOpticalModel.cc
    * https://github.com/simoncblyth/j/blob/main/PMTFastSim/HamamatsuR12860PMTManager.cc
    * ``N=0/1`` **bool m_natural_geometry = false/true**

    **Optical only Geant4 simulation, with full step point recording**  

    * https://bitbucket.org/simoncblyth/opticks/src/master/u4/tests/U4SimulateTest.sh

    ``N=0/1 ./U4SimulateTest.sh``

    **Geant4 Simtrace intersection : for 2D geometry plotting**  

    * https://bitbucket.org/simoncblyth/opticks/src/master/u4/tests/U4SimtraceTest.sh

    ``N=0/1 ./U4SimtraceTest.sh``

    **CustomART integrated with InstrumentedG4OpBoundaryProcess**

    * https://bitbucket.org/simoncblyth/opticks/src/master/u4/CustomART.h  (uses ``Layr.h`` for TMM calcs)
    * https://bitbucket.org/simoncblyth/opticks/src/master/u4/InstrumentedG4OpBoundaryProcess.cc
    



hamaLogicalPMTWrapLV_old.png
--------------------------------

``hama_UsePMTOpticalModel=0 REVERSE=1 NOGS=1 ~/opticks/extg4/xxv.sh``

.. class:: normal

   |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp|
   :g:`body` hidden under :r:`pmt` : :huge:`WHY?`



:small:`Old PMT Optical Model : G4 Optical Surfaces photocathode, mirror`
--------------------------------------------------------------------------- 

.. sidebar:: :small:`Old Surface POM`

    .. raw:: html 

       <pre class="mypretiny">
         +---------------pmt-Pyrex----------------+
         | +-------------body-Pyrex-------------+ |
         | |                                    | |
         | |                                    | |
         | |     +------------------------+     | |
         | |     |                        |     | |
         | |     |                        |     | |
         | |     |        inner1-Vacuum   |     |-|
         | |     |                        |     |1e-3
         | |     |                        |     | |
         | |     +~~coincident~face~~~~~~~+     | |
         | |     |                        |     | |
         | |     |                        |     | |
         | |     |        inner2-Vacuum   |     | |
         | |     |                        |     | |
         | |     |                        |     | |
         | |     +------------------------+     | |
         | |                                    | |
         | |                                    | |
         | +------------------------------------+ |
         +----------------------------------------+
       </pre>

    .. class:: small

       :r:`photons DO NOT enter PMT vacuum`


.. class:: small

   +------------------------+----------------+---------+
   | m_Photocathode_opsurf  | inner1<->body  | pv<->pv |
   +------------------------+----------------+---------+
   | m_mirror_opsurf        | inner2<->body  | pv<->pv |
   +------------------------+----------------+---------+

   **Why pmt+body Pyrex (1e-3 mm separation) ? GUESS:** 

   1. avoid G4LogicalBorderSurface for every PMT, as 1 body pv
   2. keeps PMT manager self-contained

   **Why split vacuum inner1/inner2 ?**

   * convenient for photocathode and mirror properties
   * BUT: fake Vacuum/Vacuum coincident face inside PMT 
   
     * :b:`no problem : as no photon enter PMT` 

   **Alternatively : with CustomG4OpBoundaryProcess** 

   * Two Volume PMT : Pyrex + Vacuum (Instead of Four)  
   * mirror_opsurf G4LogicalSkinSurface 

     * Skin not Border: so only need LV

   * custom override to Photocathode_opsurf for local_z > 0. 

   :b:`Effectively : -Z:mirror +Z:photocathode` 
      NOT YET IMPLEMENTED : SEEMS DOABLE 


hamaLogicalPMT_natural.png 
----------------------------


.. comment

    hamaLogicalPMTWrapLV_orig.png
    --------------------------------

    ``hama_UsePMTOpticalModel=1 ~/opticks/extg4/xxv.sh``





hamaLogicalPMT_fake.png
-------------------------

.. raw:: html

    <p style="margin-bottom:3cm;" />


.. class:: normal

   |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp|
   :c:`body` hidden under :m:`inner1` :y:`inner2` 

   |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp|
   :c:`body` is :r:`FastSim envelope volume`







:small:`junoPMTOpticalModel FastSim : Fake Volumes -> Contorted ModelTrigger`
--------------------------------------------------------------------------------

.. sidebar:: :small:`Current MultiLayer POM`

    .. raw:: html 

       <pre class="mypretiny">
         +---------------pmt-Pyrex----------------+
         |                                        |
         |                                        |
         |     +----body-Pyrex-(FSim-env)---+     |
         |     | +------------------------+ |     |
         |     | |                        | |     |
         |     | |                        | |     |
         |     | |        inner1-Vacuum   |-|     |
         |     | |                        |1e-3   |
         |     | |                        | |     |
         |     | +~~coincident~face~~~~~~~+ |     |
         |     | |                        | |     |
         |     | |                        | |     |
         |     | |        inner2-Vacuum   | |     |
         |     | |                        | |     |
         |     | |                        | |     |
         |     | +------------------------+ |     |
         |     +----------------------------+     |
         |                                        |
         |                                        |
         +----------------------------------------+
       </pre>

    .. class:: small

       * *ModelTrigger* : unnatural trig @ Vac/Vac bnd. 
       * *DoIt* : shift to edge, for ART calc 
       * only *m_mirror_opsurf* (inner2<->body) "active"


.. raw:: html

   <pre class="mypretiny">
     80 G4bool junoPMTOpticalModel::ModelTrigger(const G4FastTrack &fastTrack)
     81 {   // <span class="r"> Contorted as "pre-trigger" on where next </span>
     83     if(fastTrack.GetPrimaryTrack()->GetVolume() == _inner2_phys){
     84         return false;
     85     }
     ...
     89     pos     = fastTrack.GetPrimaryTrackLocalPosition();
     90     dir     = fastTrack.GetPrimaryTrackLocalDirection();
     94     
     95     if(fastTrack.GetPrimaryTrack()->GetVolume() == _inner1_phys){
     96         whereAmI = kInVacuum;
     97     }else{
     98         whereAmI = kInGlass;
     99     }
    100    
    101     if(whereAmI == kInGlass){
    102         dist1 = _inner1_solid->DistanceToIn(pos, dir);
    103         dist2 = _inner2_solid->DistanceToIn(pos, dir);
    104
    105         if(dist1 == kInfinity){
    106             return false;
    107         }else if(dist1>dist2){
    108             return false;
    109         }else{
    110             return true;
    111         }
    112     }else{
    113         dist1 = _inner1_solid->DistanceToOut(pos, dir);
    114         dist2 = _inner2_solid->DistanceToIn(pos, dir);
    115         
    116         if(dist2 == kInfinity){
    117             return true;
    118         }
    119     }
    120     return false;
    121 }   
  </pre>


:small:`FastSim Big Bouncer : Collect ModelTrigger positions, decisions` 
---------------------------------------------------------------------------

.. sidebar:: :small:`SFastSim_Debug.hh`

    .. raw:: html

       <pre class="mypretiny">
        struct SYSRAP_API SFastSim_Debug
        {   
            static std::vector&lt;SFastSim_Debug&gt; record ;   
            static constexpr const char* NAME = "SFastSim_Debug.npy" ; 
            static constexpr int LIMIT = 100000 ; 
            static void Save(const char* dir); 
            void add(); 

            double posx ;  // fs[:,0,:3]
            double posy ;
            double posz ;
            double time ;  // fs[:,0,3]

            double dirx ;  // fs[:,1,:3]
            double diry ;
            double dirz ;
            double dist1 ; // fs[:,1,3]

            double polx ;  // fs[:,2,:3]
            double poly ;
            double polz ;
            double dist2 ; // fs[:,2,3]

            double ModelTrigger; // fs[:,3,0].astype(np.int64)
            double whereAmI ;    // fs[:,3,1].astype(np.int64)
            double c ;           // fs[:,3,2]
            double PhotonId ;    // fs[:,3,3].astype(np.int64)
       };
       </pre>

.. raw:: html

   <pre class="mypre12">
   epsilon:tests blyth$ PID=726 ./U4SimulateTest.sh nana 
    In [1]: extra.shape
    Out[1]: (14, 4, 4)
    In [2]: extra
    Out[2]: 
    array([[[-112.83 ,    0.   ,  164.918,    0.164],
            [   0.032,    0.   ,   -0.999,    0.001],    // dist1:1e-3 mm 
            [   0.   ,   -1.   ,    0.   ,  165.005],
            [  <span class="r"> 1.</span>   ,    1.   ,    0.   ,  726.   ]], ##<span class="r"> ModelTrigger:1 </span>

           [[-112.83 ,    0.   ,  164.917,    0.164],
            [  -0.138,    0.   ,   -0.99 ,  166.512],    // dist1 and dist2 equal
            [   0.   ,   -1.   ,    0.   ,  166.512],
            [  <span class="b"> 0.</span>   ,    2.   ,    0.   ,  726.   ]], ##<span class="b"> ModelTrigger:0 </span>

           [[-156.577,    0.   , -148.846,    1.778],
            [   0.81 ,    0.   ,    0.587,  253.614],
            [   0.   ,    1.   ,    0.   ,    0.   ],
            [   0.   ,    1.   ,    0.   ,  726.   ]],

           [[ -95.   ,    0.   , -104.211,    2.166],
            [  -0.81 ,    0.   ,    0.587,  177.561],
            [   0.   ,   -1.   ,    0.   ,  169.042],
            [   0.   ,    1.   ,    0.   ,  726.   ]],

           [[-238.764,    0.   ,   -0.   ,    3.071],
            [  -0.81 ,    0.   ,    0.587,   12.404],
            [   0.   ,   -1.   ,    0.   ,   -1.   ],
            [   1.   ,    2.   ,    0.   ,  726.   ]],
            ...
   </pre>

.. class:: small

   *ModelTrigger* "pre-triggering" *dist1* ahead as *DoIt* will shift by **dist1**   

   * :r:`Complication arising from unnatural geometry`
   * :b:`Workaround G4 FastSim needing Region, not boundary` 



hamaLogicalPMTWrapLV_ModelTriggerYES.png
------------------------------------------

.. raw:: html

   <p style="margin-bottom:0.1cm;" />

.. class:: small

   |emsp| |emsp| |emsp| |emsp| |emsp| Starts at upper left, here -->  

.. raw:: html

   <p style="margin-bottom:14cm;" />

.. class:: small

   * FastSim Workaround -> DoIt **dist1** shifts -> Effectively "Pre-Triggering" : slide red dots forwards 
   



hamaLogicalPMTWrapLV_ModelTriggerNO.png
------------------------------------------


.. raw:: html

   <p style="margin-bottom:15.5cm;" />

.. class:: small

   * :b:`blue dots` : ModelTrigger:NO : within FastSim region, but handled by SlowSim








:small:`junoPMTOpticalModelSimple : Natural Geometry -> Simple ModelTrigger`
--------------------------------------------------------------------------------

.. sidebar:: :small:`Simplified MultiLayer POM`

    .. raw:: html 

       <pre class="mypretiny">
         +---------------pmt-Pyrex----------------+
         |                                        |
         |                                        |
         |                                        |
         |       +~inner~Vacuum~(FSim~env)+       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       +                        +       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       +------------------------+       |
         |                                        |
         |                                        |
         |                                        |
         +----------------------------------------+
       </pre>

    .. class:: small

       * *ModelTrigger* : z>0 : no unnatural trig 
       * override *mirror_opsurf* (inner<->pmt) @ z > 0 
       * simpler *DoIt* : no geom. queries, no shifting

.. raw:: html

   <p style="margin-bottom:6cm;" />
   <pre class="mypretiny">
    G4bool junoPMTOpticalModelSimple::ModelTrigger(
            const G4FastTrack &fastTrack)
    {
         // <span class="r"> Simple + Cheap due to natural geometry </span>
        return fastTrack.GetPrimaryTrackLocalPosition().z() > 0. ;
    }
   </pre>
        
.. class:: small

   https://github.com/simoncblyth/j/blob/main/PMTFastSim/junoPMTOpticalModelSimple.cc
    

:small:`junoPMTOpticalModelSimple : Natural Geometry -> Simple DoIt`
--------------------------------------------------------------------------------

.. sidebar:: :small:`Simplified MultiLayer POM`

    .. raw:: html 

       <pre class="mypretiny">
         +---------------pmt-Pyrex----------------+
         |                                        |
         |                                        |
         |                                        |
         |       +~inner~Vacuum~(FSim~env)+       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       +                        +       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       +------------------------+       |
         |                                        |
         |                                        |
         |                                        |
         +----------------------------------------+
       </pre>

    .. class:: small

       * *ModelTrigger* : z>0 : no unnatural trig 
       * override *mirror_opsurf* (inner<->pmt) @ z > 0 
       * simpler *DoIt* : no geom. queries, no shifting

.. raw:: html

   <pre class="mypretiny">
    void junoPMTOpticalModelSimple::DoIt(const G4FastTrack& fastTrack, 
          G4FastStep &fastStep)
    {
        G4double energy = fastTrack.GetPrimaryTrack()->GetKineticEnergy();
        wavelength_nm = twopi*hbarc/energy/nm ;

        position = fastTrack.GetPrimaryTrackLocalPosition();
        direction = fastTrack.GetPrimaryTrackLocalDirection();
        polarization = fastTrack.GetPrimaryTrackLocalPolarization();

        G4VSolid* envelope_solid = fastTrack.GetEnvelopeSolid();
        surface_normal = envelope_solid->SurfaceNormal(position);

        minus_cos_theta = direction*surface_normal ;
        whereAmI = minus_cos_theta < 0. ? kInGlass : kInVacuum ;

        StackSpec<double> spec ;
        // ... skip : collect refractive indices, thickness into spec ...

        Stack<double,4> stack(      wavelength_nm, minus_cos_theta, spec );
        Stack<double,4> stackNormal(wavelength_nm, -1.            , spec );
        // ...
   }
   </pre>


.. class:: small

   * :r:`Simple : BUT NOT WORKABLE`
   * :b:`Cannot stop:` ``G4OpBoundaryProcess`` 
   
     * **REAL REASON FOR THE FAKE VOLUMES** 
     * Workaround limitations of Geant4 FastSim


:small:`Pivot to CustomG4OpBoundaryProcess For PMT Optical Model ?`
-------------------------------------------------------------------

.. sidebar:: :small:`Custom Boundary POM`

    .. raw:: html 

       <pre class="mypretiny">
         +---------------pmt-Pyrex----------------+
         |                                        |
         |                                        |
         |                                        |
         |       +~inner~Vacuum~~~~~~~~~~~+       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       !                        !       |
         |       +                        +       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       |                        |       |
         |       +------------------------+       |
         |                                        |
         |                                        |
         |                                        |
         +----------------------------------------+
       </pre>

    .. class:: small

       ``OpSurfaceName[0] == '@'``

       * ``local_z>0`` : does MultiLayer ART calc 
       * ``!(local_z>0)`` : standard *mirror_opsurf*

.. class:: small

  
 
   * Cannot use natural geometry with FastSim

     * SO: ``CustomG4OpBoundaryProcess``

   * same TMM calc, less code, simpler code
   * half the geometry objects to model PMT (4->2)

   +----------------------+-----------------------+
   | Current FastSim POM  | 4 Solid, 4 LV, 4 PV   |
   +----------------------+-----------------------+
   | Custom Boundary POM  | 2 Solid, 2 LV, 2 PV   | 
   +----------------------+-----------------------+
 

:small:`u4/CustomART.h : include into CustomG4OpBoundaryProcess.cc`
-----------------------------------------------------------------------

.. sidebar:: :small:`CustomART<J>::maybe_doIt`

    .. raw:: html

      <pre class="mypretiny">
      template&lt;typename J&gt;
      inline char CustomART&lt;J&gt;::maybe_doIt(
           const char* OpticalSurfaceName, 
           const G4Track& aTrack, const G4Step& aStep )
      {   
          if( OpticalSurfaceName == nullptr || 
              OpticalSurfaceName[0] != '@') return 'N' ;
          
          const G4AffineTransform& transform = 
            aTrack.GetTouchable()
            ->GetHistory()->GetTopTransform();

          G4ThreeVector localPoint = 
            transform.TransformPoint(theGlobalPoint);

          if(localPoint.z() <= 0) return 'Z' ;
          
          return doIt(aTrack, aStep) ;
      }
      </pre>
             

    .. class:: small

      *doIt* TMM calc, runs only for:
 
      * OpticalSurfaceName[0]=='@' && zlocal > 0  
      * -> Transmittance, Reflectivity, Efficiency  
      * TMM calc using Layr.h multi-layer Stack 

.. raw:: html

    <pre class="mypretiny">
    &#35;include "JPMT.h"
    &#35;include "Layr.h"    
    &#35;include "U4Touchable.h"

    template&lt;typename J&gt; struct CustomART
    {
        J* parameter_accessor ; 
        
        <span class="b">G4double& theTransmittance ;
        G4double& theReflectivity ;
        G4double& theEfficiency ;</span> 
        
        const G4ThreeVector& theGlobalPoint ;
        const G4ThreeVector& OldMomentum ;  
        const G4ThreeVector& OldPolarization ;
        const G4ThreeVector& theRecoveredNormal ;
        const G4double& thePhotonMomentum ; 
        
        CustomART(
            G4double& theTransmittance,
            G4double& theReflectivity,
            G4double& theEfficiency,
            const G4ThreeVector& theGlobalPoint,
            const G4ThreeVector& OldMomentum,  
            const G4ThreeVector& OldPolarization,
            const G4ThreeVector& theRecoveredNormal,
            const G4double& thePhotonMomentum
        );  
        char maybe_doIt(const char* OpticalSurfaceName, 
                  const G4Track& aTrack, const G4Step& aStep );
        char doIt(const G4Track& aTrack, const G4Step& aStep ); 
    };  
    </pre>

.. class:: small

   `opticks/src/master/u4/CustomART.h <https://bitbucket.org/simoncblyth/opticks/src/master/u4/CustomART.h>`_



:i:`hamaLogicalPMTWrapLV_full_history.png`
--------------------------------------------

.. raw:: html

   <p style="margin-bottom:16.5cm;" />

.. raw:: html

   <pre class="mypre20">   
   TO  BT  BT  BT  BT  SR  SR  BT  BR  BR  BT  SR  SR  SR  BT  BR  BT  SR  BT  SA    
   00  01 [02] 03 [04] 05  06 [07] 08  09 [10] 11  12  13 [14] 15 [16] 17 [18] 19   (7/20 Fake)
   </pre>


:i:`hamaLogicalPMTWrapLV_natural.png`
--------------------------------------

.. raw:: html

   <p style="margin-bottom:16.5cm;" />

.. raw:: html

   <pre class="mypre20">   
   TO  BT  BT  SR  SR  BR  BR  SR  SR  SR  BR  SR  BR <span class="r"> SR  SA</span>
   00  01  02  03  04  05  06  07  08  09  10  11  12 <span class="r"> 13  14</span> 
   00  01  03  05  06  08  09  11  12  13  15  17  19  
   </pre>





:small:`Compare "big bouncer" position, time between N=0,1 (1)`
------------------------------------------------------------------

.. raw:: html

    <pre class="mypretiny">
    u4t ; ./U4SimulateTest.sh cf

    In [12]: np.c_[ar[:,0],np.arange(len(ar)),br[:,0]]
    Out[12]: 
    array([[-113.   ,    0.   ,  200.   ,    0.   ,    0.   , -113.   ,    0.   ,  200.   ,    0.   ],
           [-113.   ,    0.   ,  170.163,    0.137,    1.   , -113.   ,    0.   ,  170.163,    0.137],
           [-112.83 ,    0.   ,  164.918,    0.164,    2.   , -112.83 ,    0.   ,  164.917,    0.164],
           [-112.83 ,    0.   ,  164.917,    0.164,    3.   , -156.577,    0.   , -148.846,    1.22 ],
           [-135.824,    0.   ,    0.   ,    1.012,    4.   ,  -95.   ,    0.   , -104.211,    1.474],
           [-156.577,    0.   , -148.846,    1.778,    5.   , -248.807,    0.   ,    7.28 ,    2.108],
           [ -95.   ,    0.   , -104.211,    2.166,    6.   ,   53.206,    0.   ,  180.727,    3.269],
           [-238.764,    0.   ,   -0.   ,    3.071,    7.   ,  245.605,    0.   ,  -35.443,    4.235],
           [-248.807,    0.   ,    7.28 ,    3.112,    8.   ,   95.   ,    0.   ,  -99.428,    4.781],
           [  53.205,    0.   ,  180.727,    4.274,    9.   ,  177.724,    0.   , -134.574,    5.08 ],
           [ 214.06 ,    0.   ,    0.   ,    5.507,   10.   ,  141.059,    0.   ,  152.451,    6.046],
           [ 245.605,    0.   ,  -35.443,    5.749,   11.   , -239.66 ,    0.   ,  -55.195,    7.492],
           [  95.   ,    0.   ,  -99.428,    6.583,   12.   ,  237.91 ,    0.   ,   54.597,    9.127],
           [ 177.724,    0.   , -134.574,    7.041,   13.   ,   50.   ,    0.   ,  -63.74 ,    9.867],
           [ 160.533,    0.   ,    0.   ,    7.732,   14.   ,   58.352,    0.   ,  -69.   ,    9.9  ],
           [ 141.059,    0.   ,  152.451,    8.245,   15.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [-138.46 ,    0.   ,    0.   ,    9.867,   16.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [-239.66 ,    0.   ,  -55.195,   10.455,   17.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [   0.427,    0.   ,    0.   ,   11.71 ,   18.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [ 237.91 ,    0.   ,   54.596,   12.523,   19.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [   0.   ,    0.   ,    0.   ,    0.   ,   20.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [   0.   ,    0.   ,    0.   ,    0.   ,   21.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [   0.   ,    0.   ,    0.   ,    0.   ,   22.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [   0.   ,    0.   ,    0.   ,    0.   ,   23.   ,    0.   ,    0.   ,    0.   ,    0.   ],

    </pre>
    
.. class:: small

    +----+-----------------+------------------+---------------------------------------+
    | ar | a.record[PID]   | N=0 current geom | degenerate and fake intersect points  |
    +----+-----------------+------------------+---------------------------------------+
    | bb | b.record[PID]   | N=1 natural geom | less points, simpler history          |
    +----+-----------------+------------------+---------------------------------------+

    :r:`Need point-to-point mapping to compare`





:small:`Compare "big bouncer" position, time between N=0,1 (2)`
------------------------------------------------------------------

.. raw:: html

    <pre class="mypretiny">
    u4t ; ./U4SimulateTest.sh cf

    In [2]: b2a  ## point-to-point mapping to skip a fakes  
    Out[2]: array([ 0,  1,  3,  5,  6,  8,  9, 11, 12, 13, 15, 17, 19])

    In [4]: abr = np.c_[ar[b2a,0],br[:len(b2a),0],ar[b2a,0]-br[:len(b2a),0]] ; abr
    Out[4]: 
    array([[-113.   ,    0.   ,  200.   ,    0.   , -113.   ,    0.   ,  200.   ,    0.   ,    0.   ,    0.   ,    0.   ,    0.   ],
           [-113.   ,    0.   ,  170.163,    0.137, -113.   ,    0.   ,  170.163,    0.137,    0.   ,    0.   ,    0.   ,    0.   ],
           [-112.83 ,    0.   ,  164.917,    0.164, -112.83 ,    0.   ,  164.917,    0.164,    0.   ,    0.   ,    0.   ,   -0.   ],
           [-156.577,    0.   , -148.846,    1.778, -156.577,    0.   , -148.846,    1.22 ,   -0.   ,    0.   ,    0.   ,    0.558],
           [ -95.   ,    0.   , -104.211,    2.166,  -95.   ,    0.   , -104.211,    1.474,    0.   ,    0.   ,    0.   ,    0.692],
           [-248.807,    0.   ,    7.28 ,    3.112, -248.807,    0.   ,    7.28 ,    2.108,    0.   ,    0.   ,   -0.   ,    1.004],
           [  53.205,    0.   ,  180.727,    4.274,   53.206,    0.   ,  180.727,    3.269,   -0.   ,    0.   ,    0.   ,    1.004],
           [ 245.605,    0.   ,  -35.443,    5.749,  245.605,    0.   ,  -35.443,    4.235,    0.   ,    0.   ,    0.   ,    1.514],
           [  95.   ,    0.   ,  -99.428,    6.583,   95.   ,    0.   ,  -99.428,    4.781,    0.   ,    0.   ,    0.   ,    1.802],
           [ 177.724,    0.   , -134.574,    7.041,  177.724,    0.   , -134.574,    5.08 ,    0.   ,    0.   ,    0.   ,    1.96 ],
           [ 141.059,    0.   ,  152.451,    8.245,  141.059,    0.   ,  152.451,    6.046,   -0.   ,    0.   ,    0.   ,    2.199],
           [-239.66 ,    0.   ,  -55.195,   10.455, -239.66 ,    0.   ,  -55.195,    7.492,    0.   ,    0.   ,    0.   ,    2.963],
           [ 237.91 ,    0.   ,   54.596,   12.523,  237.91 ,    0.   ,   54.597,    9.127,    0.   ,    0.   ,   -0.   ,    3.397]], dtype=float32)
   </pre>

.. class:: small

    :b:`Positions match closely, some times are way off` 


:small:`Compare "big bouncer" position, time, dist, speed between N=0,1`
--------------------------------------------------------------------------

::

    rvtime_ = lambda r:np.diff(r[:,0,3])
    rvstep_ = lambda r:np.diff(r[:,0,:3],axis=0 )   
    rvdist_ = lambda r:np.sqrt(np.sum(rvstep_(r)*rvstep_(r),axis=1))
    rvspeed_ = lambda r:rvdist_(r)/rvtime_(r)

    In [14]: np.c_[rvtime_(ar[b2a]), rvtime_(br[:len(b2a)]),
                   rvdist_(ar[b2a]), rvdist_(br[:len(b2a)]),
                  rvspeed_(ar[b2a]),rvspeed_(br[:len(b2a)])]
 
.. raw:: html

    <pre class="mypretiny">
    Out[14]: 
    array([[  0.137,   0.137,  29.837,  29.837, 218.038, 218.038],  ## Water
           [  0.027,   0.027,   5.249,   5.249, 196.216, 196.215],  ## Pyrex 
           [  1.615,   1.057, 316.798, 316.798, <span class="r">196.215</span>, 299.792],  ## Vacuum
           [  0.388,   0.254,  76.053,  76.053, <span class="r">196.215</span>, 299.792],
           [  0.946,   0.634, 189.965, 189.965, <span class="b">200.744</span>, 299.792],  ## <span class="b">comb. of Vacuum and Pyrex speeds, split at Fake </span>
           [  1.162,   1.162, 348.275, 348.275, 299.792, 299.792],
           [  1.475,   0.965, 289.392, 289.392, <span class="r">196.215</span>, 299.792],
           [  0.834,   0.546, 163.634, 163.634, <span class="r">196.215</span>, 299.792],
           [  0.458,   0.3  ,  89.881,  89.881, <span class="r">196.215</span>, 299.792],
           [  1.204,   0.965, 289.357, 289.357, <span class="b">240.315</span>, 299.792],  ## <span class="b">comb. of Vacuum and Pyrex speeds, split at Fake</span>  
           [  2.21 ,   1.447, 433.663, 433.663, 196.215, 299.792],
           [  2.068,   1.635, 490.027, 490.027, 236.919, 299.792]], dtype=float32)
    </pre>

.. class:: small

    +-----+--------------------------------+----------------------------------------------------------+
    | N=0 | Pyrex speed within PMT Vacuum  | :r:`FastSim->SlowSim transitions miss speed setup ?`     |
    +-----+--------------------------------+----------------------------------------------------------+
    | N=1 | Always Vacuum speed in Vacuum  | All standard Geant4 with customized G4OpBoundaryProcess  |
    +-----+--------------------------------+----------------------------------------------------------+




:small:`Rerunning Single Photons : Very Useful Debug Technique`
-----------------------------------------------------------------

.. sidebar:: :small:`Save/Load g4state into NP array`

    .. class:: small

        :r:`Efficiently save/restore thousands of states` 

    .. class:: small

        **MixMaxRng (G4 1042 random engine)**
      
        State of engine : 38*uint32 

    .. raw:: html

        <pre class="mypretiny">
        U4Engine::SaveState(    NP* states, int idx );
        U4Engine::RestoreState( NP* states, int idx );
        </pre>


    .. class:: small

        **Rerun "big bouncer" photon**

    .. raw:: html

        <pre class="mypretiny">
        vi U4SimulateTest.sh    # SRM_G4STATE_SAVE
        N=0 ./U4SimulateTest.sh # save g4state into ALL0
        vi U4SimulateTest.sh    # SRM_G4STATE_RERUN
        N=1 ./U4SimulateTest.sh # load ALL0, save SEL1
        </pre>
    


* save g4state before sim each photon 
* :r:`enables re-simulation of single photons`
* compare between geometry versions
* add random "burns" matching consumption

  * :b:`manual fixup, only for debug`








:i:`hamaLogicalPMT_two_pmt_geom.png`
--------------------------------------

:i:`hamaLogicalPMT_two_pmt_cf.png`
------------------------------------


.. comment

    hamaLogicalPMT_two_pmt_check.png 
    -----------------------------------




junoPMTOpticalModel Issues : All from using FastSim 
----------------------------------------------------

.. sidebar:: :small:`CustomG4OpBoundaryProcess ?`

    .. class:: small

         * simple 2 volume (Pyrex+Vacuum) geometry 
         * standard G4OpBoundaryProcess reflect/refract/absorb/TIR 
         * much less code : reuse of standard Geant4
         * easier Opticks on GPU : simpler, more standard
 
           * no near-degenerate 1e-3 mm boundaries
           * allows same geometry on CPU and GPU 
           * avoid history rewriting for comparisons 
          
         **BUT : need to change very nasty Geant4 impl:**

         ``G4OpBoundaryProcess::PostStepDoIt``
             ugly monolith, rats nest of nested ifs 

         * Unpleasant to get familiar with 
         * Change palatable, using : ``CustomART.h``
         * Keep change separated, detailed validation vital 
                

.. raw:: html

   <p style="margin-bottom:1cm;" />


.. class:: small

   1. :r:`Four volume PMT due to FastSim limitation`

      * Two volumes (Pyrex + Vacuum) would be natural 

.. raw:: html

   <p style="margin-bottom:1cm;" />

.. class:: small

   2. Fake volumes yield many fake intersects

      * Pyrex/Pyrex + Vacuum/Vacuum same material fakes
      * :b:`complicates Geant4 step point history` 
      * :b:`complicates comparison with Opticks`

.. raw:: html

   <p style="margin-bottom:1cm;" />

.. class:: small

   3. Non-FastSim in PMT propagates at Pyrex (not Vacuum) speed

      * FastSim->SlowSim transition misses speed fixup 

.. raw:: html

   <p style="margin-bottom:1cm;" />

.. class:: small

   4. :r:`reflected + refracted polarization doesnt follow Geant4`

      * should follow G4OpBoundaryProcess, depending on S/P 

.. raw:: html

   <p style="margin-bottom:0.1cm;" />

.. class:: small

   * :b:`All issues stem from using FastSim (designed for regions)`
 
     * :b:`not good fit for 1 boundary (Pyrex/ARC/PHC/Vacuum)`


.. comment

    .. class:: small

       6. TODO: look into _qe definition 

          * justification for ``efficiency=_qe/An`` ? 




Next Steps
----------------------



**CPU**

* Extend ``JPMT.h`` to access QE + pmtcat using pmtid 
* Extend to NNVT (currently only HAMA)
* Compare absorption, efficiency between implementations


**GPU**

* Implement CUDA equivalent of CustomART.h 
* Integrate wih Opticks qudarap/qsim.h 

**More standard approach and simpler geometry makes it easier**   




