.. meta::
   :title: Opticks Zhejiang Seminar
   :description: (2024 February) JUNO, OptiX, Opticks
   :note0: 30 min 

.. include:: my_s5defs.txt

.. comment

    Teacher Li, Lin Tao, Simon,

    Happy New Year everyone!

    Our research work in medical imaging requires in-depth study of the transport
    process of scintillation light within the crystal and efficient simulation. We
    sincerely invite you to visit Zhejiang University from February 26th to 28th so
    that we can consult with you in person. During this period, we will arrange
    academic reports and other academic exchange activities. Looking forward to
    your arrival!

    good luck!
    Zhu Hongbo
    School of Physics, Zhejiang University


.. comment

    TO BRING OVER 

    HK graphics comparison

    TO ADD

    NVIDIA GPUs for China

    * https://videocardz.com/newz/nvidia-to-launch-hgx-h20-l20-and-l2-gpus-for-china
    * H20 L20 L2  
    * is L20 a cut down for China L40 ? 
    * is L2 a cut down for China L4 ? 

    Gpu-based optical photon simulation for the LHCb RICH 1 detector
    https://link.springer.com/article/10.1140/epjc/s10052-023-12158-7

    Optical Photon Simulation with Mitsuba3 
    https://arxiv.org/pdf/2309.12496.pdf
 
    Geforce 4090D
    https://www.nvidia.cn/geforce/graphics-cards/40-series/rtx-4090-d/

.. comment 
  
    Things to add

    * expts with optical photon limitations, interested in Opticks 
    * Opticks Geant4 example
    * Opticks for CEPC

    Possible things to add

    * describe raytrace rendering 
    * describe validation techniques : aligned, statistical comparison  

.. comment

    Hi Simon,

    Due to conflicts with another event, our trip is modified a bit:

    * 21 Feb, Beijing - Jiangmen
    * 26 Feb, Jiangmen - Hangzhou
    * 27 Feb, you give a seminar on opticks at Zhejiang University. Then discuss the application of opticks.
    * 28 Feb, Hangzhou - Beijing

    Weidong tells me that they will create a poster for the seminar. Could you provide the title, abstract and your introduction? Thank you.

    Tao

    Title: 

        Opticks : Optical Photon Simulation via GPU Ray Tracing from NVIDIA OptiX

    Abstract:

        Opticks is an open source project that accelerates optical photon simulation by
        integrating NVIDIA GPU ray tracing, accessed via the NVIDIA OptiX 7 API, with
        Geant4 toolkit based simulations. A single NVIDIA Turing architecture GPU has 
        been measured to provide optical photon simulation speedup factors exceeding
        1500 times single threaded Geant4 with a full JUNO analytic GPU geometry
        automatically translated from the Geant4 geometry. Optical physics processes of
        scattering, absorption, scintillator reemission and boundary processes are 
        implemented in CUDA based on Geant4.  Wavelength-dependent material and surface
        properties as well as inverse cumulative distribution functions for reemission
        are interleaved into GPU textures providing fast interpolated property lookup
        or wavelength generation.

    Introduction to Dr Simon C Blyth:

        Simon is a High Energy Physicist and Software Developer based at IHEP. 
        He gained his D.Phil in Particle Physics from Oxford University working 
        on the DELPHI experiment at LEP. Following that he worked on the L3 experiment 
        at CERN and BELLE expt at KEK. Subsequently he joined the Dayabay and JUNO experiments, 
        where he has been working on accelerating optical photon simulatiom 
        by integrating GPU ray tracing. This makes possible enormous speedup
        factors of more than 1000 times compared to serial processing.

.. comment

    <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA OptiX 7, NVIDIA CUDA

    The 2023 International Workshop on the High Energy Circular Electron Positron Collider


:i:`Opticks : Optical Photon Simulation via GPU Ray Tracing from NVIDIA OptiX`
========================================================================================

.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey;text-align:center;"> 
        <i>Opticks</i> : Optical Photon Simulation via GPU Ray Tracing from NVIDIA® OptiX™
        <h2 style="background-color:lightgrey;text-align:center">
            Open source, https://bitbucket.org/simoncblyth/opticks 
        </h2>
    </h1>
    </header>
    </div>
    <!--img style="position:absolute; top:200px; LEFT:100px; WIDTH:200px; " src="juno/JUNO_logo.png"  /-->
    <div class="mycredit">
       <h2 style="background-color:lightgrey">
          Simon C Blyth, IHEP, CAS &mdash; Zhejiang University, Hangzhou &mdash; 27 February 2024
       </h2>
    </div>

:i:`Opticks : Optical Photon Simulation via GPU Ray Tracing from NVIDIA OptiX` Talk
-----------------------------------------------------------------------------------

.. class:: normal

    Opticks is an open source project that applies GPU ray tracing to optical photon simulation 
    and integrates this with Geant4. This can give drastic speedups of more than a factor of 1000.
    This approach removes memory and processing bottlenecks that can prevent the 
    optical photons from limiting simulations.  

    The actual speedup depends on your geometry and your effort in avoiding 
    geometry issues. 

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.



Outline
---------

.. image:: newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right

.. class:: small

    .. raw:: html

       <span>&nbsp;</span>

    * Optical Photon Simulation : Context and Problem

      * JUNO Optical Photon Simulation Problem...
      * Optical photons limit many simulations => lots of interest in Opticks
      * Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA

    * Optical Photon Simulation ≈ Ray Traced Image Rendering

      * Rasterization vs Ray Tracing 
      * Monte Carlo Path tracing in (movie) production
      * Fundamental "Rendering Equation" of Computer Graphics (Kajiya 1986)
      * Neumann Series Solution of Rendering Equation, Samples per pixel 
      * Optical Simulation : Computer Graphics vs Physics 

    * NVIDIA Tools to create Solution   

      * SIGRAPH 2018 
      * NVIDIA Ada Lovelace : 3rd Generation RTX, RT Cores in Data-Center
      * NVIDIA OptiX Ray Tracing Engine
      * NVIDIA OptiX 7 : Entirely new thin API, BVH Acceleration Structure

    * Opticks : Introduction + Full Re-implementation

      * Geant4 + Opticks Hybrid Workflow : External Optical Photon Simulation
      * Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7
      * Ray trace render performance scanning 
      * QUDARap : CUDA Optical Simulation Implementation
      * Validation 

    * Opticks New Features : Multi-Layer Thin Film (A,R,T) Calc using TMM (Custom4 Package)


.. raw:: html

   <hr/>


:i:`Opticks : Optical Photon Simulation via GPU Ray Tracing from NVIDIA OptiX` Talk
-----------------------------------------------------------------------------------

.. class:: normal
    
    This aim of this talk is to explain how GPU ray tracing is integrated 
    with Geant4 


.. comment

      * Primary Packages and Structs Of Re-Implemented Opticks
      * n-Ary CSG "List-Nodes"
      * Summary + Links 


.. comment

    :i:`JUNO_Intro_2`
    ------------------

    .. s5_talk::

        I guess JUNO needs no introduction here. 

        One thing to note however is the scale : JUNO will soon become the worlds 
        largest liquid scintillator detector with a 35m diameter sphere of scintillator. 

    .. comment 

        JUNO will soon start data taking, it will be the worlds largest liquid scintillator detector,
        with a 20 kiloton spherical volume of scintillator instrumented with  
        almost 50 thousand PMTs. The diameter of the sphere is 35 meters. 


`JUNO Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <p style="margin-bottom:7cm;" />

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


`JUNO Optical Photon Simulation Problem...` Talk
------------------------------------------------

.. class:: normal

   A muon travelling across the JUNO scintillator yields tens of millions 
   of optical photons, presenting memory and time challenges. 

   Most of the time is taken finding intersections between photons and geometry 
   Simulation is not alone in this bottleneck.


.. comment

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation and we
   are interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 


:small:`Optical photons limit many simulations => lots of interest in Opticks`
--------------------------------------------------------------------------------

.. class:: small

    +-----------+-----------------------------------------------------------------------------+
    | **EXPT**  | **Reactor neutrino**                                                        |  
    +-----------+-----------------------------------------------------------------------------+
    | Daya Bay  | neutrino oscillations                                                       |
    +-----------+-----------------------------------------------------------------------------+
    | JUNO      | mass heirarchy + oscillations  => :r:`NVIDIA CN Contacts`                   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Long baseline neutrino beam**                                             |
    +-----------+-----------------------------------------------------------------------------+
    | DUNE      | FermiLab->Sanford, LAr TPC, => Assistance from :b:`Fermilab Geant4 Group`   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrinoless double beta decay, dark matter, other search**               |
    +-----------+-----------------------------------------------------------------------------+
    | LZ        | LUX-ZEPLIN dark matter experiment, Sandford  => :r:`NVIDIA US Contacts`     |
    +-----------+-----------------------------------------------------------------------------+
    | LEGEND    | Large Enriched Germanium Experiment, Gran Sasso/SNOLAB                      |
    +-----------+-----------------------------------------------------------------------------+
    | SABRE     | dark matter direct-detection, Australia                                     |
    +-----------+-----------------------------------------------------------------------------+
    | AMoRE     | Mo-based Rare process Experiment, S.Korea                                   |
    +-----------+-----------------------------------------------------------------------------+
    | nEXO      | next Enriched Xenon Observatory, LLNL                                       |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrino telescope**                                                      |
    +-----------+-----------------------------------------------------------------------------+
    | KM3Net    | Cubic Kilometre Neutrino Telescope, Mediterranean                           |
    +-----------+-----------------------------------------------------------------------------+
    | IceCube   | IceCube Neutrino Observatory, South Pole                                    |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Air shower : gamma-ray and cosmic-ray observatory**                       |
    +-----------+-----------------------------------------------------------------------------+
    | LHAASO    | Large High Altitude Air Shower Observatory, Sichuan                         |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Accelerator**                                                             |
    +-----------+-----------------------------------------------------------------------------+
    | LHCb-RICH | LHCb ring imaging Cherenkov sub-detector, CERN => :r:`NVIDIA EU Contacts`   |
    +-----------+-----------------------------------------------------------------------------+



:small:`Optical photons limit many simulations => lots of interest in Opticks` Talk
-----------------------------------------------------------------------------------

.. class:: normal

    Many simulations are limited by optical photons. 
    So, there is lots of interest in Opticks.
    Several groups has assisted with Opticks development 
    by using their contacts with NVIDIA 
   


:small:`Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA`
------------------------------------------------------------------------------------

.. sidebar:: :small:`Acknowledgements`

   .. class:: small

       **LBNL + LZ + NVIDIA** : 2021 
           7 NVIDIA engineer meetings on OptiX 7 API

       **Manchester U. + LHCb-RICH + NVIDIA** : 2022 
           UK GPU Hackathon : optimization guidance

       **IHEP+NTU/JUNO+Dayabay**
           Many years supporting my work on Opticks 

       **Special Mentions**

       Dr Hans Wentzel, Fermilab, Geant4 group
           Many years of assistance with testing Opticks 

       Dr Tao Lin, IHEP
           Expert help on JUNOSW + practicalities 

       Yuxiang Hu, IHEP 
           Help on Opticks+JUNOSW testing 

           




.. class:: small

    +---------------------------------------------------------------------------------------------------------------------------------------+
    |  :r:`Developing Opticks would not have been possible without longterm support and assistance from many organizations and individuals` |
    +---------------------------------------------------------------------------------------------------------------------------------------+

    +-------------------------------------------------------------------------------------------+
    | :b:`ALSO : Assistance of many with promoting Opticks to a wide audience are acknowledged` |
    +-------------------------------------------------------------------------------------------+


    **Geant4 11.0+ (Dec 2021) : Opticks Advanced Example** 

    * **CaTS : Calorimeter+Tracker Sim. LArTPC (DUNE)**
    * :r:`Hans Wentzel, Fermilab Geant4 Group`
    * *...demonstrates how to use Opticks for the creation and propagation of optical photons...*
    * https://geant4.web.cern.ch/download/release-notes/notes-v11.0.0.html


    **Dark Matter Search Community (XENON,LZ,DARWIN,..)** 

    Dark-matter And Neutrino Computation Explored (DANCE) 

    * Input to Snowmass 2021
    * https://arxiv.org/pdf/2203.08338.pdf
    * *...Opticks package may provide a solution to the tracking of optical photons...*

:small:`Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA` Talk
---------------------------------------------------------------------------------

.. class:: normal

    The Fermilab Geant4 Group was an early adopter of Opticks and has assisted by 
    developing a Geant4 advanced example demonstrating Opticks which 
    has been in the Geant4 distribution since 2021. 

    A group of experiments from the Dark Matter search community 
    made a significant contribution to Opticks development by organizing 
    a series of meetings with NVIDIA engineers that were very useful to 
    guide a re-implementation of Opticks to work with a completely new OptiX API. 
   

.. comment

    https://gitlab.cern.ch/geant4/geant4/-/tree/master/examples/advanced/CaTS 

:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: :small:`Not a Photo, a Calculation`

    .. image:: ../optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    :b:`simulation` 
       photon parameters at sensors (PMTs) 

    :b:`rendering` 
       pixel values at image plane


.. raw:: html

    <p style="margin-bottom:2cm;" />


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :redbold:`both limited by ray geometry intersection, aka ray tracing`

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering` Talk
--------------------------------------------------------------------

.. class:: normal

    So how can GPU ray tracing help with simulation. 

    Actually, there is a lot in common between optical photon simulation and ray traced image rendering.   
    Simulation needs photon parameters at sensors, rendering needs pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is widely used across many industries from advertising to games, so 
    there has been huge efforts to improve ray tracing perfromance, especially from NVIDIA. 
    






:i:`Rasterization vs Ray-tracing`
-----------------------------------

.. image:: /env/presentation/nvidia/nv_rasterization.png
   :width: 550px
   :align: left

.. image:: /env/presentation/nvidia/nv_raytrace.png
   :width: 550px
   :align: right


:i:`Rasterization vs Ray-tracing` Talk
--------------------------------------

.. class:: normal

   Ray tracing and rasterization are the two primary graphics rendering techniques. 

   Rasterization is the most common rendering technique
   
   * it starts from the objects in a scene, and projects them onto pixels in the image plane
   * this requires approximate triangulated geometry   
   
   Ray tracing 

   * starts from the pixels, casts rays out into the 3D scene and finds intersects
   * this can use analytic geometry, without approximation (just like Geant4)   
   * its easier to create realistic images with ray tracing because it is closer to the physics

   Ray tracing is an overloaded term.  In some contexts it means just the ray transport
   from an origin to an intersection. But is also refers more generally to the rendering technique. 

.. comment

   https://www.youtube.com/watch?v=Mrixi27G9yM
   RTX Launch



:i:`Path Tracing in Production 1`
----------------------------------


.. comment

   * http://www.realtimerendering.com/raytracing/siggraph2019/Path_Tracing_in_Production_part_1.pdf

   * https://jo.dreggn.org/path-tracing-in-production/2019/ptp-part1.pdf

   * https://cs.dartmouth.edu/~wjarosz/publications/novak18monte.html



:i:`Path Tracing in Production 1` Talk
--------------------------------------

.. class:: normal

    Ray tracing is the building block behind **Monte Carlo Path Tracing** 

    SIGGRAPH is the primary computer graphics conference series. 
    This is the abstract from a course document sharing movie production graphics techniques. 

    * **Monte Carlo Path Tracing** is now the standard rendering technique in movie production


:i:`Path Tracing in Production 2`
-----------------------------------

.. sidebar:: :small:`Monte Carlo Path Tracing`

   .. class:: small

       :r:`Path Tracing is built on top of Ray Tracing`

       * ubiquitous rendering technique 
       * random sampling (Monte Carlo method)
       * numerical solution of **"The Rendering Eqn."**

       **Movies ≈ monte carlo optical photon simulations**


:i:`Path Tracing in Production 2` Talk
--------------------------------------

.. class:: normal

   This means that for many movies: 

   * every frame is the result of monte carlo optical photon simulations, involving billions of photons

.. comment

   * "ground truth" render 
   * numerical integration by recursive point-sampling 
   * Russian roulette killing of rays
   * **ubiquitous** approach to solution to numerical solution of RE  
   * includes indirect light (global illumination)


.. comment

    Irradiance Caching and Derived Methods
    ----------------------------------------

    .. class:: small

       * https://cs.dartmouth.edu/~wjarosz/publications/dissertation/chapter3.pdf




:i:`The Rendering Equation 1`
------------------------------

:i:`The Rendering Equation 1` Talk
----------------------------------

.. class:: small

    SMALL
    Computer graphics is all about finding solutions to the rendering equation.
  
    The equation stems from energy conservation in equilibrium:

    * Outgoing light in some direction comes from emission and reflection at the point   
    * Light reflected from the point depends on all the incoming 
      light and the reflection characteristics of the surface. 

    What you see at one point depends on all other points that are 
    visible from it and so on recursively. 

    You can see blue, green and red casts on the teapot 
    coming from color bleeding : that arises from the 
    multiple bounces or indirect lighting.

    The rendering equation is a recursive integral equation

    * surface properties are known
    * what is unknown is the radiance distribution function

    Solving it gives you images from any viewpoint.


.. comment

    The lines on the images try to illustrate that:
 
    * what the eye at point x sees at some x-prime depends on inputs from all the 
      x-double-prime and each double-prime point depends on all the 
      treble-prime ones



       
 
:i:`The Rendering Equation 2`
------------------------------

:i:`The Rendering Equation 2` Talk
----------------------------------

.. class:: normal

   This form of recursive integral equation has a solution
   which is a sum of terms with progressively increasing 
   bounces. 

   0. emission : looking at the light 
   1. direct illumination
   2. one-bounce indirect illumination
   3. two-bounce indirect illumination

   Top row shows individual contributions, with the 
   cumulative sum on the bottom row.

   Recursive integral eqn -> sum of integrals 

   The "Volumetric Rendering Equation" is a generalization to cover
   participating media eg clouds, fire, fog, skin  


 
:i:`The Rendering Equation 3`
------------------------------

.. raw:: html 

   <p style="margin-bottom:3cm;" />


.. sidebar:: :small:`Sum over increasing "bounces"`

   .. class:: small

       0. emission : direct from light source 
       1. direct illumination
       2. one-bounce indirect illumination
       3. two-bounce indirect illumination

       Top row : individual terms, Bottom row : cumulative 

       :r:`improving realism as more bounces included`


:i:`The Rendering Equation 3` Talk
----------------------------------

.. class:: normal

    Realism improves as more bounces are included


.. comment

   Recursive integral eqn -> sum of integrals 

   The "Volumetric Rendering Equation" is a generalization to cover
   participating media eg clouds, fire, fog, skin  



:i:`Samples per Pixel 1`
------------------------- 

:i:`Samples per Pixel 1` Talk
-----------------------------

.. class:: normal

    Monte Carlo Path Tracing 

    * amazingly general technique 
    * produces images difficult to distinguisable from reality 
    * BUT : suffers from slow convergence


:i:`Samples per Pixel 2`
-------------------------- 

.. sidebar:: :small:`Monte Carlo Path Tracing` 

  .. class:: small

    :b:`fantastically general technique`
      * any geometry 
      * any lighting/surface effect

    :b:`BUT noisy : slow 1/sqrt(N) convergence`
      * need many samples per pixel
      * every pixel needing several "bounces"

    :r:`=> Limited by ray tracing performance`
       

:i:`Samples per Pixel 2` Talk
-----------------------------

.. class:: normal

   The technique has the usual monte carlo disadvantage of slow 
   convergence.  Much of computer graphics is about devising ways 
   to bias the sampling and speed up the convergence. 


Optical Simulation : Computer Graphics vs Physics 
------------------------------------------------------------------

.. class:: small

   ==========================================  =============================================  
    CG Rendering "Simulation"                    Particle Physics Simulation
   ==========================================  =============================================  
     simulates: image formation, vision          simulates photons: generation, propagation, detection     
     (red, green, blue)                          wavelength range eg 400-700 nm
     ignore polarization                         polarization vector propagated throughout
     participating media: clouds,fog,fire [1]    bulk scattering: Rayleigh, MIE  
     human exposure times                        nanosecond time scales
     equilibrium assumption                      transient phenomena
     ignores light speed, time                   arrival time crucial, speed of light : 30 cm/ns  
   ==========================================  =============================================  

   * **handling of time is the crucial difference**

   Despite differences :red:`many techniques+hardware+software directly applicable to physics` eg:

   * GPU accelerated ray tracing (NVIDIA OptiX)
   * GPU accelerated property interpolation via textures (NVIDIA CUDA)   
   * GPU acceleration structures (NVIDIA BVH)   

   
   Potentially Useful CG techniques for "billion photon simulations"

   * irradiance caching, photon mapping, progressive photon mapping 
   

.. class:: tiny 

   [1] search for: "Volumetric Rendering Equation"


Optical Simulation : Computer Graphics vs Physics  Talk
-------------------------------------------------------

.. class:: normal

    There are great similarities between graphics rendering and physics simulation
    but also some clear differences.

    * principal difference is handling of time : graphics assuming 
      long time scales and equilibium  

    * despite the differences there is great scope for re-purposing 
      computer graphics techniques+projects to assist physics simulation   










:i:`SIGGRAPH_2018_Announcing_Worlds_First_Ray_Tracing_GPU`
------------------------------------------------------------

.. raw:: html 

    <pre>







    </pre>


.. class:: huge 

    .. table:: 
       :align: right

     
       +----------------------------+
       |  :white:`10 Giga Rays/s`   |
       +----------------------------+


:i:`SIGGRAPH_2018_Announcing_Worlds_First_Ray_Tracing_GPU` Talk
---------------------------------------------------------------

.. class:: normal

    In 2018 NVIDIA introduced a GPU with hardware dedicated to accelerating ray tracing.
    NVIDIA claims it can reach 10 billion ray geometry intersections per second
    with a single GPU. 

    Assuming each simulated photon costs 10 rays, that means the upper limit per GPU is 
    1 billion photons/second.





:small:`NVIDIA Ada : 3rd Generation RTX`
--------------------------------------------------------------------------

.. class:: small

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 4090 (2022)** 

     * 16,384 CUDA Cores, 24GB VRAM, USD 1599

   * :r:`Continued large ray tracing improvements:` 

     * **Ada** ~2x ray trace over **Ampere** (2020), 4x with DLSS 3
     * **Ampere** ~2x ray trace over **Turing** (2018)  
    
   * DLSS : Deep Learning Super Sampling 

     * AI upsampling, not applicable to optical simulation



:small:`NVIDIA Ada : 3rd Generation RTX` Talk
---------------------------------------------

.. class:: normal

    NVIDIA GPU Ray Tracing performance has continued to improve rapidly.
    With a rough doubling in ray tracing performance
    with each generation of NVIDIA RTX GPUs and we are now at the 3rd generation. 

    [Notes to Presenter]
    [<20s slide : No need to read the slide, just say the above comment]    


:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center`
-------------------------------------------------------------------------

.. sidebar:: :small:`Data Center GPUs with RT Cores`

    .. class:: small

        * :b:`An Established part of NVIDIA Lineup`

        +--------------+------------------+-----------------+  
        |              |    NVIDIA L40    | NVIDIA L4       |   
        +==============+==================+=================+
        |  Release     |   2022/10        |  2023/03        |   
        +--------------+------------------+-----------------+  
        |  GPU Arch    |   Ada Lovelace   |  Ada Lovelace   |        
        +--------------+------------------+-----------------+  
        |  VRAM        |   48 GB gddr6    | 24 GB gddr6     |   
        +--------------+------------------+-----------------+  
        |  TDP         |    300W          |  :r:`72W`       |   
        +--------------+------------------+-----------------+  
        |  Form factor |    dual slot     |  :r:`1-slot`    |   
        +--------------+------------------+-----------------+  
        | CUDA Core    |    18,176        |   7,680         |    
        +--------------+------------------+-----------------+  
        | :b:`RT Core` |:b:`142 (3rd gen)`|:b:`60 (3rd gen)`|    
        +--------------+------------------+-----------------+  
        | Tensor Core  |    568 (4th gen) |   240 (4th gen) |    
        +--------------+------------------+-----------------+  
        |  FP32        |    90.5 TFLOPS   |  30 TFLOPS      |   
        +--------------+------------------+-----------------+  
        |  FP16(*)     |    181 TFLOPS    |  121 TFLOPS     |   
        +--------------+------------------+-----------------+  
        | Predecessor  |    A40           |    T4           |   
        +--------------+------------------+-----------------+  

        (*) x2 with Sparsity 


.. class:: small


    **NVIDIA L4 Tensor Core GPU (Released 2023/03)**

    * Ada Lovelace GPU architecture
    * :r:`universal accelerator for graphics and AI workloads` 
    * :b:`small form-factor, easy to integrate, power efficient` 
    * PCIe Gen4 x16 slot without extra power
    * Google Cloud adopted for G2 VMs, successor to **NVIDIA T4**
    * **NVIDIA L4 likely to become a very popular GPU**

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    `NVIDIA L4 Tensor Core GPU (Data Center, low profile+power)`

:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center` Talk
----------------------------------------------------------------------------

.. class:: normal

    Hardware Accelerated Ray Tracing is becoming much more commonly available, 
    with NVIDIA offering a range of data center GPUs with RT cores. 

    [Notes: <20s slide, just mention above comments]

.. comment

    The current boom in interest in AI is only going to increase this trend. 


:small:`US restricts export of highest performing GPUs`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`Performance Density Threshold`

    .. raw:: html

         <pre class="mypretiny">
         +----------------------------------------------------+
         | total proc. performance (TFLOPs)                   |
         | ------------------------------ < 5.92 TFLOPs mm^-2 |
         | applicable die area (mm^2)                         |
         +----------------------------------------------------+

         ([0],[1] for full rule details )
         </pre>


.. sidebar:: :small:`China+HK : ~22% NVIDIA revenue (2023 Q3)`

    .. class:: small

         :r:`=> Bound to provide GPUs just below threshold`  

.. class:: small

     [0] *GPUs above performance threshold require export permits*


.. raw:: html

     <p style="margin-bottom:2cm;" />

.. class:: small

     [1] **Federal Register on 10/25/2023 : restriction details**

     * based on a "performance density" definition 

.. raw:: html

     <p style="margin-bottom:2cm;" />

.. class:: small

     [2] **NVIDIA filing to US Securities and Exchange Commission** 

     *...additional licensing requirements for exports to China...*

     *...(including but not limited to the A100, A800, H100, H800, L40, L40S, and RTX 4090)* 

.. raw:: html

     <p style="margin-bottom:2cm;" />


.. class:: tiny

     [0] https://www.theregister.com/2023/10/19/china_biden_ai/

     [1] https://public-inspection.federalregister.gov/2023-23055.pdf

     [2] https://www.sec.gov/ix?doc=/Archives/edgar/data/1045810/000104581023000217/nvda-20231017.htm


:small:`US restricts export of highest performing GPUs` Talk
------------------------------------------------------------

.. class:: normal

    China is something like 20-25% of the world market for GPUs, 
    so NVIDIA has no choice : it is bound to introduce
    GPUs with specs just underneath threshold. 



:i:`OptiX Title Banner`
------------------------

.. raw:: html

     <p style="margin-bottom:165mm;" />

.. class:: huge

    https://developer.nvidia.com/rtx/ray-tracing/optix

:i:`OptiX Title Banner` Talk
----------------------------

.. class:: normal

    Most NVIDIA OptiX users are involved with realistic image rendering. 
    Fortunately OptiX exposes an intersection API which makes
    it applicable to simulation. So all the effort NVIDIA has expended 
    in accelerating ray tracing becomes directly applicable to simulation. 


:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing`
--------------------------------------------------------------------------

.. sidebar:: :small:`Flexible Ray Tracing Pipeline` 

    .. class:: small

        :g:`Green: User Programs`,  :e:`Grey: Fixed function/HW`

    .. image:: nvidia/optix7/OptiX-API.png
       :width: 450px
       :align: right

    .. class:: small

        :b:`Analogous to OpenGL rasterization pipeline` 


.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * :r:`Programmable GPU-accelerated Ray-Tracing Pipeline`
   * Single-ray shader programming model using CUDA
   * ray tracing acceleration using RT Cores (RTX GPUs)
   * "...free to use within any application..."

   **OptiX features**

   * acceleration structure creation + traversal (eg BVH)
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

   ``https://developer.nvidia.com/rtx/ray-tracing/optix``

.. class:: small

   **User provides (Green):**

   * ray generation
   * geometry bounding boxes
   * intersect functions 
   * instance transforms

   

:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing` Talk
-----------------------------------------------------------------------------

.. class:: normal

   NVIDIA OptiX makes GPU ray tracing accessible 

   * it divides up the ray tracing workflow 
   * the green boxes represent user provided CUDA programs, including:

     * ray generation : where Opticks generates photons and steers the simulation
     * intersection : where the CSG geometry is implemented 

   * geometry has to be translated into a GPU appropriate easily serialized form





``Spatial Index Acceleration Structure``
---------------------------------------------------

.. raw:: html

    <p style="margin-bottom:11cm;" />

.. sidebar:: :small:`Tree of Bounding Boxes (bbox)`

    .. class:: small

        * aims to minimize bbox+primitive intersects 
        * accelerates ray-geometry intersection


``Spatial Index Acceleration Structure`` Talk
---------------------------------------------

.. class:: normal

   The principal technique to accelerate ray geometry intersection 
   is an acceleration structure called a bounding volume hierarchy 
   
   This divides space into progressively smaller boxes which forms
   a spatial index.

   Traversing the tree of bounds allows to minimize tests
   needed to find an intersect.

   Much of the acceleration structure traversal 
   is done in the dedicated RT cores.






:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`GPU Ray Tracing APIs Converged`

    .. class:: small

        * 3 APIs (DXR,VKRay,OptiX7) over RTX 
        * Driver updates :r:`independent of application`  
        * Support new GPUs, performance improvements 

.. class:: small

    **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

    * low-level CUDA-centric thin API (Vulkan-ized)
    * headers only (no library, impl in Driver) 
    * Minimal host state,  :red:`All host functions are thread-safe`
    * GPU launches : explicit, asynchronous (CUDA streams)
    * :strike:`near perfect scaling to 4 GPUs, for free` 
    * :strike:`Shared CPU/GPU geometry context`
    * :strike:`GPU memory management`
    * :strike:`Multi-GPU support`


.. class:: small

    **Advantages of 6->7 transition**

    * More control/flexibility over everything 
    * :b:`Keep pace with state-of-the-art GPU ray tracing` 
    * Fully benefit from current + future GPUs : RT cores, RTX 

.. class:: small

    **BUT:** :r:`demanded full re-implementation of Opticks` 
     


:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation` Talk
--------------------------------------------------------------------------------------

.. class:: normal

   * OptiX 7 is an entirely new API, dropping many features used by the old Opticks
   * re-implementation of almost all of Opticks was necessary

   [Notes: No need to read slide, just the above comments]



Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow
-------------------------------------------------------------

.. class:: small

    .. table::
        :align: center

        +--------------------------------------------------+
        | :b:`https://bitbucket.org/simoncblyth/opticks`   |
        +--------------------------------------------------+


.. raw:: html

    <p style="margin-bottom:13cm;" />

.. class:: small

    Opticks API : split according to dependency -- Optical photons are GPU "resident", only hits need to be copied to CPU memory 


Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow Talk
--------------------------------------------------------

.. class:: normal

    This shows how Opticks is integrated with Geant4. The geometry is translated 
    and uploaded to the GPU at initialization.

    Cerenkov or Scintillation gensteps, the blue lines, are the generation parameters 
    uploaded to the GPU so optical photon generation can be done there.

    This allows the optical photon simulation to be entirely offloaded  
    to the GPU with only collected hits requiring memory on the CPU.
 

Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2
--------------------------------------------------------

.. sidebar:: :small:`Offload Optical Simulation to GPU`

   .. class:: small

      * :r:`translate Geant4 geometry to OptiX GPU`  

        * intersect functions
        * instance transforms
        * GPU textures for mat/surf properties

      * CUDA port of Geant4 generation+propagation

        * cuRAND random number generation
        * may small QUDARap headers implement optical simulation 


Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2 Talk
----------------------------------------------------------

.. class:: normal

    In general, I found that directly porting the optical physics has been straightforward.
    Most of problems and effort of Opticks been with the geometry, because the 
    geometry model needs to be very different from the deep tree of volumes of Geant4.




:small:`How to Make Effective Use of GPUs ? Parallel / Simple / Uncoupled`
------------------------------------------------------------------------------

.. sidebar:: :small:`Optical Photon Simulation`

    .. class:: small

        Abundant parallelism 
           * Many millions of photons 

        Low register usage 
           * Simple optical physics, texture lookups

        Little/No synchronization
           * Independent photons -> None 

        Minimize CPU<->GPU copies 
           * geometry copied at initialization
           * gensteps copied once per event
           * only hits copied back    

        :blue:`~perfect match for GPU acceleration` 



.. class:: small

    **Abundant parallelism**
       * many thousands of tasks (ideally millions)

    **Low register usage : otherwise limits concurrent threads** 
       * simple kernels, avoid branching  

    **Little/No Synchronization**
       * avoid waiting, avoid complex code/debugging

    **Minimize CPU<->GPU copies**
       * reuse GPU buffers across multiple CUDA launches 

    .. image:: /env/presentation/1px.png


    **How Many Threads to Launch ?**

    * can (and should) launch many millions of threads

      * :red:`mince problems as finely as feasible`

    * maximum thread launch size : so large its irrelevant
    * maximum threads inflight : #SM*2048 = 80*2048 ~ 160k

      * best latency hiding when launch > ~10x this ~ 1M 


.. class:: tiny    


    Understanding Throughput-oriented Architectures
    https://cacm.acm.org/magazines/2010/11/100622-understanding-throughput-oriented-architectures/fulltext

    NVIDIA Titan V: 80 SM, 5120 CUDA cores


:small:`How to Make Effective Use of GPUs ? Parallel / Simple / Uncoupled` Talk
-------------------------------------------------------------------------------

.. class:: normal

    Optical photon simulation is close to being an ideal 
    workload for GPUs 

    HMM: MAYBE MOVE THIS ?



:small:`Primary Packages and Structs Of Re-Implemented Opticks`
-----------------------------------------------------------------

.. sidebar:: :small:`Flexible Multi-Package Organization`

    .. class:: small

         **Code Organized by Dependency (not "Topic")**
     
         * :r:`maximizes: utility, re-use, ease of testing` 
         * => "GPU" code usable+tested on CPU 

         **Many small header-only implementations** 

         * common CPU/GPU headers   



.. class:: small 

   *SysRap* : many small CPU/GPU headers
     * *stree.h,snode.h* : geometry base types
     * *sctx.h* *sphoton.h* : event base types
     * *NP.hh* : serialization into NumPy .npy format files     

   *QUDARap* 
     * *QSim* : optical photon simulation steering
     * *QScint,QCerenkov,QProp,...* : modular CUDA implementation 

   *U4*
     * *U4Tree* : convert geometry into *stree.h*
     * *U4* : collect gensteps, return hits 

   *CSG*
     * *CSGFoundry/CSGSolid/CSGPrim/CSGNode* geometry model
     * *csg_intersect_tree.h* *csg_intersect_node.h* *csg_intersect_leaf.h* : CPU/GPU intersection functions 

   *CSGOptiX*
     * *CSGOptiX.h* : manage geometry convert from *CSG* to OptiX 7 *IAS* *GAS*, pipeline creation
     * *CSGOptiX7.cu* : compiled into ptx that becomes OptiX 7 pipeline

       * includes QUDARap headers for simulation   
       * includes *csg_intersect_tree.h,..* headers for CSG intersection    
     
   *G4CX*
     * *G4CXOpticks* : Top level Geant4 geometry interface


:small:`Primary Packages and Structs Of Re-Implemented Opticks` Talk
--------------------------------------------------------------------

.. class:: normal

   [HMM: COULD SKIP THIS ONE?]

   Opticks code is split into multiple packages by-dependency, not by-topic
   This means that more of the code has less dependencies, making 
   it more useful and easier to test.   

   Using mocking,  most of the "GPU" code can be tested on CPU.  

   [Notes: <30s slide, mainly for offline consumption, no need to read out]



.. comment

    :small:`Full re-implementation of Opticks for NVIDIA OptiX 7 API` 
    --------------------------------------------------------------------

    .. class:: small

        * :r:`Huge change unavoidable from new OptiX API` --> :b:`So profit from rethink of simulation code` --> **2nd impl advantage** 

        +------------------------------------------+--------------------------------------------------------+
        |  Old simulation (OptiXRap)               |  New simulation (QUDARap/qsim.h + CSGOptiX, CSG)       | 
        +==========================================+========================================================+
        |  * implemented on top of old OptiX API   | * pure CUDA implementation                             |
        |                                          | * :r:`OptiX use kept separate, just for intersection`  |
        |                                          |                                                        |
        +------------------------------------------+--------------------------------------------------------+
        |  * monolithic .cu                        | * many small headers                                   |
        |  * GPU only implementation               | * many GPU+CPU headers                                 |
        |  * deep stack of support code            | * shallow stack : QUDARap depends only on SysRap       | 
        +------------------------------------------+--------------------------------------------------------+
        |  * most code in GPU only context,        | * strict code segregation                              |
        |    even when not needing OptiX or CUDA   |                                                        |
        |                                          |   * :r:`code not needing GPU in SysRap not QUDARap`    |
        +------------------------------------------+--------------------------------------------------------+
        |  * testing : GPU only, coarse            | * :r:`testing : CPU+GPU , fine-grained`                |
        |                                          | * curand mocking on CPU                                | 
        +------------------------------------------+--------------------------------------------------------+
        |  * limited CPU/GPU code sharing          | * maximal sharing : SEvt.hh, sphoton.h, ...            |
        +------------------------------------------+--------------------------------------------------------+
        |  * timeconsuming manual random alignment | * :b:`new systematic approach to random alignment`     |  
        |    conducted via debugger                |                                                        |
        +------------------------------------------+--------------------------------------------------------+

        **Goals of re-implementation : flexible, modular GPU simulation, easily testable, less code**

        * code reduction, sharing as much as possible between CPU and GPU
        * fine grained testing on both CPU and GPU, with GPU curand mocking 
        * profit from several years of CUDA experience, eg QSim.hh/qsim.h host/device counterpart pattern:

          * hostside initializes and uploads device side counterpart --> :r:`device side hits ground running` 


    .. s5_talk::

        Embracing the change : might as well profit from a rethink 

        [Notes: dont read out as too much text, just read a few of the highlighted]


:small:`Two-Level Hierarchy : Instance transforms (TLAS) over Geometry (BLAS)`
-------------------------------------------------------------------------------

.. class:: small

    **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


.. class:: small

    .. figure:: nvidia/tlas_blas_two_level_hierarchy.png
        :width: 800px
        :align: right 

        https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

.. class:: small

   AS
      Acceleration Structure

   TLAS (aka **IAS**) 
      4x4 transforms, refs to BLAS
       
   BLAS (aka **GAS**)
      | triangles : vertices, indices
      | custom primitives : AABB 

   AABB
      axis-aligned bounding box 


   **SBT : Shader Binding Table**

   Flexibly binds together:
 
   1. geometry objects
   2. shader programs 
   3. data for shader programs

   **Hidden in OptiX 1-6 APIs**



:small:`Two-Level Hierarchy : Instance transforms (TLAS) over Geometry (BLAS)` Talk
-----------------------------------------------------------------------------------

.. class:: normal

   OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
   Other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
   This is because OptiX supports multiple instance levels. 
   But the simple two level is faster as that can be done on the RT cores.

   Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  


:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7`
-------------------------------------------------------------------------------

.. sidebar:: :small:`CSGFoundry Model`

    .. class:: small

        * :b:`array-based -> simple serialization + upload`
        * entire geometry in 4 GPU allocations 
        * factorized using subtree digests 

.. class:: small

    **Geant4 Geometry Model (JUNO: 300k PV, deep hierarchy)**

    +----+---------------------------+---------------------------------------------+ 
    | PV | *G4VPhysicalVolume*       | placed, refs LV                             |
    +----+---------------------------+---------------------------------------------+ 
    | LV | *G4LogicalVolume*         | unplaced, refs SO                           |
    +----+---------------------------+---------------------------------------------+ 
    | SO | *G4VSolid,G4BooleanSolid* | binary tree of SO "nodes"                   |
    +----+---------------------------+---------------------------------------------+ 

    **Opticks CSGFoundry Geometry Model** (index references)

    +---------------+----------------------------------------------------------------------------+----------------------------+
    | struct        | Notes                                                                      |  Geant4 Equivalent         |
    +===============+============================================================================+============================+
    | *CSGFoundry*  | vectors of the below, easily serialized + uploaded + :r:`used on GPU`      | None                       |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *qat4*        | 4x4 transform refs *CSGSolid* using "spare" 4th column (:b:`becomes IAS`)  | Transforms ref from PV     |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGSolid*    | refs sequence of *CSGPrim*                                                 | Grouped Vols + Remainder   | 
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGPrim*     | bbox, refs sequence of *CSGNode*, root of CSG Tree of nodes                | root *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGNode*     | CSG node parameters (JUNO: ~23k *CSGNode*)                                 | node *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+

    **NVIDIA OptiX 7 Geometry Acceleration Structures (JUNO: 1 IAS + 10 GAS, 2-level hierarchy)**

    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | IAS | Instance Acceleration Structures | JUNO: 1 IAS created from vector of ~50k *qat4* (JUNO)                   |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | GAS | Geometry Acceleration Structures | JUNO: 10 GAS created from 10 *CSGSolid* (which refs *CSGPrim,CSGNode* ) |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 

.. class:: small

    :r:`JUNO : Geant4 ~300k volumes "factorized" into 1 OptiX IAS referencing ~10 GAS`


:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7` Talk
---------------------------------------------------------------------------------

.. class:: normal

   The tables illustrates three geometry models.

   The CSGFoundry geometry model in the middle was designed 
   to enable translation between the Geant4 and OptiX models. 

      





:small:`Opticks : GPU Geometry starts from ray-primitive intersection`
-------------------------------------------------------------------------------------------------

.. class:: small

   * 3D parametric ray : **ray(x,y,z;t) = rayOrigin  +  t * rayDirection** 
   * implicit equation of primitive : **f(x,y,z) = 0**  
   * -> polynomial in **t** , roots: **t > t_min**  -> intersection positions + surface normals

.. figure:: /env/presentation/tboolean_parade_sep2017.png
   :width: 900px
   :align: center

   :red:`CUDA/OptiX intersection for ~10 primitives` -> :blue:`Exact geometry translation`


:small:`Opticks : GPU Geometry starts from ray-primitive intersection` Talk
---------------------------------------------------------------------------

.. class:: normal

    NVIDIA OptiX is a ray tracing library, it helps with accelerating intersection 
    it does not provide the intersection itself

    This gives full flexibility to implement intersection with any shape
    from first principals : by solving implicit equations for example


:small:`Ray intersection with general CSG binary trees, on GPU`
---------------------------------------------------------------------------------

.. sidebar:: Outside/Inside Unions

    .. class:: small

       dot(normal,rayDir) -> Enter/Exit

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_outside.png
       :width: 300px
       :align: center

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_inside.png
       :width: 300px
       :align: center

    .. class:: small

        * **A + B** boundary not inside other 
        * **A * B** boundary inside other 


.. class:: small

   Pick between pairs of nearest intersects, eg:

   =======================  ===========  ===============  ============== 
   *UNION* tA < tB           Enter B      Exit B           Miss B
   =======================  ===========  ===============  ============== 
   **Enter A**               ReturnA      :blue:`LoopA`    ReturnA
   **Exit A**                ReturnA      ReturnB          ReturnA 
   **Miss A**                ReturnB      ReturnB          ReturnMiss
   =======================  ===========  ===============  ============== 

   * *Nearest hit intersect algorithm* [1] avoids state

     * sometimes :blue:`Loop` : advance **t_min** , re-intersect both 
     * classification shows if inside/outside

   * *Evaluative* [2] implementation emulates recursion: 

     * :red:`recursion not allowed` in OptiX intersect programs
     * bit twiddle traversal of complete binary tree 
     * stacks of postorder slices and intersects 

   * :red:`Identical geometry to Geant4` 

     * solving the same polynomials 
     * near perfect intersection match



.. class:: tiny

    [1] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
        with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
 
    [2] https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h
        Similar to binary expression tree evaluation using postorder traverse. 


:small:`Ray intersection with general CSG binary trees, on GPU` Talk
--------------------------------------------------------------------

.. class:: normal

    Of course most geometries have more complex shapes than just 
    primitives.  Constructive solid geometry is a common way to 
    represent complex shapes. Opticks provides a CSG intersection 
    implementation. 


.. comment

    :i:`[9]cxr_i0_t8,_-1 : EXCLUDE SLOWEST`
    -----------------------------------------


:i:`cxr_overview_emm_t0_elv_t_moi__ALL_with-debug-disable-xj.jpg`
------------------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:2cm;" />


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        * :redbold:`purely analytic CSG, no triangles` 
      
        +--------------------------------------------+
        |  raytrace 2M pixels 1920x1080              |
        +======================+=====================+
        | **NVIDIA TITAN RTX** | 0.0091s (~110 FPS)  |
        | (1st gen. RT Cores)  |                     |
        +----------------------+---------------------+


:i:`cxr_overview_emm_t0_elv_t_moi__ALL_with-debug-disable-xj.jpg` Talk
----------------------------------------------------------------------

.. class:: normal

   Here is a ray trace render of JUNO using OptiX 7 
   There are no triangles here, this is a purely analytic ray trace with 
   the exact same geometry that the simulation uses.

   [Notes: ~10s slide, just the comment] 




.. comment

    :i:`cxr_min__eye_-10,0,0__zoom_1__tmin_0.1__sChimneyAcrylic_altview.jpg`
    -------------------------------------------------------------------------

    ``Raytrace render view from inside JUNO Water Buffer``

    .. s5_talk::

       Here is a view from inside the JUNO Water Buffer showing the PMTs
       pointing down at the acrylic sphere that contains the scintillator. 



.. comment

    :i:`cxr_min__eye_-30,0,5__zoom_1__tmin_25__sChimneyAcrylic_tmin_cutaway.jpg`
    ------------------------------------------------------------------------------

    ``ray TMIN cuts away sphere`` 

    .. s5_talk::

       Unlike with rasterization clipping, setting a ray tracing TMIN cuts away a sphere. 


    :i:`cxr_min__eye_-30,0,5__zoom_1__tmin_25__sChimneyAcrylic_skip_target_acrylic.jpg`
    ------------------------------------------------------------------------------------

    ``ELV=t94,95 ./cxr_min.sh  ## skip sTarget sAcrylic``

    .. s5_talk::

       Skipping the acrylic sphere and scintillator target allows to see more of the PMTs
       

.. comment

    `Increase TMAX to avoid cutoff`


:i:`cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_increased_TMAX.jpg`
-----------------------------------------------------------------------------------

``Raytrace render view from inside JUNO Water Buffer``


:i:`cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_increased_TMAX.jpg` Talk
--------------------------------------------------------------------------------------

.. class:: normal

    Klop



.. comment

    :i:`cxr_min__eye_-10,0,-30__zoom_0.5__tmin_0.1__sChimneyAcrylic_photon_eye_view.jpg`
    --------------------------------------------------------------------------------------

    ``ELV=t94,95 ./cxr_min.sh ## skip sTarget sAcrylic : upwards view`` 

    .. s5_talk::

       Here is a photon eye view from inside the scintillator, looking upwards towards the Chimney. 


:i:`cxr_overview_emm_image_grid_overview`
-------------------------------------------

``Comparison of ray traced render times of different geometry`` 
  ``simple way to find issues, eg over complex CSG, overlarge BBox`` 


:i:`cxr_overview_emm_image_grid_overview` Talk
----------------------------------------------

.. class:: normal

   Comparisons of ray trace rendering times for different geometriess 
   provides simple way to look for performance issues


.. comment

    :i:`scan_emm_jpg_select.txt_coarse.jpg`
    -----------------------------------------

    :i:`cxr_view_emm_t0_elv_t142_eye_-1,-1,-1,1__zoom_1__tmin_0.4__sWaterTube_skip_sBottomRock.jpg`
    -------------------------------------------------------------------------------------------------

    ``Render inside JUNO water buffer : PMTs, chimney, support sticks`` 


    .. s5_talk::

       Acceleration structure creation is a black box, so have to adopt an experimental 
       approach to finding the best geometry modelling to use.   


:i:`image_grid_elv_scan.jpg`
------------------------------

``Spot the differences : from volume exclusions``

:i:`image_grid_elv_scan.jpg` Talk
---------------------------------

.. class:: normal

   If you look closely at the renders you can see differences 
   from the exclusion of single volume types. Doing this for 
   all volume types allows to sort the volumes by their 
   impact on the performance. 


.. comment

    vi $HOME/j/issues/scan_elv_jpg_select.txt  ## manually prepare list of 9 jpg with visible diffs
    export JPGLIST=$HOME/j/issues/scan_elv_jpg_select.txt
    open -n $(cat $JPGLIST)
    cx
    JPGLIST=$JPGLIST ./image_grid.sh 




.. comment

    cxr_min__eye_-10,0,0__zoom_0.5__tmin_0.1__sChimneyAcrylic_explain_the_grey.jpg
    --------------------------------------------------------------------------------

    Maybe a TMAX issue again ?







:i:`scan-pf-check-GUI-TO-SC-BT5-SD`
--------------------------------------

:i:`scan-pf-check-GUI-TO-SC-BT5-SD` Talk
----------------------------------------

.. class:: normal

   This GUI allows interactive selection between tens of millions 
   of photons based on their histories.  

   Here its showing the photons that scattered before boundary transmitting straight 
   through to surface detect.

   Its implemented by indexing the photon histories using some very fast 
   GPU big integer sorting provided by CUDA Thrust, 
   and using OpenGL shaders to switch between selections.

   The 64-bit integers hold up to 16 4-bit flags for each step of the photon.

   All of this is done using interop capabilities of OpenGL/CUDA/Thrust and OptiX
   so GPU buffers can be written to and rendered inplace with no copying around.


:i:`scan-pf-check-GUI-TO-BT5-SD`
----------------------------------

:i:`scan-pf-check-GUI-TO-BT5-SD` Talk
-------------------------------------

.. class:: normal

   The GUI also provides interactive time scrubbing of the propagation 
   of tens of millions of photons. 

   This is some nanoseconds later for a different history category. 
  
   I created this GUI to help with debugging the simulation. 


.. comment

     * DELL Precision 7920T Workstation
     * Intel Xeon Silver 4114, 2.2GHz, 40 cores, 65G 
     * NVIDIA Quadro RTX 8000, 48G 

     * DELL Precision 7920T Workstation
     * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 65G  
     * NVIDIA TITAN RTX, 24G
     * NVIDIA TITAN V, 12G







.. comment

    :small:`cxr_overview.sh ELV scan 1080x1920 2M (NVIDIA TITAN RTX)`
    ---------------------------------------------------------------------

    .. class:: small

        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |idx|        -e|       time(s)    |      relative    |    enabled geometry description                                              |
        +===+==========+==================+==================+==============================================================================+
        |  0|      t133|        0.0077    |        0.9347    |    EXCL: sReflectorInCD                                                      |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  1|       t37|        0.0079    |        0.9518    |    EXCL: GLw1.bt08_bt09_FlangeI_Web_FlangeII                                 |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  2|       t74|        0.0079    |        0.9616    |    EXCL: GZ1.B06_07_FlangeI_Web_FlangeII                                     |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  ...                                                                                                                              |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        | 35|         t|        0.0083    |        1.0000    |    ALL                                                                       |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |  ...                                                                                                                              |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |141|       t50|        0.0097    |        1.1750    |    EXCL: GLb1.up01_FlangeI_Web_FlangeII                                      |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |142|       t39|        0.0097    |        1.1751    |    EXCL: GLw1.bt10_bt11_FlangeI_Web_FlangeII                                 |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |143|      t123|        0.0097    |        1.1753    |    EXCL: PMT_3inch_inner1_solid_ell_helper                                   |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |144|       t46|        0.0097    |        1.1758    |    EXCL: GLb1.up05_FlangeI_Web_FlangeII                                      |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+
        |145|       t16|        0.0102    |        1.2320    |    EXCL: sExpRockBox                                                         |
        +---+----------+------------------+------------------+------------------------------------------------------------------------------+

    .. class:: small

        :r:`Dynamic geometry : excluding volumes of each of 146 solids (after excluding slowest: solidXJfixture)` 

        * time range : 0.0077->0.0102 s (~ +-20% )  
        * reproducibility ~+-10%

        :b:`Small time range suggests no major geometry performance issues remain, after excluding slowest`

        * :r:`solids with deep CSG trees (eg solidXJfixture) can cause >2x slow downs`  


    .. s5_talk::

        You might think that the geometry without any exclusions would be the slowest, but 
        that is not the case. Varying the geometry changes the details of the acceleration structure. 
        Here the time range from fastest to slowest is rather small, suggesting there are 
        no major geometry performance problems left. 

        This is only the case after I excluded some problematic geometry. 
     
     







:small:`n-ary CSG Compound "List-Nodes" => Much Smaller CSG trees`
-------------------------------------------------------------------

.. sidebar:: :small:`Complex CSG => Tree Overheads`

    .. image:: GeoChain_Darwin/XJfixtureConstruction/CSGOptiXRenderTest/cvd0/50001/ALL/top_i0_/cxr_geochain_XJfixtureConstruction_ALL_upper.jpg 
          :align: right
          :width: 500px



.. class:: small


   :r:`Communicate shape more precisely`
       :r:`=> better suited intersect alg => less resources => faster` 

   Generalized Opticks CSG into three levels : tree < node < leaf 

   * `csg_intersect_tree.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_tree.h>`_ 
   * `csg_intersect_node.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h>`_
   * `csg_intersect_leaf.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_leaf.h>`_

   :b:`Generalizes binary to n-ary CSG trees`

   * list-node references sub-nodes by **subNum** **subOffset**

   CSG_CONTIGUOUS Union
      user guarantees contiguous, like G4MultiUnion of prim

   CSG_DISCONTIGUOUS Union
      user guarantees no overlaps, eg "union of holes" to be CSG subtracted : :r:`=> simple, low resource intersect` 

   CSG_OVERLAP Intersection
      user guarantees overlap, eg general G4Sphere: inner radius, thetacut, phicut


   :r:`Promising approach to avoid slowdowns from complex CSG solids`


:small:`n-ary CSG Compound "List-Nodes" => Much Smaller CSG trees` Talk
-----------------------------------------------------------------------

.. class:: normal

   Complex solids like this one with deep CSG trees can cause 
   large slowdowns.  In an attempt to reduce the performance degradation 
   I have generalize Opticks CSG to support list nodes in order to 
   reduce tree size and avoid large tree overheads. 


.. comment

    :small:`CSG_CONTIGUOUS Union : n-ary (not bin-ary) CSG intersection`
    -----------------------------------------------------------------------

    .. class:: small

        * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_contiguous`

    .. sidebar:: :small:`Alg works : but many TODOs`

        .. class:: small

           * integer templating : suit resources to shape
           * try sort networks, bitonic sort, ... 
           * compare performance with unbalanced trees
           * iterate implementation whilst measuring perf.


    .. class:: small

        1. *zeroth pass* : find **nearest_enter** and count first exits
        2. if zero exits => outside compound => return **nearest_enter**
        3. *first pass* : collect enter distances, **farthest_exit**
        4. order enter indices making **enter** distances ascend

           * :r:`n-ary : store, sort enters` :b:`(cf bin-ary : compare two)`
           * :b:`no tree overheads, but must store+sort distances`

        5. *2nd pass* : loop over enters in distance order 

           * contiguous requirement : **enter < farthest_exit** so far  
           * find Exits for Enters that qualify as contiguous, update farthest_exit

        6. return **farthest_exit** that qualifies as contiguous


    .. raw:: html

        <pre class="mypre15">
                 +----------------+     +-------------------+                  DISJOINT MUST BE DISQUALIFIED
                 |B               |     |D                  |                   
            +----|----+      +----|-----|----+       +------|----------+             +-----------+
            |A   |    |      |C   |     |    |       |E     |          |             |           |
            |    |    |      |    |     |    |       |      |          |             |           |
            | 0 E1    X2     E3  X4    E5   X6      E7     X8        [X9]           E10         X11
            |    |    |      |    |     |    |       |      |          |             |           |
            |    |    |      |    |     |    |       |      |          |             |           |
            +----|----+      +----|-----|----+       +------|----------+             +-----------+
                 |                |     |                   |
                 +----------------+     +-------------------+

                 E           E          E            E                               E 
                      X           X          X              X          X                         X
         </pre>



    .. s5_talk::

       Communicating the geometry more precisely enables a better suited intersection 
       algorithm to be used. This reduces resources and increases performance. 

       [notes: dont need to explain the algorithm in detail, important point is just the above comment] 




:small:`CSG_DISCONTIGUOUS Union : CSG intersection`
---------------------------------------------------------------

.. class:: small

    * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_discontiguous`

    :r:`User guarantees : absolutely no overlapping between constituents`

.. raw:: html

    <pre class="mypre15">
     +-------+          +-------+          +-------+          +-------+         +-------+      
     |       |          |       |          |       |          |       |         |       |      
     |       |          |       |          |       |          |       |         |       |      
     +-------+          +-------+          +-------+          +-------+         +-------+       

     +-------+          +-------+          +-------+          +-------+         +-------+      
     |       |          |       |          |       |          |       |         |       |      
     |       |          |       |          |       |          |       |         |       |      
     +-------+          +-------+          +-------+          +-------+         +-------+       

     </pre>


.. class:: small

    * => very simple low resource intersection : **closest Enter or Exit**

    * :b:`More closely suiting algorithm to geometry => better performance`
    * this can help with "holes" subtracted from another solid : the "holes" usually do not overlap 

:small:`CSG_DISCONTIGUOUS Union : CSG intersection` Talk
--------------------------------------------------------

.. class:: normal

   Again more precise communication of intent for geometry -> better performance
   as it enables a very low resource intersection appoach to be used and it can 
   avoid tree overheads.  












:small:`QUDARap : CUDA Optical Simulation Implementation`
------------------------------------------------------------

.. sidebar:: :small:`CPU Pre-Init of GPU Counterpart`

    .. class:: small

        hh
           instanciate device .h **on host**, upload constituents (eg texture buffers),  
           set constituent device pointers into .h instance, upload .h instance to GPU  
        h
           simple device header, testable on CPU 
            
        --> :r:`device side hits ground running` 


.. class:: small

    **CPU/GPU Counterpart Code Organization for Simulation**

    +-------------------------------+-----------------+-----------------------+
    |                               | CPU             | GPU                   |
    +===============================+=================+=======================+
    | context steering              | QSim.hh         |  qsim.h               |  
    +-------------------------------+-----------------+-----------------------+
    | curandState setup             | QRng.hh         |  qrng.h               |
    +-------------------------------+-----------------+-----------------------+
    | property interpolation        | QProp.hh        |  qprop.h              |
    +-------------------------------+-----------------+-----------------------+
    | event handling                | QEvent.hh       |  qevent.h             |
    +-------------------------------+-----------------+-----------------------+
    | Cerenkov generation           | QCerenkov.hh    |  qcerenkov.h          |
    +-------------------------------+-----------------+-----------------------+
    | Scintillation generation      | QScint.hh       |  qscint.h             |
    +-------------------------------+-----------------+-----------------------+
    | texture handling              | QTex.hh         |  cudaTextureObject_t  |
    +-------------------------------+-----------------+-----------------------+
    

    * :r:`facilitate fine-grained modular testing` 
    * bulk of GPU code in simple to test headers 

      * test most "GPU" code on CPU,  eg using mock curand

    * *QUDARap* does not depend on OptiX -> more flexible -> simpler testing    



:small:`QUDARap : CUDA Optical Simulation Implementation` Talk
--------------------------------------------------------------

.. class:: normal

    Of course in addition to geometry intersections the simulation also 
    needs the optical physics. The QUDARap package is a pure CUDA port 
    of the Geant4 optical simulation, with no OptiX dependency. 

    [Notes: mainly of intersect for people writing CUDA code, a useful pattern] 


.. comment

       +---------------------------------------+
       | **A** (GPU) CSGOptiX/qsim.h           |
       +=======================================+
       |  qsim => sctx/sevent/SEvt             |
       +---------------------------------------+

       +---------------------------------------+
       | **B** (CPU) U4Recorder                |
       +=======================================+
       | G4StepPoint => sctx/sevent/SEvt       |
       +---------------------------------------+





:small:`Validation of Opticks Simulation(A) by Comparison with Geant4 Sim. (B)`
--------------------------------------------------------------------------------

.. sidebar:: :small:`A+B photon histories => SEvt`

   .. class:: small

      * **A** : CSGOptiX : qsim => SEvt
      * **B** : U4Recorder : G4StepPoint => SEvt 

      +---------------------------------------+
      | **Opticks Event** : sysrap/SEvt.hh    |
      +=======================================+ 
      | sevent.h sctx.h sphoton.h srec.h ...  |
      +---------------------------------------+
      | :r:`serialize to NumPy .npy arrays`   |
      +---------------------------------------+

      => A-B comparison, matplotlib/pyvista plotting

      +------------+------------+------------------+
      |  array     | shape      |  notes           |  
      +============+============+==================+
      | inphoton   | (n,4,4)    | input photons    |
      +------------+------------+------------------+
      | photon     | (n,4,4)    | final photons    |
      +------------+------------+------------------+
      | record     | (n,32,4,4) | photon histories |
      +------------+------------+------------------+
      | seq        |  (n,2,2)   | uint64 histories |   
      +------------+------------+------------------+
      | aux        | (n,32,4,4) | extra point info |       
      +------------+------------+------------------+
      | sframe     | (4,4,4)    | target M2W W2M   |
      +------------+------------+------------------+

      :b:`Record of every point of every photon`


.. class:: small 

   **A and B always same photon counts (due to gensteps)** 

   1. direct comparison when simulations are random aligned
   2. when not aligned : statistical Chi2 history comparison

      * compare history frequencies, Chi2 points to issues

   **Primary Issue : double vs float, also:**

   * geometry bugs : overlaps, coincident faces 
   * grazing incidence, edge skimmers

   After debugged : :b:`fraction of percent diffs` 

   **Optical Performance : Very dependent on geometry + modelling**

   After avoiding geometry problems : G4Torus, deep CSG trees

   * :r:`have achieved > 1500x Geant4 [1]` 
   * :b:`removes optical bottlenecks : memory + processing` 

.. class:: tiny 

   [1] Single threaded Geant4 10.4.2, NVIDIA Quadro RTX 8000 (48G), 1st gen RTX, ancient JUNO geom, OptiX 6.5, ancient Opticks 
    

:small:`Validation of Opticks Simulation(A) by Comparison with Geant4 Sim. (B)` Talk
------------------------------------------------------------------------------------

.. class:: normal

    The Opticks simulation is validated by comparison with the Geant4 simulation. 

    Full details of the optical photon propagations from both simulations 
    are collected into Opticks Events and persisted to NumPy arrays. 
    Allowing NumPy analysis to compare the photon propagations. 


:small:`Optical Simulation Comparison : Statistical OR Direct`
----------------------------------------------------------------

.. class:: small

    Statistical Chi-squared comparison of photon history occurence between two simulations

    * powerful metric to find discrepancies between simulations (eg from near-degenerate geometry)

.. raw:: html
 
    <pre class="mypretiny">
    c2sum/c2n:c2per(C2CUT)  280.88/188:1.494 (30)

    np.c_[siq,_quo,siq,sabo2,sc2,sabo1][0:25]  ## A-B history frequency chi2 comparison 
        0   TO BT BT BT BT SD                                             33322  33343    0.0066        1      2  
        1   TO BT BT BT BT SA                                             28160  28070    0.1441        8      0  
        2   TO BT BT BT BT BT SR SA                                        6270   6268    0.0003    10363  10565  
        3   TO BT BT BT BT BT SA                                           4552   4649    1.0226     8398   8433  
        4   TO BT BT BT BT BT SR BR SR SA                                  1154   1186    0.4376    21156  21014  
        5   TO BT BT BT BT BT SR BR SA                                      923    989    2.2782    20241  20201  
        6   TO BT BT BT BT BR BT BT BT BT BT BT AB                          946    958    0.0756    10389   8432  
        7   TO BT BT BT BT BT SR SR SA                                      901    942    0.9121    10399  10410  
        8   TO BT BT AB                                                     878    895    0.1630       26    102  
        9   TO BT BT BT BT BT SR BT BT BT BT BT BT BT AB                    615    635    0.3200    20974  22027  
       10   TO BT BT BT BT BR BT BT BT BT AB                                571    601    0.7679     8459   9208  
       11   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SA                    533    537    0.0150     7312   7299  
       <span class="r">12   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SD        503    396   12.7353    12018  11465</span>  
       13   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SD                    480    497    0.2958     7974   7967  
       14   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SA        412    411    0.0012    11467  11471  
       15   TO BT BT BT BT BT SR SR SR SA                                   383    396    0.2169    10362  10368  
     </pre>

.. class:: small

    When causes of discrepancy cannot be identified statistically

    * use common input photons + aligned random consumption between simulations 
    * enable direct photon-to-photon comparison of simulations : reveals precisely where simulations diverge

    :b:`Comparison of two independent optical simulation implementations : ideal way find issues`


:small:`Optical Simulation Comparison : Statistical OR Direct` Talk
-------------------------------------------------------------------

.. class:: normal

    Ideal 



:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_yy_frame_close.png`
----------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:130mm;" />

.. class:: small

    ``Green : start position (100k input photons)`` 

    ``Red : end position,  Cyan : other position``


:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_yy_frame_close.png` Talk
-----------------------------------------------------------

.. class:: normal

    3D pyvista view of photon points here from input photons shown in green. 
    The squares indicates the target frame.


:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_b.png`
-------------------------------------------

.. class:: small

   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   |emsp| |emsp| |emsp| |emsp| |emsp| 
   ``cd ~/j/ntds ; N=1 ./ntds.sh ana``  

.. raw:: html

    <p style="margin-bottom:150mm;" />

.. class:: small

   :b:`Geant4/U4Recorder 3D photon points transformed into target frame, viewed in 2D`
 

:i:`B_V1J008_N1_ip_MOI_Hama:0:1000_b.png` Talk
----------------------------------------------

.. class:: normal

   This is a 2D view of the target frame, showing intersection positions on the
   PMT mask and inside the PMT. 



:i:`B_V1J008_N1_OIPF_NNVT:0:1000_gridxy.png`
----------------------------------------------


::

     export OPTICKS_INPUT_PHOTON=GridXY_X1000_Z1000_40k_f8.npy
     export OPTICKS_INPUT_PHOTON_FRAME=NNVT:0:1000

     MODE=3 EDL=1 N=0 EYE=500,0,2300 CHECK=not_first ~/j/ntds/ntds.sh ana


.. raw:: html

    <p style="margin-bottom:110mm;" />
    

::

    Photon step points from grid of input photons target NNVT:0:1000 (POM:1)


:i:`B_V1J008_N1_OIPF_NNVT:0:1000_gridxy.png` Talk
-------------------------------------------------

.. class:: normal

    This is a 3D pyvista view of photon points from a grid of input photons. 
    Looking closely you can distinguish the type of PMT 
    by the size of ring inside. 


:i:`cxr_min__eye_1,0,5__zoom_2__tmin_0.5__NNVT:0:1000_demo.jpg`
-----------------------------------------------------------------

``ray traced renders : exact same geometry "seen" by simulation``


:i:`cxr_min__eye_1,0,5__zoom_2__tmin_0.5__NNVT:0:1000_demo.jpg` Talk
--------------------------------------------------------------------

.. class:: normal

    This is a ray trace render targetting the same group of PMTs. 
    You can see the same pattern of PMTs from the ray trace and from the simulation. 




:small:`Multi-Layer Thin Film (A,R,T) Calc using TMM Calc (Custom4 Package)`
------------------------------------------------------------------------------

.. sidebar:: :small:`TMM : Transfer Matrix Method`
 
   .. image:: tmm/multi-layer-stack.png
       :align: center
       :width: 400px

   .. class:: small

       **multi-layer thin films, coherent calc:**

       * complex refractives indices, thicknesses
       * => (A,R,T)  (Absorb, Reflect, Transmit)
       * Used from **C4OpBoundaryProcess**  

       :r:`header-only GPU/CPU` : **C4MultiLayrStack.h**       
    
       https://github.com/simoncblyth/customgeant4/

.. class:: small


    C4OpBoundaryProcess.hh
       G4OpBoundaryProcess with C4CustomART.h 
    
    C4CustomART.h
       integrate custom boundary process and TMM calculation

    C4MultiLayrStack.h : :b:`CPU/GPU TMM calculation of (A,R,T)` 
       based on complex refractive indices and layer thicknesses 
 
       * GPU: **using thrust::complex** CPU:**using std::complex**

    :r:`Custom4: Simplifies JUNO PMT Optical Model + Geometry` 

.. image:: GEOM/FewPMT/U4SimtraceTest/1/figs/U4SimtraceTest/mpcap/FewPMT_demo.png
   :width: 580px
   :align: left


.. comment
 
    .. image:: Custom4/Custom4_README.png
       :width: 580px
       :align: left


:small:`Multi-Layer Thin Film (A,R,T) Calc using TMM Calc (Custom4 Package)` Talk
---------------------------------------------------------------------------------

.. class:: normal

   Customizing the Geant4 boundary process allows a very natural 
   way to support calculation of thin film interference effects 
   using the transfer matrix method. That is implemented in a 
   single header that is used both on CPU and GPU.  

   This slide summarizes recent work that enables the JUNO PMT geometry 
   to be simplified and also enables the same PMT geometry to be used 
   for the Geant4 and Opticks simulations. 




:i:`LayrTest__R12860_Aspa.png`
---------------------------------

:i:`LayrTest__R12860_Aspa.png` Talk
-----------------------------------

.. class:: normal

    Aspa : This is just showing the absorption, the dotted lines are the average of the S and P polarizations




:small:`Amdahls "Law" : Expected Speedup Limited by Serial Processing`
--------------------------------------------------------------------------------------------

.. sidebar:: :small:`S(n) Expected Speedup`

    .. comment

       :width: 1176px
       :height: 358px
       :width: 588px 
       :height: 179px
            
    .. image:: /env/presentation/parallel/amdahl.png
       :width: 392px 
       :height: 112px
       :align: center


    .. class:: small

        *P* 
             parallelizable proportion
        *1-P*
             non-parallelizable portion
        *n*
             parallel speedup factor  



optical photon simulation, P ~ 99% of CPU time  

* -> potential overall speedup S(n) is 100x 
* even with parallel speedup factor >> 1000x  



**Must consider processing "big picture"**

* remove bottlenecks one by one
* re-evaluate "big picture" after each  


:small:`Amdahls "Law" : Expected Speedup Limited by Serial Processing` Talk
---------------------------------------------------------------------------

.. class:: normal

   Serial Portion of processing determines the overall 
   speedup because this goes to zero 




:i:`amdahl_p_sensitive.png`
-----------------------------

.. class:: small

    .. image:: /env/presentation/parallel/amdahl.png
       :width: 392px 
       :height: 112px
       :align: center


:i:`amdahl_p_sensitive.png` Talk
--------------------------------

.. class:: normal

   Having a large parallel speedup of 1000x or so 
   is only actually useful to overall speedup when the 
   parallel fraction is large over 98 percent or, 
   otherwise the serial portion limits performance. 



:small:`How much parellelized speedup actually useful to overall speedup?`
---------------------------------------------------------------------------

.. class:: small

   :r:`Very dependant on the parallel fraction`

   +---------------------------------------------------------------------------------------------------------------+
   |  **Theoretical Overall Speedup for various parallel fractions and parallelized speedups**                     |
   +-------------------+-------------------------------+-----------------------------------------------------------+
   |                   |   Parallelized Speedup        |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+
   | Parallel Fraction |   100x  |   1000x   | limit   |    Notes                                                  |
   +===================+=========+===========+=========+===========================================================+
   |     95%           |   17x   |   20x     |  20x    |  Little benefit beyond ~100x parallelized speedup         |
   +-------------------+---------+-----------+---------+                                                           |
   |     96%           |   20x   |   24x     |  25x    |                                                           |
   +-------------------+---------+-----------+---------+                                                           |
   |     97%           |   25x   |   32x     |  33.3x  |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+
   |     98%           |   34x   |   48x     |  50x    |  Substantial benefit from more parallelized speedup       |
   +-------------------+---------+-----------+---------+                                                           | 
   |     99%           |   50x   |   91x     | 100x    |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+


::

    In [1]: run ~/opticks/ana/amdahl.py

    In [2]: Amdahl.Overall_Speedup(np.array([100,1000,np.inf]),0.95)
    Out[2]: array([16.807, 19.627, 20.   ])

    In [3]: Amdahl.Overall_Speedup(np.array([100,1000,np.inf]),0.99)
    Out[3]: array([ 50.251,  90.992, 100.   ])


:small:`How much parellelized speedup actually useful to overall speedup?` Talk
-------------------------------------------------------------------------------

.. class:: normal

    This is the same information numerically 


:small:`Summary and Links`
-------------------------------------------------------------------------------------

.. sidebar:: :small:`Hidden Benefits of Adopting Opticks`

   .. class:: small

      * detailed photon instrumentation, validation 
      * comparisons find issues with both simulations:
       
        * complex geometry, overlaps, bugs... 

      :r:`=> using Opticks improves CPU simulation too !!`

.. raw:: html

     <p style="margin-bottom:5mm;" />

..

  *Opticks* : state-of-the-art GPU ray traced optical simulation integrated with *Geant4*. 
  Full re-implementation of Opticks geometry and simulation for NVIDIA OptiX 7 completed.


.. raw:: html

     <p style="margin-bottom:15mm;" />

.. class:: normal

  * NVIDIA Ray Trace Performance continues rapid progress (2x each generation) 
  * **any simulation limited by optical photons can benefit from Opticks**
  * more photon limited -> more overall speedup (99% -> 100x)


.. table::
    :align: center

    +--------------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks        | code repository                         |                   
    +--------------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io                 | presentations and videos                |
    +--------------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                      | forum/mailing list archive              |
    +--------------------------------------------------+-----------------------------------------+
    | email: ``opticks+subscribe@groups.io``           | subscribe to mailing list               |
    +--------------------------------------------------+-----------------------------------------+ 
    | ``simon.c.blyth@gmail.com``                      | any questions                           |   
    +--------------------------------------------------+-----------------------------------------+ 

:small:`Summary and Links` Talk
-------------------------------

.. class:: normal

    Opticks brings state-of-the-art GPU ray tracing performance to optical photon 
    simulations. 

    The detailed validations needed when adopting a new simulation has a 
    hidden benefit in that detailed comparisons reveal problems with both 
    simulations. Adopting Opticks means you will 
    improve your CPU simulation whilst also giving you a GPU simulation.  
 
    Links to get you started with using Opticks are listed here.





