.. meta::
   :title: Opticks CHEP 2023
   :description: (2023 May) JUNO, OptiX, Opticks
   :note: 15 min including questions 

.. include:: my_s5defs.txt


.. comment

    Opticks : GPU Optical Photon Simulation using NVIDIA OptiX 7 and NVIDIA CUDA

    Opticks is an open source project that accelerates optical photon simulation by
    integrating NVIDIA GPU ray tracing, accessed via the NVIDIA OptiX 7 API, with
    Geant4 toolkit based simulations. A single NVIDIA Turing architecture GPU has
    been measured to provide optical photon simulation speedup factors exceeding
    1500 times single threaded Geant4 with a full JUNO analytic GPU geometry
    automatically translated from the Geant4 geometry. Optical physics processes of
    scattering, absorption, scintillator reemission and boundary processes are
    implemented in CUDA based on Geant4.  Wavelength-dependent material and surface
    properties as well as inverse cumulative distribution functions for reemission
    are interleaved into GPU textures providing fast interpolated property lookup
    or wavelength generation.

    In this work we describe the near complete re-implementation of geometry and
    optical simulation required to adopt the entirely new NVIDIA OptiX 7 API, with
    the implementation now directly CUDA based with OptiX usage restricted to
    providing intersects.  The new Opticks features a modular many small header
    design that provides fine grained testing both on GPU and CPU as well as
    substantial code reductions from CPU/GPU sharing.  Enhanced modularity has
    enabled CSG tree generalization to support "list-nodes", similar to
    G4MultiUnion, that improve performance for complex CSG solids.  Recent addition
    of support for interference effects in boundaries with multiple thin layers,
    such as anti-reflection coatings and photocathodes, using CUDA compatible
    transfer matrix method (TMM) calculations of reflectance, transmittance and
    absorptance is also reported.


    * complete re-implementation of geometry 
    * complete re-implementation of optical simulation
    * CSG tree generalizations to support "list-nodes" to improve handling of complex CSG solids
    * multi-thin-layer TMM 

    * list of packages (?)




:i:`Opticks : GPU Optical Photon Simulation using NVIDIA OptiX 7 and NVIDIA CUDA` 
========================================================================================


.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey;text-align:center;"> 
          <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA® OptiX™ 7, NVIDIA® CUDA™

        <h2 style="background-color:lightgrey;text-align:center"> Open source, https://bitbucket.org/simoncblyth/opticks </h2>
    </h1>
    </header>
    </div>

    <img style="position:absolute; top:200px; LEFT:100px; WIDTH:200px; " src="/env/presentation/juno/JUNO_logo.png"  />
    <div class="mycredit">
    <h2 style="background-color:lightgrey"> Simon C Blyth, IHEP, CAS &mdash; (Presented by Dr Tao Lin, IHEP, CAS) &mdash; CHEP, Norfolk VA, 8-12 May 2023</h2>
    </div>


.. s5_talk:: 

    Opticks applies state-of-the-art GPU ray tracing from NVIDIA OptiX to optical photon simulation 
    and integrates this with Geant4. This can give drastic speedups of more a factor 1000.

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.



Outline
----------------------------------------------------

.. image:: /env/presentation/newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right


.. class:: small


    .. raw:: html

       <span>&nbsp;</span>

    * Optical Photon Simulation : Context and Problem

      * p2: Jiangmen Underground Neutrino Observatory (JUNO)
      * p3: JUNO Optical Photon Simulation Problem...
      * p4: Optical Photon Simulation ≈ Ray Traced Image Rendering

    * NVIDIA Tools to create Solution   

      * p5,6: NVIDIA Ada Lovelave : 3rd Generation RTX, RT Cores in Data-Center
      * p7: NVIDIA OptiX Ray Tracing Engine
      * p8: NVIDIA OptiX 7 : Entirely new thin API

    * Opticks : Introduction + Full Re-implementation

      * p9,10: Geant4 + Opticks Hybrid Workflow : External Optical Photon Simulation
      * p11: Full re-implementation for NVIDIA OptiX 7 API
      * p12-14: *CSGFoundry* Geometry Model, Translation to GPU 
      * p15: QUDARap : CUDA Optical Simulation Implementation

    * Opticks : New Features 

      * p16:n-Ary CSG "List-Nodes"
      * p17,18: Specialized n-ary CSG intersect algs : "contiguous" and "dis-contiguous"
      * p19: Multi-Layer Thin Film (A,R,T) Calc using TMM (Custom4 Package)

    * p20: Summary + Links 

    .. raw:: html
 
       <hr/>


.. s5_talk::

    The focus of this talk is recent progress on migrating Opticks
    to work with the all new NVIDIA OptiX 7 API.
    

:i:`JUNO_Intro_2`
------------------

.. s5_talk::

    JUNO will be the worlds largest liquid scintillator detector,
    with a 20 kiloton spherical volume of scintillator instrumented with  
    almost 50 thousand PMTs. The diameter of the sphere is 35 meters. 


`Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <pre>







     </pre>

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


.. s5_talk::

   A muon travelling across the scintillator yields tens of millions 
   of optical photons, presenting memory and time challenges for simulation.

   Most of the time is taken finding intersections between photons and geometry 
   Simulation is not alone in this bottleneck.


.. comment

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation and we
   are interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 



:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: Not a Photo, a Calculation

    .. image:: /env/optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. class:: small


    :bluebold:`simulation` 
       photon parameters at sensors (PMTs) 

    :bluebold:`rendering` 
       pixel values at image plane


.. raw:: html

    <pre>

    </pre>


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :redbold:`both limited by ray geometry intersection, aka ray tracing`


.. raw:: html

    <pre>

    </pre>

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


.. s5_talk::

    Ray traced image rendering in computer graphics has exactly the same bottleneck.
    Actually, there is a lot in common between optical photon simulation and ray traced image rendering.   
    Simulation gives photon parameters at PMTs, rendering gives pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is widely used resulting in huge efforts to improve ray tracing perfromance.
    


:small:`NVIDIA Ada : 3rd Generation RTX`
--------------------------------------------------------------------------

.. class:: small

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 4090 (2022)** 

     * 16,384 CUDA Cores, 24GB VRAM, USD 1599

   * :r:`Continued large ray tracing improvements:` 

     * **Ada** ~2x ray trace over **Ampere** (2020), 4x with DLSS 3
     * **Ampere** ~2x ray trace over **Turing** (2018)  
    
   * DLSS : Deep Learning Super Sampling 

     * AI upsampling, not applicable to optical simulation



.. s5_talk::

    GPU Ray Tracing performance continue to improve rapidly.
    With Ampere there is a big increase in the numbers of CUDA 
    cores at the same price points.   


.. comment

    :i:`ada_lovelace_leap_in_ray_tracing_performance_19206531.jpg`
    ----------------------------------------------------------------

    :i:`ada_lovelace_123_RTX_generations_18976718.jpg`
    -------------------------------------------------------------

    :small:`NVIDIA OptiX 7 Programs`
    ----------------------------------

    .. class:: small

       https://developer.nvidia.com/rtx/ray-tracing/optix



:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center`
-------------------------------------------------------------------------

.. sidebar:: :small:`Data Center GPUs with RT Cores`

    .. class:: small

        * :b:`An Established part of NVIDIA Lineup`

        +--------------+------------------+-----------------+  
        |              |    NVIDIA L40    | NVIDIA L4       |   
        +==============+==================+=================+
        |  Release     |   2022/10        |  2023/03        |   
        +--------------+------------------+-----------------+  
        |  GPU Arch    |   Ada Lovelace   |  Ada Lovelace   |        
        +--------------+------------------+-----------------+  
        |  VRAM        |   48 GB gddr6    | 24 GB gddr6     |   
        +--------------+------------------+-----------------+  
        |  TDP         |    300W          |  :r:`72W`       |   
        +--------------+------------------+-----------------+  
        |  Form factor |    dual slot     |  :r:`1-slot`    |   
        +--------------+------------------+-----------------+  
        | CUDA Core    |    18,176        |   7,680         |    
        +--------------+------------------+-----------------+  
        | :b:`RT Core` |:b:`142 (3rd gen)`|:b:`60 (3rd gen)`|    
        +--------------+------------------+-----------------+  
        | Tensor Core  |    568 (4th gen) |   240 (4th gen) |    
        +--------------+------------------+-----------------+  
        |  FP32        |    90.5 TFLOPS   |  30 TFLOPS      |   
        +--------------+------------------+-----------------+  
        |  FP16(*)     |    181 TFLOPS    |  121 TFLOPS     |   
        +--------------+------------------+-----------------+  
        | Predecessor  |    A40           |    T4           |   
        +--------------+------------------+-----------------+  

        (*) x2 with Sparsity 


.. class:: small


    **NVIDIA L4 Tensor Core GPU (Released 2023/03)**

    * Ada Lovelace GPU architecture
    * :r:`universal accelerator for graphics and AI workloads` 
    * :b:`small form-factor, easy to integrate, power efficient` 
    * PCIe Gen4 x16 slot without extra power
    * Google Cloud adopted for G2 VMs, successor to **NVIDIA T4**
    * **NVIDIA L4 likely to become a very popular GPU**

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    `NVIDIA L4 Tensor Core GPU (Data Center, low profile+power)`

.. s5_talk::

    Hardware Accelerated Ray Tracing is becoming much more commonly available 



:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing`
--------------------------------------------------------------------------

.. sidebar:: :small:`Flexible Ray Tracing Pipeline` 

    .. class:: small

        :g:`Green: User Programs`,  :e:`Grey: Fixed function/HW`

    .. image:: /env/presentation/nvidia/optix7/OptiX-API.png
       :width: 450px
       :align: right

    .. class:: small

        :b:`Analogous to OpenGL rasterization pipeline` 


.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * :r:`Programmable GPU-accelerated Ray-Tracing Pipeline`
   * Single-ray shader programming model using CUDA
   * ray tracing acceleration using RT Cores (RTX GPUs)
   * "...free to use within any application..."

   **OptiX features**

   * acceleration structure creation + traversal (eg BVH)
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

   ``https://developer.nvidia.com/rtx/ray-tracing/optix``

.. class:: small

   **User provides (Green):**

   * ray generation
   * geometry bounding boxes
   * intersect functions 
   * instance transforms

   

.. s5_talk::

   NVIDIA OptiX makes GPU ray tracing accessible 

   * it divides up the ray tracing workflow 
   * the yellow boxes represent user provided CUDA programs, including:

     * ray generation : where Opticks generates photons and steers the simulation
     * intersection : where the geometry is implemented 

   * geometry has to be translated into a GPU appropriate form



:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`GPU Ray Tracing APIs Converged`

    .. class:: small

        * 3 APIs (DXR,VKRay,OptiX7) over RTX 
        * Driver updates :r:`independent of application`  
        * Support new GPUs, performance improvements 

.. class:: small

    **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

    * low-level CUDA-centric thin API (Vulkan-ized)
    * headers only (no library, impl in Driver) 
    * Minimal host state,  :red:`All host functions are thread-safe`
    * GPU launches : explicit, asynchronous (CUDA streams)
    * :strike:`near perfect scaling to 4 GPUs, for free` 
    * :strike:`Shared CPU/GPU geometry context`
    * :strike:`GPU memory management`
    * :strike:`Multi-GPU support`


.. class:: small

    **Advantages of 6->7 transition**

    * More control/flexibility over everything 
    * :b:`Keep pace with state-of-the-art GPU ray tracing` 
    * Fully benefit from current + future GPUs : RT cores, RTX 

.. class:: small

    **BUT:** :r:`demanded full re-implementation of Opticks` 
     


.. s5_talk::

   * OptiX 7 is an entirely new API, dropping many features used by Opticks
   * re-implementation of large parts of Opticks is necessary
   * i will cover recent progress on this shortly



Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow
-------------------------------------------------------------

.. class:: small

    .. table::
        :align: center

        +--------------------------------------------------+
        | :b:`https://bitbucket.org/simoncblyth/opticks`   |
        +--------------------------------------------------+


.. raw:: html

    <p style="margin-bottom:13cm;" />

.. class:: small

    Opticks API : split according to dependency -- Optical photons are GPU "resident", only hits need to be copied to CPU memory 


.. s5_talk::

    This shows how Opticks is integrated with Geant4. The geometry is translated 
    and uploaded to the GPU at initialization.

    Cerenkov or Scintillation gensteps, the blue lines, are the generation parameters 
    uploaded to the GPU so optical photon generation can be done there.

    This allows the optical photon simulation to be entirely offloaded  
    to the GPU with only collected hits requiring CPU memory.
 

Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2
--------------------------------------------------------

.. sidebar:: :small:`Offload Optical Simulation to GPU`

   .. class:: small

      * :redbold:`translate Geant4 geometry to OptiX GPU`  

        * intersect functions
        * instance transforms
        * GPU textures for mat/surf properties

      * CUDA port of Geant4 generation+propagation

        * cuRAND random number generation  


.. s5_talk::

    In general, I found that directly porting the optical physics has been straightforward.
    Most of problems and effort of Opticks been with the geometry, because the 
    geometry model needs to be very different from the deep tree of volumes of Geant4.



:small:`Full re-implementation of Opticks for NVIDIA OptiX 7 API` 
--------------------------------------------------------------------

.. class:: small

    * :r:`Huge change unavoidable from new OptiX API` --> :b:`So profit from rethink of simulation code` --> **2nd impl advantage** 

    +------------------------------------------+-----------------------------------------------------+
    |  Old simulation (OptiXRap)               |  New simulation (QUDARap/qsim.h + CSGOptiX, CSG)    | 
    +==========================================+=====================================================+
    |  * implemented on top of old OptiX API   | * pure CUDA implementation                          |
    |                                          | * OptiX use kept separate, just for intersection    |
    |                                          |                                                     |
    +------------------------------------------+-----------------------------------------------------+
    |  * monolithic .cu                        | * many small headers                                |
    |  * GPU only implementation               | * many GPU+CPU headers                              |
    |  * deep stack of support code            | * shallow stack : QUDARap depends only on SYSRap    | 
    +------------------------------------------+-----------------------------------------------------+
    |  * most code in GPU only context,        | * strict code segregation                           |
    |    even when not needing OptiX or CUDA   |                                                     |
    |                                          |   * code not needing GPU in SYSRap not QUDARap      |
    +------------------------------------------+-----------------------------------------------------+
    |  * testing : GPU only, coarse            | * testing : CPU+GPU , fine-grained                  |
    |                                          | * curand mocking on CPU                             | 
    +------------------------------------------+-----------------------------------------------------+
    |  * limited CPU/GPU code sharing          | * maximal sharing : SEvt.hh, sphoton.h, ...         |
    +------------------------------------------+-----------------------------------------------------+
    |  * timeconsuming manual random alignment | * :b:`new systematic approach to random alignment`  |  
    |    conducted via debugger                |                                                     |
    +------------------------------------------+-----------------------------------------------------+

    **Goals of re-implementation : flexible, modular GPU simulation, easily testable, less code**

    * code reduction, sharing as much as possible between CPU and GPU
    * fine grained testing on both CPU and GPU, with GPU curand mocking 
    * profit from several years of CUDA experience, eg QSim.hh/qsim.h host/device counterpart pattern:

      * hostside initializes and uploads device side counterpart --> :r:`device side hits ground running` 


.. s5_talk::

    Embrace the change : might as well profit from a rethink 




:small:`Two-Level Hierarchy : Instance transforms (TLAS) over Geometry (BLAS)`
-------------------------------------------------------------------------------

.. class:: small

    **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


.. class:: small

    .. figure:: /env/presentation/nvidia/tlas_blas_two_level_hierarchy.png
        :width: 800px
        :align: right 

        https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

.. class:: small

   AS
      Acceleration Structure

   TLAS (aka **IAS**) 
      4x4 transforms, refs to BLAS
       
   BLAS (aka **GAS**)
      | triangles : vertices, indices
      | custom primitives : AABB 

   AABB
      axis-aligned bounding box 


   **SBT : Shader Binding Table**

   Flexibly binds together:
 
   1. geometry objects
   2. shader programs 
   3. data for shader programs

   **Hidden in OptiX 1-6 APIs**



.. s5_talk::

   OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
   The other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
   This is because OptiX supports multiple instance levels. 
   But the simple two level is faster as that can be done on the RT cores.

   Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  



:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7`
-------------------------------------------------------------------------------

.. sidebar:: :small:`CSGFoundry Model`

    .. class:: small

        * array-based -> simple serialization + upload
        * entire geometry in 4 GPU allocations 
        * factorized using subtree digests 

.. class:: small

    **Geant4 Geometry Model (JUNO: 300k PV, deep hierarchy)**

    +----+---------------------------+---------------------------------------------+ 
    | PV | *G4VPhysicalVolume*       | placed, refs LV                             |
    +----+---------------------------+---------------------------------------------+ 
    | LV | *G4LogicalVolume*         | unplaced, refs SO                           |
    +----+---------------------------+---------------------------------------------+ 
    | SO | *G4VSolid,G4BooleanSolid* | binary tree of SO "nodes"                   |
    +----+---------------------------+---------------------------------------------+ 

    **Opticks CSGFoundry Geometry Model** (index references)

    +---------------+--------------------------------------------------------------------+-------------------------+
    | struct        | Notes                                                              |  Geant4 Equivalent      |
    +===============+====================================================================+=========================+
    | *CSGFoundry*  | vectors of the below, easily serialized + uploaded                 | None                    |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *qat4*        | 4x4 transform refs *CSGSolid* using "spare" 4th column             |                         |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *CSGSolid*    | refs sequence of *CSGPrim*                                         | Groups of nearby PV, LV | 
    |               +--------------------------------------------------------------------+ + Remainder             |
    |               | eg JUNO *CSGSolid* numPrim [3089, 5, 11, 14, 6, 1, 1, 1, 1, 130]   |                         |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *CSGPrim*     | bbox, refs sequence of *CSGNode*, root of CSG Tree of nodes        | root *G4VSolid*         |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *CSGNode*     | CSG node parameters (JUNO: ~23k *CSGNode*)                         | node *G4VSolid*         |
    +---------------+--------------------------------------------------------------------+-------------------------+

    **NVIDIA OptiX 7 Geometry Acceleration Structures (JUNO: 1 IAS + 10 GAS, 2-level hierarchy)**

    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | IAS | Instance Acceleration Structures | JUNO: 1 IAS created from vector of ~50k *qat4* (JUNO)                   |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | GAS | Geometry Acceleration Structures | JUNO: 10 GAS created from 10 *CSGSolid* (which refs *CSGPrim,CSGNode* ) |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 

.. s5_talk::

   SMALL 
   The Foundry geometry model comprises : Inst, Solid, Prim and Node

   Starting from the bottom:

   * the Node are CSG constituent shapes or operators
   * the Prim reference a range of Node forming serialized complete binary trees
   * the Solid reference one or more Prim
   * the Inst reference one or more Solid 

   **Prim:** are equivalent to G4VSolid

   **Solid:** are compound Prim, each type of PMT corresponds to a Solid 

   **Inst:** are 4x4 transforms with index refererences to Solid 

   The model is designed to work with the OptiX 7 acceleration structures:

   * Solid -> GAS (Geometry Acceleration Structure)
   * Inst  -> IAS (Instance Acceleration Structure)

   The JUNO geometry of 300,000 volumes is factorized into 10 Solid which 
   are referenced from a single instance acceleration structure. 
    
   The array-based simplicity makes it fast to upload to GPU, 
   with the entire geometry in 4 GPU allocations. 




:i:`[9]cxr_i0_t8,_-1 : EXCLUDE SLOWEST`
-----------------------------------------

.. raw:: html

    <pre>



    </pre>


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        CSGFoundry CPU/GPU Geometry 

        * :redbold:`purely analytic CSG, no triangles` 


.. s5_talk::

   Here is one of the first JUNO renders with the OptiX 7 using the Foundry model.

   Note that there are no triangles here, this is a purely analytic ray trace with 
   the geometry that the simulation will use.



:small:`QUDARap : CUDA Optical Simulation Implementation`
------------------------------------------------------------

.. sidebar:: :small:`CPU Pre-Init of GPU Counterpart`

    .. class:: small

        hh
           instanciate device .h **on host**, upload constituents (eg texture buffers),  
           set constituent device pointers into .h instance, upload .h instance to GPU  
        h
           simple device header, testable on CPU 
            
        --> :r:`device side hits ground running` 


.. class:: small

    +-------------------------------+-----------------+-----------------+
    |                               | CPU             | GPU header      |
    +===============================+=================+=================+
    | context steering              | QSim.hh         |  qsim.h         |  
    +-------------------------------+-----------------+-----------------+
    | curandState setup             | QRng.hh         |  qrng.h         |
    +-------------------------------+-----------------+-----------------+
    | property interpolation        | QProp.hh        |  qprop.h        |
    +-------------------------------+-----------------+-----------------+
    | event handling                | QEvent.hh       |  qevent.h       |
    +-------------------------------+-----------------+-----------------+
    | Cerenkov generation           | QCerenkov.hh    |  qcerenkov.h    |
    +-------------------------------+-----------------+-----------------+
    | Scintillation generation      | QScint.hh       |  qscint.h       |
    +-------------------------------+-----------------+-----------------+
    | texture handling              | QTex.hh         |                 |
    +-------------------------------+-----------------+-----------------+
    
    Aims of counterpart code organization:

    * :redbold:`facilitate fine-grained modular simulation testing` 
    * bulk of GPU code in simple to test headers 

      * many can be tested on CPU

    * *QUDARap* does not depend on OptiX -> more flexible -> simpler testing    



.. s5_talk::

    CUDA implementation of optical simulation  


:small:`n-ary CSG Compound "List-Nodes" => Much Smaller CSG trees`
-------------------------------------------------------------------

.. sidebar:: :small:`Complex CSG => Tree Overheads`

    .. image:: GeoChain_Darwin/XJfixtureConstruction/CSGOptiXRenderTest/cvd0/50001/ALL/top_i0_/cxr_geochain_XJfixtureConstruction_ALL_upper.jpg 
          :align: right
          :width: 500px



.. class:: small

   * list-node references sub-nodes by **subNum** **subOffset**

   CSG_CONTIGUOUS Union
      user guarantees contiguous 
       * like G4MultiUnion of prim only

   CSG_DISCONTIGUOUS Union
      user guarantees no overlaps 
       * => simple, low resource intersect 
       * eg use for "holes" to be cutaway  

   CSG_OVERLAP Intersection
      user guarantees overlap
       * eg general G4Sphere: inner radius, thetacut, phicut

   :r:`Communicate shape more precisely`
       :r:`=> better suited intersect alg => less resources => faster` 


   Generalized Opticks CSG into three levels : tree < node < leaf (avoids recursion in intersect) 

   * `opticks/src/master/CSG/csg_intersect_tree.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_tree.h>`_ 
     `csg_intersect_node.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h>`_
     `csg_intersect_leaf.h <https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_leaf.h>`_



.. s5_talk::

   Generalize Opticks CSG beyond trees


:small:`CSG_CONTIGUOUS Union : n-ary (not bin-ary) CSG intersection`
-----------------------------------------------------------------------

.. class:: small

    * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_contiguous`

.. sidebar:: :small:`Alg works : but many TODOs`

    .. class:: small

       * integer templating : suit resources to shape
       * try sort networks, bitonic sort, ... 
       * compare performance with unbalanced trees
       * iterate implementation whilst measuring perf.


.. class:: small

    1. *zeroth pass* : find **nearest_enter** and count first exits
    2. if zero exits => outside compound => return **nearest_enter**
    3. *first pass* : collect enter distances, **farthest_exit**
    4. order enter indices making **enter** distances ascend

       * :r:`n-ary : store, sort enters` :b:`(cf bin-ary : compare two)`
       * :b:`no tree overheads, but must store+sort distances`

    5. *2nd pass* : loop over enters in distance order 

       * contiguous requirement : **enter < farthest_exit** so far  
       * find Exits for Enters that qualify as contiguous, update farthest_exit

    6. return **farthest_exit** that qualifies as contiguous


.. raw:: html

    <pre class="mypre15">
             +----------------+     +-------------------+                  DISJOINT MUST BE DISQUALIFIED
             |B               |     |D                  |                   
        +----|----+      +----|-----|----+       +------|----------+             +-----------+
        |A   |    |      |C   |     |    |       |E     |          |             |           |
        |    |    |      |    |     |    |       |      |          |             |           |
        | 0 E1    X2     E3  X4    E5   X6      E7     X8        [X9]           E10         X11
        |    |    |      |    |     |    |       |      |          |             |           |
        |    |    |      |    |     |    |       |      |          |             |           |
        +----|----+      +----|-----|----+       +------|----------+             +-----------+
             |                |     |                   |
             +----------------+     +-------------------+

             E           E          E            E                               E 
                  X           X          X              X          X                         X
     </pre>



.. s5_talk::

   Generalize Opticks CSG beyond trees




:small:`CSG_DISCONTIGUOUS Union : CSG intersection`
---------------------------------------------------------------

.. class:: small

    * https://bitbucket.org/simoncblyth/opticks/src/master/CSG/csg_intersect_node.h :r:`intersect_node_discontiguous`

    :r:`User guarantees : absolutely no overlapping between constituents`

.. raw:: html

    <pre class="mypre15">
     +-------+          +-------+          +-------+          +-------+         +-------+      
     |       |          |       |          |       |          |       |         |       |      
     |       |          |       |          |       |          |       |         |       |      
     +-------+          +-------+          +-------+          +-------+         +-------+       

     +-------+          +-------+          +-------+          +-------+         +-------+      
     |       |          |       |          |       |          |       |         |       |      
     |       |          |       |          |       |          |       |         |       |      
     +-------+          +-------+          +-------+          +-------+         +-------+       

     </pre>


.. class:: small

    * => very simple low resource intersection : **closest Enter or Exit**

    * :b:`More closely suiting algorithm to geometry => better performance`
    * this can help with "holes" subtracted from another solid : the "holes" usually do not overlap 

.. s5_talk::

   More precise communication of intent for geometry -> better performance






:small:`Multi-Layer Thin Film (A,R,T) Calc using TMM (Custom4 Package)`
----------------------------------------------------------------------------

.. sidebar:: :small:`TMM : Transfer Matrix Method`
 
   .. image:: tmm/multi-layer-stack.png
       :align: center
       :width: 400px

   .. class:: small

       **multi-layer thin films, coherent calc:**

       * complex refractives indices, thicknesses
       * => (A,R,T)  (Absorb, Reflect, Transmit)
       * Used from **C4OpBoundaryProcess**  

       :r:`header-only GPU/CPU` : **C4MultiLayrStack.h**       
    
       https://github.com/simoncblyth/customgeant4/

.. class:: small


    C4OpBoundaryProcess.hh
       G4OpBoundaryProcess with C4CustomART.h 

    C4CustomART.h
       integrate custom boundary process and TMM calculation

    C4MultiLayrStack.h : :b:`TMM calculation of (A,R,T)` 
       based on complex refractive indices and layer thicknesses 


.. class:: small

    Enables **junosw** to use natural Pyrex+Vacuum PMT geometry  

.. image:: GEOM/FewPMT/U4SimtraceTest/1/figs/U4SimtraceTest/mpcap/FewPMT_demo.png
   :width: 580px
   :align: left


.. comment
 
    .. image:: Custom4/Custom4_README.png
       :width: 580px
       :align: left


.. s5_talk::

   Circular dependency should be avoided when possible, so I did that by 
   splitting of the customization into a mini-package which is a junoenv external, 
   just like Geant4 is.  







:small:`Summary and Links`
----------------------------------------------------------------

.. sidebar:: :small:`Hidden Benefits of CPU=>GPU Sim.`

   .. class:: small

      * detailed photon instrumentation 
      * comparisons find issues with both simulations:
       
        * complex geometry, overlaps, bugs... 

      :r:`=> using Opticks improves CPU simulation`

.. image:: /env/presentation/1px.png
   :width: 500px
   :height: 20px

..

  *Opticks* : state-of-the-art GPU ray traced optical simulation integrated with *Geant4*. 
  Full re-implementation of Opticks geometry and simulation for NVIDIA OptiX 7 completed.

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 1px

  * NVIDIA Ray Trace Performance continues rapid progress (2x each gen.) 
  * Increasing availability of HW accelerated ray tracing
  * NEXT: Opticks production testing, optimization  

.. table::
    :align: center

    +--------------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks        | code repository                         |                   
    +--------------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io                 | presentations and videos                |
    +--------------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                      | forum/mailing list archive              |
    +--------------------------------------------------+-----------------------------------------+
    | email:opticks+subscribe@groups.io                | subscribe to mailing list               |
    +--------------------------------------------------+-----------------------------------------+ 


.. s5_talk::

    Summary is that : Opticks provides state-of-the-art GPU ray tracing integrated with Geant4 and that 
    there has been substantial progress with the migration to OptiX 7, 
    which is essential to keep up with the state-of-the-art.
 
    Links to get you started with using Opticks are listed here.





