.. meta::

   :title: Opticks : Innovative Optical Photon Simulation using state-of-the-art GPU ray tracing from NVIDIA OptiX
   :name: opticks_20220115_innovation_in_hep_workshop_hongkong
   :description: (Jan 2022) 
   :notes: start from opticks_aug2020_sjtu_neutrino_telescope_workshop.txt


.. include:: my_s5defs.txt

.. include:: s5_background_image.txt


.. comment

    https://indico.cern.ch/event/1096427/

    https://indico.cern.ch/event/1096427/timetable/#b-440895-mini-workshop-experim

    Friday 14th 

    07:00 London   
    08:00 CERN
    15:00 Hong Kong 

    I am going to present Opticks, an open source project that applies state-of-the-art 
    GPU ray tracing from NVIDIA OptiX to optical photon simulation using fully analytic detector 
    geometries automatically translated for the GPU from Geant4. 
    Opticks replaces the Geant4 optical photon simulation with a GPU equivalent that 
    can reach transformative speedup factors exceeding 1000 times.

    Dear Simon, 

    I made the correction. Many thanks!  Your talk was arranged at 8:00 am (CERN time) 
    on 14th, which is the first talk of the software and computing session. 
    I hope you are able to cope with it. Look forward to hearing from you.
    Cheers, 

    Weidong
         
    Dear Weidong, 

    Yes, I can give an overview of applying GPU ray tracing techniques
    to optical photon simulation.  

    https://simoncblyth.bitbucket.io/env/presentation/opticks_aug2020_sjtu_neutrino_telescope_workshop.html

    The above talk from the SJTU neutrino telescope workshop in 2020 is the last overview style talk 
    I gave which does not assume any familiarity with Opticks. So I expect to start from that 
    presentation to prepare for the Hong Kong meeting.

    The SJTU presentation was more than an hour, but the end of it is speculation on 
    future usage for enormous numbers of photons in neutrino telescopes.
     
    I would prefer not to give such a long talk as it takes longer to prepare.  
    It would be fine to trim the speculations and update for OptiX 7 development 
    and cut it down to 20-30 min.

    Simon

    Dear Simon,
    Do you think you can give an overview  talk on application of Optix in HEP
    at the Hong Kong meeting? The meeting should be around 15th of January.
    Look forward to hearing from you!

    Weidong Li

    -----邮件原件-----
    发件人: Joao Guimaraes da Costa [mailto:guimaraes@ihep.ac.cn] 
    发送时间: 2021年12月9日 2:05
    收件人: Weidong Li
    主题: Hong Kong Workshop

    Dear Weidong,

    Thanks for agreeing to help me organize the workshop in Hong Kong.
    As we discussed the topic is: "Innovation in HEP Detectors and Computing"
    We will focus on innovative ideas that can bring significant improvements to
    the field.
    There can be a range of ideas with different degrees of innovation, but the
    goal is to aim at more disruptive technologies, like Quantum computing, and
    then fill come down from there.

    We will want to invite both foreigners and chinese speakers, but we should
    try to aim at good speakers that can provide a good overview of the subject.
    I attached the timetable. The workshop will have two days, and we should try
    to split it with one day for detector and another day for
    computing/software.
    There are 4 periods each day with 1.5 hours each.

    For the workshop, usually we would like to have longer talks but also time
    for discussion.
    So, my suggestion would be two 30-minute talks per period, with 15 minutes
    each for discussion.
    Of course, we dont need to be too strict on this. Perhaps three 20-minutes
    talks on one subject and 30 min discussion also works well.

    I will have a conversation with Paolo Giacomelli and Franco Bedeschi on
    Friday afternoon.
    In the meantime, we can collect a list of possible talks.

    Regards,
    -Joao

    <br/>
   

:i:`Opticks : Innovation in Optical Photon Simulation` 
========================================================================================

.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey"> 
        <i>Opticks</i> : Innovation in Optical Photon Simulation via <br/> state-of-the-art GPU Ray Tracing from NVIDIA® OptiX™
        <h2 style="background-color:lightgrey;text-align:center"> Open source, https://bitbucket.org/simoncblyth/opticks </h2>
    </h1>
    </header>
    </div>

    <div class="mycredit">
    <h2 style="background-color:lightgrey"> Simon C Blyth, IHEP, CAS &mdash; Jan 2022, Hong Kong Workshop: Innovation in HEP Detectors & Computing </h2>
    </div>


.. s5_talk:: 

    Opticks is an open source project that applies state-of-the-art GPU ray tracing 
    from NVIDIA OptiX to optical photon simulation and integrates this with Geant4. 
    This results in drastic speedups of more than 1500 times single threaded Geant4.

    Any simulation limited by optical photons can remove those limits by using Opticks.

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.

    The number of photons across track lengths up to 35m in the scintillator 
    is about 70M 


.. comment


    Outline Opticks
    ----------------------------------------------------

    .. image:: /env/presentation/newtons-opticks.png 
       :width: 299px
       :height: 547px 
       :align: right


    .. class:: small


        .. raw:: html

           <span>&nbsp;</span>

        * Context and Problem

          * Jiangmen Underground Neutrino Observatory (JUNO)
          * Optical Photon Simulation Problem...

        * Tools to create Solution   

          * Optical Photon Simulation ≈ Ray Traced Image Rendering
          * Rasterization and Ray tracing
          * Turing Built for RTX 
          * BVH : Bounding Volume Hierarchy 
          * NVIDIA OptiX Ray Tracing Engine

        * Opticks : The Solution

          * Geant4 + Opticks Hybrid Workflow : External Optical Photon Simulation
          * Opticks : Translates G4 Optical Physics to CUDA/OptiX
          * Opticks : Translates G4 Geometry to GPU, Without Approximation
          * CUDA/OptiX Intersection Functions for ~10 Primitives
          * CUDA/OptiX Intersection Functions for Arbitrarily Complex CSG Shapes

        * Validation and Performance

          * Random Aligned Bi-Simulation -> Direct Array Comparison
          * Perfomance Scanning from 1M to 400M Photons

        * Overview + Links 

        .. raw:: html
     
           <hr/>


    .. s5_talk::

       This will be a talk of two halves:

       * first I will introduce Opticks and how it solves the 
         problem of optical photon simulation for JUNO

    .. comment

         where propagations are expected to be <100M photons per muon 




    :small:`Outline of Graphics/GPU background + Application to neutrino telescopes`
    --------------------------------------------------------------------------------

    .. image:: /env/presentation/newtons-opticks.png 
       :width: 299px
       :height: 547px 
       :align: right


    .. class:: small

        * GPU + Parallel Processing Background 

          * Amdahls "Law" : Expected speedup limited by serial processing 
          * Understanding GPU Graphical Origins -> Effective GPU Computation                                            
          * CPU Optimizes Latency, GPU Optimizes Throughput 
          * How to make effective use of GPUs ? Parallel/Simple/Uncoupled
          * GPU Demands Simplicity (Arrays) -> Big Benefits : NumPy + CuPy                                             
          * Survey of High Level General Purpose CUDA Packages

        * Graphics History/Background 

          * 50 years of rendering progress
          * 2018 : NVIDIA RTX : Project Sol Demo
          * Monte Carlo Path Tracing in Movie Production       
          * Fundamental "Rendering Equation" of Computer Graphics
          * Neumann Series solution of Rendering Equation 
          * Noise : Problem with Monte Carlo Path Tracing  
          * NVIDIA OptiX Denoiser
          * Physically Based Rendering Book : Free Online  
          * Optical Simulations : Graphics vs Physics 

        * Neutrino Telescope Optical simulations 
      
          * Giga-photon propagations : Re-usable photon "snapshots" 
          * Opticks Rayleigh Scattering : CUDA line-by-line port of G4OpRayleigh
          * Developing a photon "snapshot" cache 
          * Photon Mapping 

        * Summary 
      
       
    .. s5_talk::

       * Then I will cover GPU and graphics backgrounds 
         which can help to handle really large propagation 
         of billions of photons 

       * I will go into some details on computer graphics techniques
         as I think there is strong potential to re-purposing them 
         to help physics simulations  




    :i:`JUNO_Intro_2`
    ------------------

    .. s5_talk::

        JUNO will be the worlds largest liquid scintillator detector,
        with a spherical 20,000 ton volume of scintillator surrounded by 
        a water pool buffer which also provides water cherenkov detection.

        The scintillator is instrumented with 18 thousand 20-inch PMTs 
        and 25 thousand 3-inch PMTs     


    :i:`JUNO_Intro_3`
    ------------------

    .. s5_talk::

        JUNO will be able to detect neutrinos from many terrestrial and extra-terrestrial 
        sources including : solar, atmospheric, geo-neutrinos. 

        Despite 700 m of overburden the largest backgrounds to these neutrino signals   
        will be from cosmic muon induced processes.  

        A muon veto is used to control the backgrounds.
        
        However to minimize the time and volume vetoed,
        it is necessary to have a good muon reconstruction which means 
        that we need large samples of cosmic muons.


    Geant4 : Monte Carlo Simulation Toolkit
    ----------------------------------------


    .. s5_talk::

        Geant4 is the standard toolkit 
        used to simulate detectors 
        across several fields.



    .. comment

        including simulations of medical imaging scanners, 
        and of satellites 



    Geant4 : Monte Carlo Simulation Toolkit Generality
    ----------------------------------------------------


    .. sidebar:: :small:`Standard Simulation Tool of HEP`

       .. class:: small
            
           **Geant4** simulates particles travelling through matter

           * high energy, nuclear and accelerator physics
           * medical physics : deciding radiotherapy doses/sources 
           * space engineering : satellites

           **Geant4 Approach**

           * geometry : **tree of CSG solids**
           * particles : track position and time etc.. 
           * processes : nuclear, EM, weak, **optical**

           **Very General and Capable Tool**

           * **mostly unused for optical photon propagation**
     
       .. class:: tiny

          https://geant4.web.cern.ch


    .. s5_talk::

       Geant4 is a very general tool : but it is mostly
       not needed for the simulation of optical photons 
     


`JUNO Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <pre>







     </pre>

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         :r:`Ray-Geometry intersection Dominates`
           :r:`simulation is not alone in this problem...`

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


.. s5_talk::

   Muons travelling across the JUNO liquid scintillator will yield
   many tens of millions of optical photons. This is a huge memory and time challenge 
   for Geant4 monte carlo production.

   Most of the CPU time is taken finding intersections between photons and geometry 
   Fortunately simulation is not alone in this bottleneck.

   Optical photons are naturally parallel, 
   with only Cherenkov and Scintillation production being relevant 
   and we are only interested in photons collected at PMTs. 

   These characteristics make it straightforward to integrate an external optical
   simulation.
 


:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: Not a Photo, a Calculation

    .. image:: /env/optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :blue:`simulation` : photon parameters at PMT detectors 
    * :blue:`rendering` : pixel values at image plane
    * :red:`both limited by ray geometry intersection, aka ray tracing`


.. raw:: html

    <pre>

    </pre>

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


.. s5_talk::

    Optical photon simulation and ray traced image rendering 
    have a lot in common.

    They are both limited by ray geometry intersection (or ray tracing)

    With simulation you want to know photon parameters at PMTs, with rendering 
    you need pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is used across many industries, so there have been huge efforts
    over 50 years to improve ray tracing perfromance.
    


.. skip

      
    **August 2018 : Major Ray Tracing Advance**

    * NVIDIA RTX Platform, Turing GPU
    * :red:`ray trace dedicated hardware : RT cores` 

    * SIGGRAPH 2018, announcing RTX 
    * https://www.youtube.com/watch?v=LP6miCI6-h4





:i:`Ray-tracing vs Rasterization`
-----------------------------------

.. image:: /env/presentation/nvidia/nv_rasterization.png
   :width: 550px
   :align: left

.. image:: /env/presentation/nvidia/nv_raytrace.png
   :width: 550px
   :align: right


.. s5_talk::

   Ray tracing and rasterization are the two primary graphics rendering techniques. 

   Rasterization is the most common rendering technique
   
   * it starts from the objects in a scene, and projects them onto pixels in the image plane
   * this requires approximate triangulated geometry   
   
   Ray tracing 

   * starts from the pixels, casts rays out into the 3D scene and finds intersects
   * this can use analytic geometry, without approximation (just like Geant4)   
   * its easier to create realistic images with ray tracing because it is closer to the physics

   Ray tracing is an overloaded term.  In some contexts it means just the ray transport
   from an origin to an intersection. But is also refers more generally to the rendering technique. 

.. comment

   https://www.youtube.com/watch?v=Mrixi27G9yM
   RTX Launch



:i:`Path Tracing in Production 1`
----------------------------------


.. comment

   * http://www.realtimerendering.com/raytracing/siggraph2019/Path_Tracing_in_Production_part_1.pdf

   * https://jo.dreggn.org/path-tracing-in-production/2019/ptp-part1.pdf

   * https://cs.dartmouth.edu/~wjarosz/publications/novak18monte.html



.. s5_talk::

    Ray tracing is the building block behind **Monte Carlo Path Tracing** 

    SIGGRAPH is the primary computer graphics conference series. 
    This is the abstract from a course document sharing movie production graphics techniques. 

    * **Monte Carlo Path Tracing** is now the standard rendering technique in movie production


:i:`Path Tracing in Production 2`
-----------------------------------

.. sidebar:: :small:`Monte Carlo Path Tracing`

   .. class:: small

       :r:`Path Tracing is built on top of Ray Tracing`

       * ubiquitous rendering technique 
       * random sampling (Monte Carlo method)
       * numerical solution of **"The Rendering Eqn."**

       **Movies ≈ monte carlo optical photon simulations**


.. s5_talk::

   This means that for many movies: 

   * every frame is the result of monte carlo optical photon simulations, involving billions of photons

.. comment

   * "ground truth" render 
   * numerical integration by recursive point-sampling 
   * Russian roulette killing of rays
   * **ubiquitous** approach to solution to numerical solution of RE  
   * includes indirect light (global illumination)


.. comment

    Irradiance Caching and Derived Methods
    ----------------------------------------

    .. class:: small

       * https://cs.dartmouth.edu/~wjarosz/publications/dissertation/chapter3.pdf




:i:`The Rendering Equation 1`
------------------------------

.. s5_talk::

    SMALL
    Computer graphics is all about finding solutions to the rendering equation.
  
    The equation stems from energy conservation in equilibrium:

    * Outgoing light in some direction comes from emission and reflection at the point   
    * Light reflected from the point depends on all the incoming 
      light and the reflection characteristics of the surface. 

    What you see at one point depends on all other points that are 
    visible from it and so on recursively. 

    You can see blue, green and red casts on the teapot 
    coming from color bleeding : that arises from the 
    multiple bounces or indirect lighting.

    The rendering equation is a recursive integral equation

    * surface properties are known
    * what is unknown is the radiance distribution function

    Solving it gives you images from any viewpoint.


.. comment

    The lines on the images try to illustrate that:
 
    * what the eye at point x sees at some x-prime depends on inputs from all the 
      x-double-prime and each double-prime point depends on all the 
      treble-prime ones



       
 
:i:`The Rendering Equation 2`
------------------------------

.. s5_talk::

   This form of recursive integral equation has a solution
   which is a sum of terms with progressively increasing 
   bounces. 

   0. emission : looking at the light 
   1. direct illumination
   2. one-bounce indirect illumination
   3. two-bounce indirect illumination

   Top row shows individual contributions, with the 
   cumulative sum on the bottom row.

   Recursive integral eqn -> sum of integrals 

   The "Volumetric Rendering Equation" is a generalization to cover
   participating media eg clouds, fire, fog, skin  


 
:i:`The Rendering Equation 3`
------------------------------

.. raw:: html 

   <p style="margin-bottom:3cm;" />


.. sidebar:: :small:`Sum over increasing "bounces"`

   .. class:: small

       0. emission : direct from light source 
       1. direct illumination
       2. one-bounce indirect illumination
       3. two-bounce indirect illumination

       Top row : individual terms, Bottom row : cumulative 

       :r:`improving realism as more bounces included`


.. s5_talk::

    Realism improves as more bounces are included


.. comment

   Recursive integral eqn -> sum of integrals 

   The "Volumetric Rendering Equation" is a generalization to cover
   participating media eg clouds, fire, fog, skin  



:i:`Samples per Pixel 1`
------------------------- 

.. s5_talk::

    Monte Carlo Path Tracing 

    * amazingly general technique 
    * can produce images indistinguisable from reality 
    * BUT : suffers from slow convergence


:i:`Samples per Pixel 2`
-------------------------- 

.. sidebar:: :small:`Monte Carlo Path Tracing` 

  .. class:: small

    :b:`fantastically general technique`
      * any geometry 
      * any lighting/surface effect

    :b:`BUT noisy : slow 1/sqrt(N) convergence`
      * need many samples per pixel
      * every pixel needing several "bounces"

    :r:`=> Limited by ray tracing performance`
       

.. s5_talk::

   The technique has the usual monte carlo disadvantage of slow 
   convergence.  Much of computer graphics is about devising ways 
   to bias the sampling and speed up the convergence. 


Optical Simulation : Computer Graphics vs Physics 
------------------------------------------------------------------

.. class:: small

   ==========================================  =============================================  
    CG Rendering "Simulation"                    Particle Physics Simulation
   ==========================================  =============================================  
     simulates: image formation, vision          simulates photons: generation, propagation, detection     
     (red, green, blue)                          wavelength range eg 400-700 nm
     ignore polarization                         polarization vector propagated throughout
     participating media: clouds,fog,fire [1]    bulk scattering: Rayleigh, MIE  
     human exposure times                        nanosecond time scales
     equilibrium assumption                      transient phenomena
     ignores light speed, time                   arrival time crucial, speed of light : 30 cm/ns  
   ==========================================  =============================================  

   * **handling of time is the crucial difference**

   Despite differences :red:`many techniques+hardware+software directly applicable to physics` eg:

   * GPU accelerated ray tracing (NVIDIA OptiX)
   * GPU accelerated property interpolation via textures (NVIDIA CUDA)   
   * GPU acceleration structures (NVIDIA BVH)   

   
   Potentially Useful CG techniques for "billion photon simulations"

   * irradiance caching, photon mapping, progressive photon mapping 
   

.. class:: tiny 

   [1] search for: "Volumetric Rendering Equation"


.. s5_talk::

    There are great similarities between graphics rendering and physics simulation
    but also some clear differences.

    * principal difference is handling of time : graphics assuming 
      long time scales and equilibium  

    * despite the differences there is great scope for re-purposing 
      computer graphics techniques+projects to assist physics simulation   



:i:`SIGGRAPH_2018_Announcing_Worlds_First_Ray_Tracing_GPU 2`
--------------------------------------------------------------


.. raw:: html 

   <p style="margin-bottom:7cm;" />


.. class:: huge

    .. table:: 
       :align: right

       
       +----------------------------+
       |  :white:`10 Giga Rays/s`   |
       +----------------------------+


.. raw:: html 

   <p style="margin-bottom:1cm;" />


.. sidebar:: :small:`2018 : Leap in Ray Tracing speed`

    .. class:: small

         **NVIDIA Quadro RTX GPU**  

         * ray trace dedicated GPU hardware
         * "World's first ray tracing GPU.." 

         :r:`if: 10 rays per photon => 1 billion photons/sec`


.. s5_talk::

    Four years ago NVIDIA announced a leap in ray tracing performance 
    with the Quadro RTX GPU : which it calls the worlds first ray tracing GPU
    As it has hardware dedicated to accelerating ray tracing.

    NVIDIA claims it can reach 10 billion ray geometry intersections per second
    with a single GPU.

    Assuming each simulated photon costs 10 rays, that means the upper limit per GPU is 
    1 billion photons/second.
    





:i:`TURING BUILT FOR RTX 2`
---------------------------------------------------------


.. raw:: html

   <p style="margin-bottom:6cm;" />


.. sidebar:: :small:`Offload Ray Trace to Dedicated HW`

    .. class:: small

        * RT core : BVH traversal + ray tri. intersection
        * frees up general purpose SM 

    .. class:: tiny

        SM : Streaming Multiprocessor

        BVH : Bounding Volume Hierarchy


.. s5_talk::

    The performance jump is done by offloading 
    ray tracing from the general purpose SM (streaming multiprocessor)
    to the fixed function RT core, which frees up the SM. 




:i:`Project Sol`
------------------------------------------------------------------------------


.. sidebar:: :small:`2018: NVIDIA RTX 2080Ti (Turing)`

   .. class:: small

       **"Project Sol" : NVIDIA RTX Demo** 

       real-time cinematic raytracing on single GPU

       * :r:`now possible due to NVIDIA RTX` 


.. s5_talk::

    * this is a frame from an NVIDIA Demo video called "Project Sol"
    * search for "Project Sol" to see the video 
    * movie frames can take hours to render
    * so the surprise with Project Sol is that it runs in real time on a single GPU 
    * this is made possible by NVIDIA RTX: 

      * dedicated GPU hardware for raytracing, texturing and AI-inference 




:small:`Ampere : 2nd Generation RTX`
-----------------------------------------

.. class:: small

   NVIDIA Ampere (2020):
      "...triple double over Turing (2018, 10 GigaRays/s)..."

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 3090** 

     * 10,496 CUDA Cores, 28GB VRAM, USD 1499


   * :redbold:`ray trace performance continues rapid improvement` 


.. s5_talk::

    GPU Ray Tracing performance continue to improve rapidly.
    With Ampere there is a big increase in the numbers of CUDA 
    cores at the same price points.   



:i:`NVIDIA Marbles At Night RTX Demo`
---------------------------------------

``GTC 2020, NVIDIA Marbles at Night RTX Demo``

.. s5_talk::

   This is a recent NVIDIA RTX demo from its launch 
   of 2nd generation RTX

   That can now be done in 1440p at 30 fps on a single Ampere GPU.


:i:`NVIDIA Marbles At Night RTX Demo 2`
-----------------------------------------

``GTC 2020, NVIDIA Marbles at Night RTX Demo``

.. raw:: html

   <p style="margin-bottom:1cm;" />


.. sidebar:: :small:`Realtime RTX render, 1 Ampere GPU`

   .. class:: small

       https://www.youtube.com/watch?v=NgcYLIvlp_k

   .. class:: small

       * **playable demo : guide marbles thru geometry**
       * purely path-traced, no rasterization, no baking
       * hundreds of dynamic ray-traced lights
       * ~100M polygons 
       * AI : DLSS + denoising 
       * 1440p @ 30fps on single Ampere GPU :

       **NVIDIA GeForce RTX 3090 [USD 1499]**

   .. class:: tiny
 
       2560*1440 = 3.7M pixels -> x30 -> 110M pixels/s

       DLSS : Deep Learning Super Sampling 


.. s5_talk::

    Consider how many ray-geometry intersections are being done per second, 
    its probably in the hundreds of millions 

    It is not so easy to estimate as AI trickery is used to reduce
    the number of rays needed by super sampling with DLSS and de-noising.

    Its all ray traced, there is no rasterization being done.
    Everything is dynamic. 





:small:`GPU Ray Tracing (RT) APIs Give Access to NVIDIA RTX`
--------------------------------------------------------------------

.. sidebar:: :small:`Interfaces over NVIDIA Driver`

    .. image:: /env/presentation/nvidia/nvidia_ray_tracing_apis_half.png  
        :width: 500px
        :align: right 

    .. raw:: html

       <p style="margin-bottom:1cm;" />

    .. class:: small

        **Driver Updates** : :redbold:`Independant of Application`

        * new GPU support
        * performance improvements


.. class:: small

   :redbold:`Three Similar Interfaces over same RTX tech:`

   **NVIDIA OptiX (Linux, Windows) [2009]**  

   * CUDA header only access to Driver functionality
   * :r:`Most flexible API, OptiX, is used by Opticks` 

   **Vulkan RT (Linux, Windows) [final spec 2020]**

   * cross-vendor cross-platform RT 

   **Microsoft DXR : DirectX 12 Ray Tracing (Windows) [2018]**

   * enhancing visual quality of realtime games 


.. raw:: html

   <pre>
   </pre>
   <hr/>


.. class:: small

   **Metal Ray Tracing API (macOS) [introduced 2020[1]]** 

   * Very different Integrated GPU : Apple Silicon M1 GPU 
   * BUT: similar API 



.. class:: tiny 

   [1] https://developer.apple.com/videos/play/wwdc2020/10012/

.. s5_talk::

    These three APIs give access to RTX. 
    With OptiX 7 the APIs are converging. 

    The similarities are not surprising : as they are 
    just different interfaces over the same tech from the NVIDIA Driver

    There is also a recent addition to GPU ray tracing APIs 
    from apple.  Despite apples GPUs being very different 




``Spatial Index Acceleration Structure``
---------------------------------------------------


.. raw:: html

    <p style="margin-bottom:11cm;" />

.. sidebar:: :small:`Tree of Bounding Boxes (bbox)`

    .. class:: small

        * aims to minimize bbox+primitive intersects 
        * accelerates ray-geometry intersection


.. s5_talk::

   The principal technique to accelerate ray geometry intersection 
   is an acceleration structure called a bounding volume hierarchy 
   
   This divides space into progressively smaller boxes which forms
   a spatial index.

   Traversing the tree of bounds allows to minimize tests
   needed to find an intersect.

   With some geometry it is possible for the traversal 
   to be done on the dedicated RT cores.






:small:`NVIDIA® OptiX™ Ray Tracing Engine -- http://developer.nvidia.com/optix`
--------------------------------------------------------------------------------

.. sidebar:: OptiX Raytracing Pipeline

    .. class:: small

       Analogous to OpenGL rasterization pipeline:

    .. image:: /env/optix/docs/optix-model.png
       :width: 450px
       :align: right

.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * **accelerates** ray-geometry intersections
   * simple : single-ray programming model
   * "...free to use within any application..."
   * :red:`access RT Cores[1] with OptiX 6+ via RTX™ mode`

   **NVIDIA expertise:**

   * OptiX pre-7 : :redbold:`~linear scaling up to 4 GPUs`
   * acceleration structure creation + traversal (Blue)
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

       ``https://developer.nvidia.com/rtx``

.. class:: small

   **User provides (Yellow):**

   * ray generation
   * geometry bounding box, intersects 


.. class:: tiny

   [1] Turing+ GPUs eg NVIDIA TITAN RTX 



.. s5_talk::

   NVIDIA OptiX makes GPU ray tracing accessible 

   * it divides up the ray tracing workflow 
   * the yellow boxes represent user provided CUDA programs, including:

     * ray generation : where Opticks generates photons and steers the simulation
     * intersection : where the geometry is implemented 

   * geometry has to be translated into a GPU appropriate form


   * NVIDIA OptiX is a CUDA interface to the NVIDIA BVH acceleration structure
   * it is a ray tracing specific compiler




:small:`NVIDIA OptiX 7 : Entirely new thin API (Introduced Aug 2019)`
---------------------------------------------------------------------------------

.. sidebar:: :small:`GPU Ray Tracing APIs Converged`

    .. class:: small

        * 3 APIs (DXR,VKRay,OptiX7) over RTX 
        * Driver updates :r:`independent of application`  
        * Support new GPUs, performance improvements 

.. class:: small

    **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

    * headers only (no library, just Driver) 
    * low-level CUDA-centric thin API (Vulkan-ized)
    * Minimal host state,  :red:`All host functions are thread-safe`
    * GPU launches : explicit, asynchronous (CUDA streams)
    * :strike:`near perfect scaling to 4 GPUs, for free` 
    * :strike:`Shared CPU/GPU geometry context`
    * :strike:`GPU memory management`
    * :strike:`Multi-GPU support`


.. class:: small

    **Advantages**
        More control/flexibility over everything. 

        * Fully benefit from future GPUs
        * :b:`Keep pace with state-of-the-art GPU ray tracing` 

    **Disadvantages**
        Demands much more developer effort than OptiX 6 

        * :r:`Major re-implementation of Opticks required`


    :b:`LATEST: Opticks transition from 6->7 is ongoing`

.. s5_talk::

   * OptiX 7 is an entirely new API, dropping many features used by Opticks
   * re-implementation of large parts of Opticks is necessary
   * i will cover recent progress on this shortly






:i:`Geant4OpticksWorkflow`
----------------------------

.. s5_talk::

    SMALL
    So : how can an external optical photon simulation be integrated with Geant4 ?

    In the standard workflow the Geant4 Scintillation and 
    Cerenkov processes calculate a number of photons 
    and then loop generating these and collecting them 
    as secondaries
     
    In the hybrid workflow, this generation is split 
    between the CPU and GPU with "Gensteps" acting as the bridge. 
    These Genstep parameters include the number of photons, positions and everything 
    else needed in the generation loop.

    The result is a very simple port of the generation loop to the GPU. 

    Its doubly helpful to generate photons on GPU, as then
    they take no CPU memory.
  
    So can entirely offload photon memory to the GPU with only hits needing CPU memory. 

    Also this keeps the overheads low as gensteps are typically a factor of 100 smaller
    than photons.   
 
    The geometry is also needed on the GPU, with all 
    material and surface properties.
     



:i:`Geant4OpticksWorkflow 2`
------------------------------

.. raw:: html

    <p style="margin-bottom:1cm;" />


.. sidebar:: :small:`Integrate NVIDIA OptiX with Geant4`
 
  .. class:: small

     :g:`Geometry Translation` + :b:`"Gensteps"`
       :r:`=> entirely offload photon simulation to GPU` 

     * upload translated geometry at initialization
     * only hits need to consume CPU memory 


.. s5_talk::

    Hybrid Workflow 


:small:`Opticks : Translates G4 Optical Physics to CUDA/OptiX`
----------------------------------------------------------------


.. sidebar:: GPU Resident Photons

    .. class:: small

       **Seeded on GPU** 
          associate photons -> *gensteps* (via seed buffer)
 
       **Generated on GPU, using genstep param:**
         * number of photons to generate
         * start/end position of step

       **Propagated on GPU**
          :red:`Only photons hitting PMTs copied to CPU`


       Thrust: **high level C++ access to CUDA**

       .. figure:: /env/numerics/thrust/thrust.png
          :width: 300px
          :align: right

       * https://developer.nvidia.com/Thrust
       
          

         
.. class:: small

    :blue:`OptiX : single-ray programming model` -> line-by-line translation

    **CUDA Ports of Geant4 classes**
      * G4Cerenkov (only generation loop) 
      * G4Scintillation (only generation loop) 
      * G4OpAbsorption
      * G4OpRayleigh 
      * G4OpBoundaryProcess (only a few surface types)

    **Modify Cherenkov + Scintillation Processes**
      * collect *genstep*, copy to GPU for generation
      * :red:`avoids copying millions of photons to GPU`

    **Scintillator Reemission**
      * fraction of bulk absorbed "reborn" within same thread
      * wavelength generated by reemission texture lookup

    **Opticks (OptiX/Thrust GPU interoperation)** 
      * **OptiX** : upload gensteps 
      * **Thrust** : seeding, distribute genstep indices to photons
      * **OptiX** : launch photon generation and propagation
      * **Thrust** : pullback photons that hit PMTs 
      * **Thrust** : index photon step sequences (optional)



.. s5_talk:: 

    This repeats what I just explained on the diagram

    * essentially the necessary Geant4 optical physics is ported to CUDA

    * the crucial thing to realize is that the photons are GPU resident

      * they are generated, propagated and visualized all in GPU buffers
      * only collected photons need to be copied to the CPU


.. skip

    Some further detail is on the reemissio and also 
    use of CUDA Thrust : which provides a higher level way 
    of using CUDA 





:small:`G4VSolid -> CUDA Intersect Functions for ~10 Primitives`
-------------------------------------------------------------------------------------------------

.. class:: small

   * 3D parametric ray : **ray(x,y,z;t) = rayOrigin  +  t * rayDirection** 
   * implicit equation of primitive : **f(x,y,z) = 0**  
   * -> polynomial in **t** , roots: **t > t_min**  -> intersection positions + surface normals

.. figure:: /env/presentation/tboolean_parade_sep2017.png
   :width: 900px
   :align: center

   Sphere, Cylinder, Disc, Cone, Convex Polyhedron, Hyperboloid, :red:`Torus`, ...


.. s5_talk::

   Geometry starts from primitive shapes.

   NVIDIA OptiX doesnt provide primitives : My Opticks 
   has ray geometry intersection for these shapes implemented 
   with polynomial root finding.




:small:`G4Boolean -> CUDA/OptiX Intersection Program Implementing CSG`
-------------------------------------------------------------------------------------

.. sidebar:: Outside/Inside Unions

    .. class:: small

       dot(normal,rayDir) -> Enter/Exit

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_outside.png
       :width: 300px
       :align: center

    .. image:: /env/presentation/kensler_union_of_two_spheres_from_inside.png
       :width: 300px
       :align: center

    .. class:: small

        * **A + B** boundary not inside other 
        * **A * B** boundary inside other 


.. class:: small

   Complete Binary Tree, pick between pairs of nearest intersects:

   =======================  ===========  ===============  ============== 
   *UNION* tA < tB           Enter B      Exit B           Miss B
   =======================  ===========  ===============  ============== 
   **Enter A**               ReturnA      :blue:`LoopA`    ReturnA
   **Exit A**                ReturnA      ReturnB          ReturnA 
   **Miss A**                ReturnB      ReturnB          ReturnMiss
   =======================  ===========  ===============  ============== 

   * *Nearest hit intersect algorithm* [1] avoids state

     * sometimes :blue:`Loop` : advance **t_min** , re-intersect both 
     * classification shows if inside/outside

   * *Evaluative* [2] implementation emulates recursion: 

     * :red:`recursion not allowed` in OptiX intersect programs
     * bit twiddle traversal of complete binary tree 
     * stacks of postorder slices and intersects 

   * :red:`Identical geometry to Geant4` 

     * solving the same polynomials 
     * near perfect intersection match



.. class:: tiny

    [1] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
        with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
 
    [2] https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h
        Similar to binary expression tree evaluation using postorder traverse. 


.. s5_talk::


    Opticks includes a CUDA CSG (constructive solid geometry) implemented beneath
    the level of OptiX primitives.
    So can intersect with complex compound shapes.

    G4Boolean trees can be translated into Opticks without 
    any approximation.
 



:small:`Opticks : Translates G4 Geometry to GPU, Without Approximation`
------------------------------------------------------------------------------------

.. sidebar:: :small:`Materials/Surfaces -> GPU Texture` 

    .. class:: small

      **Material/Surface/Scintillator properties**

      * interpolated to standard wavelength domain
      * interleaved into "boundary" texture  
      * "reemission" texture for wavelength generation 

      **Material/surface boundary : 4 indices**

      * outer material (parent)
      * outer surface (inward photons, parent -> self)
      * inner surface (outward photons, self -> parent)
      * inner material (self)

      Primitives labelled with unique boundary index

      * ray primitive intersection -> boundary index
      * texture lookup -> material/surface properties

      :red:`simple/fast properties + reemission wavelength`


.. class:: small

    **G4 Structure Tree -> Instance+Global Arrays -> OptiX**

    Group structure into repeated instances + global remainder:

    * auto-identify repeated geometry with "progeny digests"  

      * JUNO : 9 distinct instances + 1 global  

    * instance transforms used in OptiX/OpenGL geometry 

    :red:`instancing -> huge memory savings for JUNO PMTs`




.. raw:: html

    <pre>
    </pre>


.. comment

    **Automated : Geant4 "World" -> Opticks CSG -> CUDA/OptiX**

    **Solids : analytic CSG + triangulated**

    * intersection functions for ~10 primitives
    * intersection program for arbitrarily complex CSG shapes 
     
      * :red:`automated : G4 -> Opticks -> OptiX`  



.. s5_talk::


   The Opticks geometry model starts from the observation that 
   there is lots of repetition in the geometry.  It automatically 
   finds these repeats.

   Bringing optical physics to the GPU was straightforward, 
   because a direct translation could be used.

   The Geant4 geometry model is vastly different to the 
   whats needed on the GPU : making geometry translation
   the most challenging aspect of Opticks.

   And everything needs to be serialized to be copied to the GPU.
     





:small:`Translation 1st Step : Geant4 -> Opticks/GGeo : 1->1 conversions`
------------------------------------------------------------------------------

.. sidebar:: :small:`Geant4 -> Opticks/GGeo -> OptiX`

    .. class:: small

        Multi-stage translation

        **Geant4**
            G4PVPlacement, G4VSolid, G4Material, ...

        **Opticks/GGeo** : :red:`(No Geant4,OptiX dependency)`
            GGeo, GVolume, GParts, GMesh, GMaterial, ... 
            persisted as binary **.npy** file based geocache 

        **Opticks/OptiXRap (for OptiX < 7)**
            OGeo, OScene, OGeometry, OBndLib, ...
            instanciation populates OptiX GPU context   

        **Opticks/CSG (for OptiX 7+)**
            CSGFoundry, CSGSolid, CSGPrim, CSGNode
            :r:`replaces model dropped in 6->7` 

        **OptiX** 
            "IAS", "GAS", ... 


.. class:: small

   **Structural volumes : G4PVPlacement ->**

   *GVolume*
      JUNO: tree of ~300,000 *GVolume* 

   **Solid shapes : G4VSolid ->**
  
   *GMesh* (collected into **GMeshLib**)
      | arrays: vertices, indices
      | ref to *NCSG*

   *NCSG*
       tree of *NNode* (CSG constituents)
 

   **Material/surface properties as function of wavelength**   

   * *G4Material* -> *GMaterial*
   * *G4Logical(Border/Skin)Surface* -> *GSurface* 
   * adopts standard wavelength domain 
   * collected into **GMaterialLib** **GSurfaceLib**


   **Translation steered by X4 package**

   https://bitbucket.org/simoncblyth/opticks/src/master/extg4/X4PhysicalVolume.hh




.. s5_talk::

   Translation of Geant4 into a GPU geometry, is done in several stages.
   The first step is simple 1:1 conversions that prepare for the next stages.



:small:`Translation 2nd Step : Opticks/GGeo Instancing : "Factorizes" Geometry`
----------------------------------------------------------------------------------------


.. sidebar:: :small:`Form of GPU Detector Geometry`

    .. class:: small

        **~10 GAS**
          intersect prog, bufs: bbox, nodes, transforms
            
        **1 IAS in OptiX 7, ~10 in pre-7**
          transforms + refs: **GAS**, ident, boundary tex 

        **Boundary GPU Texture, interleaving:**
          material + surface props


    .. raw:: html

         <hr/>

    .. class:: small

       **JUNO: ~300,000 GVolume -> ~10 GMergedMesh**

       *repeated GMergedMesh* 
          | thousands of instance transforms
          | consolidates < 10 *GVolume* 

       *remainder GMergedMesh* 
          | one identity instance transform
          | consolidates ~ few hundred *GVolume*



.. class:: small

   Structural volumes vs solid shapes 
      | distinction for convenience only, :redbold:`distinction is movable` 

   JUNO: ~300,000 GVolume : **mostly small repeated groups** (PMTs)

   **GGeo/GInstancer**

   0. GVolume **progeny digest** : shapes+transforms -> :red:`subtree ident.` 
   1. find repeated **digests**, disqualifying repeats inside others
   2. label all nodes with repeat index, non-repeated remainder : 0 

   For each repeat+remainder create **GMergedMesh**:

   * collecting transforms, identity -> instance arrays 
   * merged volumes+solids  

     * **GMesh**: concatenated arrays: triangles, indices 
     * **GParts**: concatenated arrays: CSG nodes + transforms  
     * transforms applied -> :red:`gets into instance frame`   
     * :bluebold:`Consolidation : structural volumes -> compound solid`

   **GMergedMesh** -> **IAS+GAS** 
 
      

.. class:: tiny

   https://bitbucket.org/simoncblyth/opticks/src/master/ggeo/GInstancer.hh
     

.. s5_talk::

    * 2nd step of the translation is a factorization into geometry instances.

    * (GO THRU)

    * The GMergedMesh combines structural info in the form of instance transforms 
      together with concatenated solids. 




.. comment

    :small:`Ray Intersection with Transformed Object -> Geometry Instancing`
    -----------------------------------------------------------------------------


    .. |H2O| replace:: H\ :sub:`2`\ O

    .. |IM| replace:: M\ :sup:`-1`

    .. |IMT| replace:: M\ :sup:`-1T`

    .. |NP| replace:: N\' 


    .. figure:: /env/presentation/instancing/ray_intersection_in_two_spaces_p308_shirley_ch13_half.png
        :width: 700px
        :align: right

        .. class:: small

            Fig 13.5 "Realistic Ray Tracing", Peter Shirley

        .. class:: normal

            :redbold:`Advantages apply equally to acceleration structures`

    .. class:: small

       **Equivalent Intersects -> same** *t*

       1. **ray** with *ellipsoid* : **M*p**
       2. |IM| **ray** with *sphere* : **p**

       **Local Frame Advantages**

       1. simpler intersect (sphere vs ellipsoid)
       2. closer to origin -> better precision

       **Geometry Instancing Advantages**

       * many objects share local geometry

         * orient+position with 4x4 **M**

       * huge VRAM saving, less to copy 
       
       **Requirements**

       * must **not** normalize ray direction
       * normals transform differently 

         * |NP| = N * |IMT|   
         * (due to non-uniform scaling) 


    .. s5_talk::

        The basis for instancing is the equivalence of intersects in two spaces.

        For example a ray-ellipsoid intersect is equivalent to in inverse 
        transformed ray intersect with a sphere.

        Local frame intersects advantages...



:small:`"CSGFoundry" : Shared CPU/GPU Geometry Model (OptiX pre-7 & 7)`
-----------------------------------------------------------------------------------------------------

.. sidebar:: :small:`IAS < Inst < Solid < Prim < Node`

    .. class:: small

        * **Inst** : 4x4 tran. + **Solid** ref. ( **Inst** -> 1 **IAS** )
        * **Solid** : 1 or more **Prim**  : ( **Solid** -> **GAS** )
        * **Prim** : 1,3,7,15,31,... **Node**  : (**Prim** ~ *G4VSolid*) 

    .. raw:: html

        <pre class="mypretiny">
        struct CSGFoundry
        {
           void upload(); <span class="redbold">// to GPU </span> 
        ...
           std::vector&lt;CSGSolid&gt;  solid ; // compounds (eg PMT)
           std::vector&lt;CSGPrim&gt;   prim ;
           std::vector&lt;CSGNode&gt;   node ; // shapes, operators

           std::vector&lt;float4&gt; plan ; // planes
           std::vector&lt;qat4&gt;   tran ; // CSG transforms
           std::vector&lt;qat4&gt;   itra ; // inverse CSG transforms
           std::vector&lt;qat4&gt;   inst ; // instance transforms

           <span class="redbold">// entire geometry in four GPU allocations</span>
           CSGPrim*    d_prim ; 
           CSGNode*    d_node ; 
           float4*     d_plan ; 
           qat4*       d_itra ;    
         };
        </pre>

    .. class:: small

        :bluebold:`referencing by offset, count`  

.. class:: small

    * :r:`replaces geometry context dropped in OptiX 6->7` 
    * array-based -> simple, inherent serialization + persisting 
    * entire geometry in 4 GPU allocations 

.. raw:: html

    <pre>
    </pre>

.. class:: small

    :b:`https://bitbucket.org/simoncblyth/opticks/src/master/CSG/`
        **CSGFoundry**
          model, GPU upload
        **csg_intersect_tree.h/csg_intersect_node.h/...**
          :redbold:`simple headers common to pre-7/7/CPU-testing`

    :b:`opticks/src/master/CSG_GGeo/`
      Convert *Opticks/GGeo* -> *CSGFoundry*  

    :b:`opticks/src/master/qudarap/`
      Simulation excluding geometry, generation

    :b:`opticks/src/master/CSGOptiX/`
      OptiX 7 + pre-7 geometry : depends on CSG, QUDARap



.. raw:: html

    <pre>
    </pre>

.. class:: tiny

   **GAS** : Geometry Acceleration Structure

   **IAS** : Instance Acceleration Structure
   
   **CSG** : Constructive Solid Geometry 


.. s5_talk::

   SMALL 
   The Foundry geometry model comprises : Inst, Solid, Prim and Node

   Starting from the bottom:

   * the Node are CSG constituent shapes or operators
   * the Prim reference a range of Node forming serialized complete binary trees
   * the Solid reference one or more Prim
   * the Inst reference one or more Solid 

   **Prim:** are equivalent to G4VSolid

   **Solid:** are compound Prim, each type of PMT corresponds to a Solid 

   **Inst:** are 4x4 transforms with index refererences to Solid 

   The model is designed to work with the OptiX 7 acceleration structures:

   * Solid -> GAS (Geometry Acceleration Structure)
   * Inst  -> IAS (Instance Acceleration Structure)

   The JUNO geometry of 300,000 volumes is factorized into 10 Solid which 
   are referenced from a single instance acceleration structure. 
    
   The array-based simplicity makes it fast to upload to GPU, 
   with the entire geometry in 4 GPU allocations. 






:small:`Two-Level Hierarchy : Instance transforms (IAS) over Geometry (GAS)`
-------------------------------------------------------------------------------

.. class:: small

    **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


.. class:: small

    .. figure:: /env/presentation/nvidia/tlas_blas_two_level_hierarchy.png
        :width: 800px
        :align: right 

        https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

.. class:: small

   AS
      Acceleration Structure

   **IAS** (aka TLAS) 
      :b:`4x4 transforms, refs to GAS`
       
   **GAS** (aka BLAS)
      | :b:`custom primitives : AABB` 
      | triangles : vertices, indices

   AABB
      axis-aligned bounding box 


   **SBT : Shader Binding Table**

   Flexibly binds together:
 
   1. geometry objects
   2. shader programs 
   3. data for shader programs

   **Hidden in OptiX 1-6 APIs**



.. s5_talk::

   OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
   The other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
   This is because OptiX supports multiple instance levels. 
   But the simple two level is faster as that can be done on the RT cores.

   Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  








:i:`Opticks Generality`
-------------------------

.. s5_talk::

    A general Approach to geometry translation for GPU is used however
    every new geometry is likely to have its own issues.

    Getting Opticks to work with many geometries is necessary to
    make it mature a robust tool. 


:i:`Opticks Generality 2`
---------------------------


.. sidebar:: :small:`General Geometry Translation`

    .. class:: small

        :r:`BUT: every new geometry likely to have problems`  

        Geant4 CSG 
           "volume" based CSG in double precision

        Opticks CSG
           surface based intersection in float precision

           * more susceptible to coincident face issues
           * "G4Boolean abuse" solids -> reduced performance 

.. s5_talk::

    Plan to look into optionally improving robustness 
     









:i:`cxr_overview_emm_t0_moi_-1_ALL.jpg`
-----------------------------------------

.. raw:: html

    <pre>



    </pre>


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        "CSGFoundry" CPU/GPU Geometry 

        * :redbold:`purely analytic CSG, no triangles` 
        * everything at default, no optimization


.. s5_talk::

   JUNO render using OptiX 7 with the CSGFoundry model.

   Note that there are no triangles here, this is a purely analytic ray trace with 
   the geometry that the simulation will use.


    
:i:`cxr_overview_emm_t0,_moi_-1.jpg`
-----------------------------------------------------------------

``-e t0, : NOT 0 : 3084:sWorld : exclude global remainder volumes`` 

.. s5_talk::

   Exclude global remainder volumes, ie render only instanced 


:i:`cxr_overview_emm_image_grid_overview`
-------------------------------------------

``Comparison of ray traced render times of different geometry`` 
  ``simple way to find issues, eg over complex CSG, overlarge BBox`` 

.. s5_talk::

   Ray trace rendering performance provides natural way to look for issues


:i:`sWaterTube_image_grid_cxr_view`
-------------------------------------------

``Same viewpoint inside JUNO Central Detector, vary included volumes``
   ``ray trace performance very sensitive to geometry and its modelling => BVH structure``

.. s5_talk::

   Ray trace rendering performance provides natural way to look for issues





.. comment

    :small:`Current JUNO Geometry : Auto-Factorized by "progeny digest"`
    ------------------------------------------------------------------------


    .. sidebar:: :small:`Factorize ~300,000 vol -> 10 comp`

       .. class:: small

            * **ridx**: repeat index
            * **plc**: number of placements of the instance
            * **prim**: number of Prim/volumes in the instance
            * **component**: numPrim:outerPrimName    
     
            :r:`"progeny digest"` characterizes subtree of every volume-node  


    .. class:: tiny

        +----+------+-----+-------------------------------------------+---------------------------+
        |ridx|   plc| prim|   component                               |  note                     |
        +====+======+=====+===========================================+===========================+
        |   0|     1| 3084|   3084:sWorld                             |  non-repeated remainder   |
        +----+------+-----+-------------------------------------------+---------------------------+
        |   1| 25600|    5|   5:PMT_3inch_pmt_solid                   |                           |
        +----+------+-----+-------------------------------------------+   4 types of PMT          +
        |   2| 12612|    5|   5:NNVTMCPPMTsMask                       |                           |
        +----+------+-----+-------------------------------------------+                           +
        |   3|  5000|    5|   5:HamamatsuR12860sMask                  |                           |
        +----+------+-----+-------------------------------------------+                           +
        |   4|  2400|    5|   5:mask_PMT_20inch_vetosMask             |                           |
        +----+------+-----+-------------------------------------------+---------------------------+
        |   5|   590|    1|   1:sStrutBallhead                        |                           |
        +----+------+-----+-------------------------------------------+   4 parts of same         +
        |   6|   590|    1|   1:uni1                                  |   assembly, BUT not       |
        +----+------+-----+-------------------------------------------+   grouped as siblings     +
        |   7|   590|    1|   1:base_steel                            |   (not parent-child)      |
        +----+------+-----+-------------------------------------------+                           +
        |   8|   590|    1|   1:uni_acrylic3                          |                           |
        +----+------+-----+-------------------------------------------+---------------------------+
        |   9|   504|  130|   130:sPanel                              |  repeated parts of TT     |
        +----+------+-----+-------------------------------------------+---------------------------+


    .. class:: small

       * **ridx:0** "remainder" Prim

         * Prim that did not pass instancing criteria, on number of repeats + complexity
         * TODO: tune criteria to instance more, reducing remainder Prim (Expect: 3084->~ 84)  

       * **ridx:1,2,3,4**

         * four types of PMT, all with 5 Prim 

       * **ridx:5,6,7,8**

         * same 590x assembly :redbold:`but not grouped together` : as siblings (not parent-child like PMTs) 
         * TODO: implement instancing of siblings, combining 4 -> 1   


    .. class:: small

       :redbold:`Increasing instancing : reduces memory for geometry -> improved performance`



    .. s5_talk::

       To follow what follows you need to know a bit about the factorization.
       
       300,000 Geant4 volumes are factorized into 10 Foundry Solids, with a lot of Inst 
       referencing them according to the number of placements of each solid.
       
       Repeat index zero corresponds to the remainder volumes with only a single placement.
       These are volumes that were not repeated enough to get instanced.     

       More instancing reduces memory for the geometry and improves performance, so 
       some work to avoid having thousands of remainder volumes is needed.





.. comment

    :i:`j1808_top_rtx`
    --------------------

    .. s5_talk::

       The upshot is that full Geant4 detector geometries
       can be automatically translated into NVIDIA OptiX geometries.

       This is an OptiX ray trace image from the chimney region at the 
       top of the JUNO scintillator sphere.
        

    :i:`j1808_top_ogl`
    --------------------

    .. s5_talk::

       This is an OpenGL rasterized image, using the approximate triangulated 
       geometry. 

       Opticks manages analytic and triangulated geometry together.  





:small:`[Dec 2021] JUNO : OptiX 7 Ray Trace Times ~2M-pix : TITAN RTX`
------------------------------------------------------------------------

.. sidebar:: :small:`Same viewpoint, vary GPU geometry`

   .. class:: small

        * **-e** : controls components : "t" means ~ (NOT) 
        * **time(s)** : GPU ray trace CUDA launch time
        * **relative** : compares to "ONLY PMT" baseline

        **Recent Geometry Fixes**

        * :b:`fix profligate PMT modelling` 
        * :b:`simpler Acrylic fastener` 
        * :b:`avoid overlarge Fastener BBox`  
        * :b:`fix Polycone inner overlap`
 
   .. class:: small

        :r:`Small-ish time range 1:15 (previously 1:600)`
          :r:`suggests no bad bottlenecks remaining`

        **Substantial speedup after fixing geometry issues**

        :b:`ALL PMTs` :  0.0097 -> 0.0061  (x1.6 faster) 

        :b:`ALL` :  0.6240 -> 0.0054 (x155 faster) 


.. comment

   * **3084:sWorld** (too many non-instanced Prim)

.. class:: tiny

    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |idx|        -e|       time(s)    |      relative    |    enabled geometry description 3dbec4dc                                     |
    +===+==========+==================+==================+==============================================================================+
    |  0|        5,|        0.0004    |        0.0643    |    ONLY: 1:sStrutBallhead                                                    |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  1|        9,|        0.0004    |        0.0658    |    ONLY: 130:sPanel                                                          |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  2|        7,|        0.0005    |        0.0782    |    ONLY: 1:base_steel                                                        |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  3|        8,|        0.0006    |        0.0966    |    ONLY: 1:uni_acrylic1                                                      |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  4|        6,|        0.0006    |        0.1009    |    ONLY: 1:uni1                                                              |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  5|        1,|    :b:`0.0009`   |    :b:`0.1476`   |:b:`ONLY: 5:PMT_3inch_pmt_solid`               :b:`FAST cf 20in`              |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  6|        4,|        0.0015    |        0.2386    |    ONLY: 4:mask_PMT_20inch_vetosMask                                         |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  7|        3,|    :r:`0.0033`   |    :r:`0.5373`   |:r:`ONLY: 5:HamamatsuR12860sMask`              :r:`SLOW cf 3in`               |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  8|        0,|        0.0040    |        0.6556    |    ONLY: 3084:sWorld                                                         |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    |  9|        2,|    :r:`0.0040`   |    :r:`0.6627`   |:r:`ONLY: 5:NNVTMCPPMTsMask`                   :r:`SLOW cf 3in`               |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 10|       t4,|        0.0050    |        0.8307    |    EXCL: 4:mask_PMT_20inch_vetosMask                                         |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 11|       t2,|        0.0051    |        0.8391    |    EXCL: 5:NNVTMCPPMTsMask                                                   |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 12|       t3,|        0.0052    |        0.8514    |    EXCL: 5:HamamatsuR12860sMask                                              |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 13|       t6,|        0.0053    |        0.8799    |    EXCL: 1:uni1                                                              |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 14|       t7,|        0.0054    |        0.8809    |    EXCL: 1:base_steel                                                        |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 15|        t0|        0.0054    |        0.8843    |    ALL                                                                       |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 16|       t5,|        0.0054    |        0.8843    |    EXCL: 1:sStrutBallhead                                                    |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 17|       t9,|        0.0054    |        0.8855    |    EXCL: 130:sPanel                                                          |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 18|       t1,|        0.0054    |        0.8860    |    EXCL: 5:PMT_3inch_pmt_solid                                               |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 19|       t8,|        0.0055    |        0.9013    |    EXCL: 1:uni_acrylic1                                                      |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 20|       t0,|        0.0059    |        0.9753    |    EXCL: 3084:sWorld                                                         |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 21|   1,2,3,4|        0.0061    |        1.0000    |    ONLY PMT                                                                  |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+
    | 22|      t8,0|        0.0062    |        1.0217    |    EXCL: 1:uni_acrylic1 3084:sWorld                                          |
    +---+----------+------------------+------------------+------------------------------------------------------------------------------+


.. s5_talk::

    Smallish Relative time Range suggests no major bottlenecks from geometry issues remain 



:small:`Validation of Opticks Simulation by Comparison with Geant4`  
--------------------------------------------------------------------

.. sidebar:: :small:`Random Aligned Bi-Simulation`

    .. class:: small

        Same inputs to *Opticks* and *Geant4*:

        * CPU generated photons 
        * GPU generated randoms, fed to *Geant4*

        Common recording into *OpticksEvents*:

        * compressed photon step record, up to 16 steps
        * persisted as *NumPy* arrays for python analysis   

        Aligned random consumption, direct comparison:

        * ~every **scatter, absorb, reflect, transmit** 
          at matched positions, times, polarization, wavlen



.. class:: small


   **Bi-simulations of all JUNO solids, with millions of photons**

   mis-aligned histories
       mostly < 0.25%, < 0.50% for largest solids    
       
   deviant photons within matched history
       < 0.05% (500/1M) 
 
   **Primary sources of problems**

   * grazing incidence, edge skimmers
   * incidence at constituent solid boundaries 


   **Primary cause : float vs double** 
      
   *Geant4* uses *double* everywhere, *Opticks* only sparingly (observed *double* costing 10x slowdown with RTX) 

   **Conclude** 

   * :blue:`neatly oriented photons more prone to issues than realistic ones`
   * perfect "technical" matching not feasible
   * instead shift validation to more realistic full detector "calibration" situation    


.. s5_talk::

   Opticks is validated by comparison with Geant4. 

   Random Aligned bi-simulation (sidebar) 
   allows direct step-by-step comparison of simulations  
   unclouded by statistical variation.

   So issues show up very clearly.   

   Comparing individual solids shows discrepancies at the fraction of a percent level.

   Main cause is float vs double. 


:i:`scan-pf-check-GUI-TO-SC-BT5-SD`
--------------------------------------

.. s5_talk::

   This GUI allows interactive selection between tens of millions 
   of photons based on their histories.  

   Here its showing the photons that scattered before boundary transmitting straight 
   through to surface detect.

   Its implemented by indexing the photon histories using some very fast 
   GPU big integer sorting provided by CUDA Thrust, 
   and using OpenGL geometry shaders to switch between selections.

   The 64-bit integers hold up to 16 4-bit flags for each step of the photon.

   All of this is done using interop capabilities of OpenGL/CUDA/Thrust and OptiX
   so GPU buffers can be written to and rendered inplace with no copying around.


.. comment

    :small:`Recording the steps of Millions of Photons`  
    ---------------------------------------------------------   

    .. sidebar:: Compression Essential

        .. class:: small

             Domain compression to fit in VRAM 

             * 16 step records per photon -> 256 bytes/photon
             * 10M photons -> 2.56 GB

             **4-bit History Flags at Each Step** 

        .. raw:: html

             <pre class="mypretiny">
             BT : boundary
             BR : boundary reflect 
             SC : bulk scatter
             AB : bulk absorb 
             SD : surface detect 
             SA : surface absorb 
             </pre>

        .. class:: small

             **seqhis**
                 :red:`64-bit integer history sequence`


    .. class:: small

        Up to 16 steps of the photon propagation are recorded.

        **Photon Array** : 4 * *float4* = 512 bits/photon

        * *float4*: position, time  [32 * 4 = 128 bits]
        * *float4*: direction, weight
        * *float4*: polarization, wavelength
        * *float4*: flags: material, boundary, history  

        **Step Record Array** : 2 * *short4* = 2*16*4 = 128 bits/record

        * *short4*: position, time (snorm compressed)  [4*16 = 64 bits]
        * *uchar4*: polarization, wavelength (uchar compressed) [4*8 = 32 bits]
        * *uchar4*: material, history flags [4*8 = 32 bits]  

        Compression uses known domains of position (geometry center, extent),
        time (0:200ns), wavelength, polarization. 


    .. s5_talk::

        When you have millions of photons it is important 
        to consider compression techniques. 

        I mention this detail, because compression of 
        photons is essential when considering how to make 
        propagations re-usable.



:i:`scan-pf-check-GUI-TO-BT5-SD`
----------------------------------

.. s5_talk::

   The GUI also provides interactive time scrubbing of the propagation 
   of tens of millions of photons. 

   This is some nanoseconds later for a different history category. 
  
   I created this GUI to help with debugging the simulation. 


.. comment

     * DELL Precision 7920T Workstation
     * Intel Xeon Silver 4114, 2.2GHz, 40 cores, 65G 
     * NVIDIA Quadro RTX 8000, 48G 

     * DELL Precision 7920T Workstation
     * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 65G  
     * NVIDIA TITAN RTX, 24G
     * NVIDIA TITAN V, 12G


:small:`Performance : Scanning from 1M to 400M Photons`  
---------------------------------------------------------------

.. sidebar:: :small:`Test Hardware + Software`

     .. class:: small

         **Workstation**

         * DELL Precision 7920T Workstation
         * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 62G  
         * NVIDIA Quadro RTX 8000 (48G) 
    
         **Software**

         * Opticks 0.0.0 Alpha 
         * Geant4 10.4p2 
         * NVIDIA OptiX 6.5.0
         * NVIDIA Driver 435.21
         * CUDA 10.1

         **IHEP GPU Cluster**

         * 10 nodes of 8x NVIDIA Tesla GV100 (32G) 




.. class:: small

     **Full JUNO Analytic Geometry j1808v5**

     * "calibration source" genstep at center of scintillator

     **Production Mode : does the minimum**

     * only saves hits  
     * skips : genstep, photon, source, record, sequence, index, ..
     * no *Geant4* propagation (other than at 1M for extrapolation)

     **Multi-Event Running, Measure:**

     :red:`interval` 
       avg time between successive launches, including overheads:
       (upload gensteps + :blue:`launch` + download hits)

     :blue:`launch` 
       avg of 10 OptiX launches


     * overheads < 10% beyond 20M photons



.. s5_talk::

   Emitting millions of photons from the center of the scintillator 
   and timing the interval and launch times of the propagation 
   provides a measure of the performance of a geometry.
   
   By interval, I mean the time between suceessive launches : so this 
   covers all the overheads of copying the gensteps to the GPU and 
   pulling back the hits to the CPU.

   Overheads are less than 10%    



.. comment

    .. sidebar:: :small:`Genstep/Hit Copying Overheads`

         .. class:: small

             **launch**
               time of each OptiX launch (avg of 10)

             **interval, including overhead**
               time between subsequent launches (avg of 9)

             :red:`Mostly < 10% Overhead beyond 20M photons`



.. comment

    ``NVIDIA Quadro RTX 8000 (48G)``
    ----------------------------------

    .. raw:: html

       <div class="mysidebar" style="position: absolute; top:15%; left:65%; width:22%; height:10% ;" >
          <strong> 谢谢 NVIDIA China <br> for loaning the card </strong>
       </div>


    .. s5_talk::

       The GPU used for these tests is the Quadro RTX 8000 with 48GB VRAM.

       Xie-xie to NVIDIA China for loaning the card.  



    .. comment

       update these profilesmry.py plots with::

           scan-plot     ## on workstation    
           scan-pub      ## on laptop with simoncblyth.bitbucket.org clone
           scan-pubrst   ## prepare RST for inclusion at tail 




:i:`scan-pf-1_NHit`
---------------------

.. raw:: html

   <p style="margin-bottom:8cm;" />


.. sidebar:: :small:`Photon Launch Size : VRAM Limited`

     .. class:: small


         **NVIDIA Quadro RTX 8000 (48 GB)**

         * photon 4*4 floats : 64 bytes
         * curandState       : 48 bytes 

         **400M photons** x :blue:`112 bytes` ~ 45G  



.. s5_talk::

    The first check is that you get the expected number of hits 
    as a function of the number of photons.

    The photon parameters takes 64 bytes and curandState takes 48 bytes
     
    So thats 112 bytes per photon, so the limit on the number 
    of photons that can be simulated in a single launch with this 48G 
    GPU is a bit more than 400M.


 





:i:`scan-pf-1_Opticks_vs_Geant4 2`
------------------------------------

.. raw:: html

   <p style="margin-bottom:5cm;" />


.. class:: small

    .. table:: 
        :align: center

        +--------------------+----------------------------+------------------+
        | JUNO analytic, 400M photons from center         |  Speedup         |
        +====================+============================+==================+
        | Geant4 Extrap.     | 95,600 s (26 hrs)          |                  | 
        +--------------------+----------------------------+------------------+
        | Opticks RTX ON (i) | 58 s                       |   1650x          |
        +--------------------+----------------------------+------------------+


.. s5_talk::

   This compares the extrapolated Geant4 propagation time with the Opticks launch
   interval with RTX on.   The speedup is more than a factor of 1500.   Need to 
   use a log scale to make them both visible. 

   For 400M photons, Geant4 takes more than a day, Opticks takes less than a minute.   

   This is with analytic geometry. Speedup is a lot more with triangles.



:i:`scan-pf-1_Opticks_Speedup 2`
---------------------------------

.. raw:: html
  
   <p style="margin-bottom:9cm;" />


.. class:: small

     .. table:: 
        :align: center

        +-------------------------+------------------+------------------+
        | JUNO analytic, 400M photons from center    |   Speedup        |
        +=========================+==================+==================+
        | Opticks RTX ON (i)      | 58s              |   1650x          |
        +-------------------------+------------------+------------------+
        | Opticks RTX OFF (i)     | 275s             |   350x           |
        +-------------------------+------------------+------------------+
        | Geant4 Extrap.          | 95,600s (26 hrs) |                  |
        +-------------------------+------------------+------------------+


.. s5_talk::

    This is the same information shown as a ratio.



:i:`scan-pf-1_RTX_Speedup`
---------------------------------


.. raw:: html
  
   <p style="margin-bottom:11cm;" />
    
.. table:: 
   :align: center

   +-----------------------------------------------------+
   | **5x Speedup from RTX with JUNO analytic geometry** |
   +-----------------------------------------------------+


.. s5_talk::

    Comparing RTX mode OFF to ON shows that the
    dedicated ray tracing hardware is giving a factor of 5.





:small:`Useful Speedup > 1500x : But Why Not Giga Rays/s ? (1 Photon ~10 Rays)`   
----------------------------------------------------------------------------------

.. sidebar:: :small:`100M photon RTX times, avg of 10` 

    .. class:: small

         .. table::
            :widths: 15 5 5 

            +--------------------+-----------+------------------+----------+
            | Launch times for various geometries                          | 
            +--------------------+-----------+------------------+----------+
            | Geometry           | Launch (s)|  Giga Rays/s     | Relative |
            |                    |           |                  | to ana   |
            +====================+===========+==================+==========+
            | JUNO ana           |   13.2    |  0.07            |          |
            +--------------------+-----------+------------------+----------+
            | JUNO tri.sw        |    6.9    |  0.14            |   1.9x   |
            +--------------------+-----------+------------------+----------+
            | JUNO tri.hw        |    2.2    |  0.45            |   6.0x   |
            +--------------------+-----------+------------------+----------+
            |                                                              | 
            +--------------------+-----------+------------------+----------+
            | Boxtest ana        |    0.59   |  1.7             |          |
            +--------------------+-----------+------------------+----------+
            | Boxtest tri.sw     |    0.62   |  1.6             |          |
            +--------------------+-----------+------------------+----------+
            | Boxtest tri.hw     |    0.30   |  3.3             |  1.9x    |
            +--------------------+-----------+------------------+----------+

    .. class:: small

        * ana : Opticks analytic CSG (SM) 
        * tri.sw : software triangle intersect (SM)
        * :red:`tri.hw : hardware triangle intersect (RT)` 

        JUNO 15k triangles, 132M without instancing

        **Simple Boxtest geometry gets into ballpark**

.. class:: small

    * NVIDIA claim : :blue:`10 Giga Rays/s with RT Core` 
    * -> **1 Billion photons per second**

    * **RT cores : built-in triangle intersect + 1-level of instancing**  
    * flatten scene model to avoid SM<->RT roundtrips ?  


.. raw:: html

    <pre>












    </pre>

.. class:: small

    OptiX Performance Tools and Tricks, David Hart, NVIDIA
    https://developer.nvidia.com/siggraph/2019/video/sig915-vid




.. s5_talk::

   NVIDIA claims 10 GigaRays/s

   As each photon costs around 10 rays 
   that means 1 billion photons per second is the upper limit.

   Performance you get is very sensitive to the geometry, 
   both its complexity and how you model it.  Because these result 
   in different BVH.

   And its also necessary to consider what can run in the RT cores.  

   The large dependence on geometry makes me hopeful that there 
   is room for improvement by tuning the geometry modelling.
 



.. comment

        +-----------------------------------+------------------+------------------+-------------------------------+
        |           RTX ON Launch times for 100M photons, (avg of 10)                                             |
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        | Id  |  Geometry                   |  Launch Time (s) |  GigaRays/s      |  Speedup Relative to analytic | 
        +=====+=============================+==================+==================+===============================+
        | pf1 | JUNO analytic CSG           |   13.2           |  0.07            |                               |
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        | pt0 | JUNO triangulated SW        |    6.9           |  0.14            |   1.9x                        |
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        | pt0 | JUNO triangulated HW        |    2.2           |  0.45            |   6.0x                        |
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        |     |                             |                  |                  |                               | 
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        | ph11| Box-in-box analytic CSG     |    0.59          |  1.7             |                               |
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        | ph13| Box-in-box tri(4k) SW       |    0.62          |  1.6             |                               |
        +-----+-----------------------------+------------------+------------------+-------------------------------+
        | ph13| Box-in-box tri(4k) HW       |    0.30          |  3.3             |    1.9x                       |
        +-----+-----------------------------+------------------+------------------+-------------------------------+


    .. class:: tiny

        JUNO: j1808v5, box-in-box: tboolean-box



.. comment

    :small:`Where Next for Opticks ?`
    ----------------------------------------------------


    .. sidebar:: :small:`NVIDIA OptiX 7 : Entirely new API`

        .. class:: small

            * introduced August 2019
            * low-level CUDA-centric thin API
            * :strike:`near perfect scaling to 4 GPUs, for free` 


    .. class:: small

        **JUNO+Opticks into Production** 

        * optimize geometry modelling for RTX
        * full JUNO geometry validation iteration 
        * JUNO offline integration
        * optimize GPU cluster throughput:

          * split/join events to fit VRAM
          * job/node/multi-GPU strategy

        * support OptiX 7, find multi-GPU load balancing approach

    .. raw:: html

        <pre>
        </pre>

    .. class:: small

        **Geant4+Opticks Integration : Work with Geant4 Collaboration** 

        * finalize *Geant4+Opticks* extended example
     
          * aiming for *Geant4* distrib 

        * prototype *Genstep* interface inside *Geant4* 

          * avoid customizing *G4Cerenkov* *G4Scintillation*


    .. raw:: html

        <pre>
        </pre>


    .. class:: small

        **Alpha Development ------>-----------------> Robust Tool**

        * many more users+developers required (current ~10+1)
        * if you have an optical photon simulation problem ... 
        
          * start by joining : https://groups.io/g/opticks

        
    .. s5_talk::

       The next step is bringing Opticks into production usage within JUNO 

       There is considerable interest in Opticks by the Geant4 
       collaboration. The Fermilab Geant4 group is working on 
       making an extended example for inclusion with the Geant4
       distribution.  The CERN Geant4 group is looking at 
       the possibilities to use the Opticks geometry approach more
       widely, eg for gamma simulation in LHC calorimeters.

       Opticks needs many more users and developers, 
       to turn it into an robust tool.  

       There is also a challenge in the form of NVIDIA OptiX 7 
       which has drastically changed its API. A important 
       multi-GPU feature is going away. 

       To regain this requires developing load balancing across multiple GPUs myself.


    .. comment

        * geometry translation help : NEXO, DUNE, LZ  
        * interest -> usage : SABRE, Baikal GVD, KM3Net, MicroBooNE
        * expand interest : scintillator using medical imaging companies 
        * automated geometry translation, but problems inevitable

        * now: sole-developer + ~10 exploratory users from ~5 detectors  
        * needs users+developers, join https://groups.io/g/opticks 


.. comment       

    :small:`Drastically Improved Optical Photon Simulation Performance...`
    -----------------------------------------------------------------------------------------


    .. sidebar:: :small:`How is >1500x possible ?`

         .. class:: small

              **Progress over 30 yrs, Billions of Dollars**

              * industry funded : game, film, design, ... 
              * re-purposed by translating geometry to GPU

                * tree of C++ objects -> arrays -> BVH

              **Photon Simulation ideally suited to GPU**
     
              * millions of photons -> abundantly parallel 
              * simple phys. -> small stack -> many in flight 
              * decoupled -> no synchronization 

             
              


    .. class:: small

      **Three revolutions reinforcing each other:**

      * games -> graphics revolution -> GPU -> cheap TFLOPS
      * internet scale big datasets -> ML revolution
      * computer vision revolution for autonomous vehicles 
        
      :blue:`Deep rivers of development, ripe for re-purposing`
      
      * analogous problems -> solutions
      * :red:`experience across fields essential to find+act on analogies`  

      **Example : DL denoising for faster ray trace convergence**

      * analogous to hit aggregation
      * skip the hits, jump straight to DL smoothed probabilities 

        * :red:`blurs the line between simulation and reconstruction`

    .. raw:: html

       <pre>
       </pre>

    .. class:: small

       **Re-evaluate long held practices in light of new realities:**

       * large ROOT format (C++ object) MC samples repeatedly converted+uploaded to GPU for DL training ... OR:
       * small Genstep NumPy arrays uploaded, dynamically simulated into GPU hit arrays in fractions of a second 


    .. comment

      **Transformative Performance : But how to transform ?**

      * graphics : oldest user of GPUs -> rich palette of techniques 
      * vision spherical CNN -> potential for reconstruction 

      **Dynamically generated simulation feasible ?**

      * current reconstruction -> custom simulation
      * no more : limited MC stats in edge cases 



    .. s5_talk::

       How it is possible for a > 1500 times speedup ?

       Well, I think it is because of the success of Geant4 over 
       20 years have made it too easy just to continue using it, 
       and hope Moores law is going to speed things up.

       Meanwhile, billions of dollars of industry development 
       have gone into improving ray tracing.

       Liberating geometry from the Geant4 object model allows
       all this development effort to be applied to optical photon simulation.



:small:`Overview + Links`
----------------------------------------------------------------

.. sidebar:: :small:`Highlights`

   .. class:: small

      * Benefit from hardware accelerated ray tracing
      * **Opticks > 1500x Geant4** (one Turing GPU) 



.. image:: /env/presentation/1px.png
   :width: 500px
   :height: 50px

..


  *Opticks* : state-of-the-art GPU ray tracing applied to optical photon simulation and
  integrated with *Geant4*, eliminating memory and time bottlenecks.
 


  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 1px


  * :r:`~30yrs/Giga-$ of HW+SW optimization applied to optical simulation`  
  * Drastic speedup -> better detector understanding -> greater precision
  
    * **any simulation limited by optical photons can benefit** 
    * more photon limited -> more overall speedup (99% -> 100x) 

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 10px



.. table::
    :align: center

    +----------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks    | code repository                         |                   
    +----------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io             | presentations and videos                |
    +----------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                  | forum/mailing list archive              |
    +----------------------------------------------+-----------------------------------------+
    | email:opticks+subscribe@groups.io            | subscribe to mailing list               |
    +----------------------------------------------+-----------------------------------------+ 


.. comment

  *Opticks* uses hardware accelerated GPU ray tracing
  via NVIDIA OptiX to give **effectively zero time and zero CPU memory** 
  optical photon simulation to *Geant4* applications.



.. s5_talk::

   Opticks applies the best available GPU ray tracing to optical 
   photon simulation resulting in speedups exceeding three orders of magnitude.

   Opticks is still very young and it really needs users (and developers) 
   to turn it into a robust tool that anyone with an optical photon simulation problem 
   can use to elimate.

   These speedups are just for the optical photons, how much that 
   helps with the overall speedup depends on how limited you are by 
   optical photons.


    

:i:`geocache_360`
---------------------------------------------------------


.. s5_talk::

    This is a 360 degree view of the all the JUNO central detector PMTs,
    which I used a raytracing benchmark.  

    Its an equirectangular projection.



